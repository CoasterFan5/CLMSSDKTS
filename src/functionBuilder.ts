import { addMethod } from "./builtMethodManager";
import { operationParams, swaggerLikeFormat } from "./swaggerLikeFormat";
import { typesMap } from "./typesMap";

const typeBuilder = (typeName: string, ref: string | undefined) => {
  switch (typeName) {
    case "array":
      return {
        import: `import type {${ref}} from "../models/${ref}"`,
        typeName: `${ref}[]`,
      };
    case "boolean":
      return {
        import: "",
        typeName: "{}",
      };
    case "void":
      return {
        import: "",
        typeName: "void",
      };
    default:
      return {
        import: `import type {${typeName}} from "../models/${typeName}"`,
        typeName: `${typeName}`,
      };
  }
};

export const buildFunction = (args: {
  name: string;
  url: string;
  params: typeof operationParams._type;
  method: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
  returnType: string;
  ref: string | undefined;
}) => {
  const paramList = args.params.map((item) => {
    return `"${item.name}"${item.required ? "" : "?"}: ${typesMap[item.type]}`;
  });
  const paramListString = paramList.join(";");
  const typeDetails = typeBuilder(args.returnType, args.ref);
  addMethod(args.name);
  return ` //Generated by CoasterFan5
  const baseUrl = "${args.url}";
  ${typeDetails.import}

  const method = "${args.method}"

  const urlBuilder = (base: string, items: Record<string, unknown>) => {
    let newUrl = baseUrl
    for (const key in items) {
      newUrl = newUrl.replaceAll(\`{\${key}}\`, \`\${items[key]}\`)
    }

    return base + newUrl
  }

export const ${args.name} = async (token: string, baseUrl: string, params: {
  ${paramListString}
}) => {
  const r = await fetch(urlBuilder(baseUrl, params) + "?per_page=100", {
    method: method,
    headers: {
      "Authorization": "Bearer " + token
    }
  })
  if(r.status != 200) {
    throw r
    return undefined
  }
  return (await r.json()) as ${typeDetails.typeName}
}
`;
};
