/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { CalendarEvent } from '../model/calendarEvent';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum CalendarEventsApiApiKeys {
}

export class CalendarEventsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: CalendarEventsApiApiKeys, value: string) {
        (this.authentications as any)[CalendarEventsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create and return a new calendar event
     * @summary Create a calendar event
     * @param calendarEventContextCode Context code of the course, group, user, or account whose calendar this event should be added to.
     * @param calendarEventTitle Short title for the calendar event.
     * @param calendarEventDescription Longer HTML description of the event.
     * @param calendarEventStartAt Start date/time of the event.
     * @param calendarEventEndAt End date/time of the event.
     * @param calendarEventLocationName Location name of the event.
     * @param calendarEventLocationAddress Location address
     * @param calendarEventTimeZoneEdited Time zone of the user editing the event. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
     * @param calendarEventAllDay When true event is considered to span the whole day and times are ignored.
     * @param calendarEventChildEventDataXStartAt Section-level start time(s) if this is a course event. X can be any identifier, provided that it is consistent across the start_at, end_at and context_code
     * @param calendarEventChildEventDataXEndAt Section-level end time(s) if this is a course event.
     * @param calendarEventChildEventDataXContextCode Context code(s) corresponding to the section-level start and end time(s).
     * @param calendarEventDuplicateCount Number of times to copy/duplicate the event.  Count cannot exceed 200.
     * @param calendarEventDuplicateInterval Defaults to 1 if duplicate &#x60;count&#x60; is set.  The interval between the duplicated events.
     * @param calendarEventDuplicateFrequency Defaults to \\\&quot;weekly\\\&quot;.  The frequency at which to duplicate the event
     * @param calendarEventDuplicateAppendIterator Defaults to false.  If set to &#x60;true&#x60;, an increasing counter number will be appended to the event title when the event is duplicated.  (e.g. Event 1, Event 2, Event 3, etc)
     * @param calendarEventRrule The recurrence rule to create a series of recurring events. Its value is the {https://icalendar.org/iCalendar-RFC-5545/3-8-5-3-recurrence-rule.html iCalendar RRULE} defining how the event repeats. Unending series not supported.
     * @param calendarEventBlackoutDate If the blackout_date is true, this event represents a holiday or some other special day that does not count in course pacing.
     */
    public async createCalendarEvent (calendarEventContextCode: string, calendarEventTitle?: string, calendarEventDescription?: string, calendarEventStartAt?: Date, calendarEventEndAt?: Date, calendarEventLocationName?: string, calendarEventLocationAddress?: string, calendarEventTimeZoneEdited?: string, calendarEventAllDay?: boolean, calendarEventChildEventDataXStartAt?: Date, calendarEventChildEventDataXEndAt?: Date, calendarEventChildEventDataXContextCode?: string, calendarEventDuplicateCount?: number, calendarEventDuplicateInterval?: number, calendarEventDuplicateFrequency?: string, calendarEventDuplicateAppendIterator?: boolean, calendarEventRrule?: string, calendarEventBlackoutDate?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/calendar_events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'calendarEventContextCode' is not null or undefined
        if (calendarEventContextCode === null || calendarEventContextCode === undefined) {
            throw new Error('Required parameter calendarEventContextCode was null or undefined when calling createCalendarEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (calendarEventContextCode !== undefined) {
            localVarFormParams['calendar_event[context_code]'] = ObjectSerializer.serialize(calendarEventContextCode, "string");
        }

        if (calendarEventTitle !== undefined) {
            localVarFormParams['calendar_event[title]'] = ObjectSerializer.serialize(calendarEventTitle, "string");
        }

        if (calendarEventDescription !== undefined) {
            localVarFormParams['calendar_event[description]'] = ObjectSerializer.serialize(calendarEventDescription, "string");
        }

        if (calendarEventStartAt !== undefined) {
            localVarFormParams['calendar_event[start_at]'] = ObjectSerializer.serialize(calendarEventStartAt, "Date");
        }

        if (calendarEventEndAt !== undefined) {
            localVarFormParams['calendar_event[end_at]'] = ObjectSerializer.serialize(calendarEventEndAt, "Date");
        }

        if (calendarEventLocationName !== undefined) {
            localVarFormParams['calendar_event[location_name]'] = ObjectSerializer.serialize(calendarEventLocationName, "string");
        }

        if (calendarEventLocationAddress !== undefined) {
            localVarFormParams['calendar_event[location_address]'] = ObjectSerializer.serialize(calendarEventLocationAddress, "string");
        }

        if (calendarEventTimeZoneEdited !== undefined) {
            localVarFormParams['calendar_event[time_zone_edited]'] = ObjectSerializer.serialize(calendarEventTimeZoneEdited, "string");
        }

        if (calendarEventAllDay !== undefined) {
            localVarFormParams['calendar_event[all_day]'] = ObjectSerializer.serialize(calendarEventAllDay, "boolean");
        }

        if (calendarEventChildEventDataXStartAt !== undefined) {
            localVarFormParams['calendar_event[child_event_data][X][start_at]'] = ObjectSerializer.serialize(calendarEventChildEventDataXStartAt, "Date");
        }

        if (calendarEventChildEventDataXEndAt !== undefined) {
            localVarFormParams['calendar_event[child_event_data][X][end_at]'] = ObjectSerializer.serialize(calendarEventChildEventDataXEndAt, "Date");
        }

        if (calendarEventChildEventDataXContextCode !== undefined) {
            localVarFormParams['calendar_event[child_event_data][X][context_code]'] = ObjectSerializer.serialize(calendarEventChildEventDataXContextCode, "string");
        }

        if (calendarEventDuplicateCount !== undefined) {
            localVarFormParams['calendar_event[duplicate][count]'] = ObjectSerializer.serialize(calendarEventDuplicateCount, "number");
        }

        if (calendarEventDuplicateInterval !== undefined) {
            localVarFormParams['calendar_event[duplicate][interval]'] = ObjectSerializer.serialize(calendarEventDuplicateInterval, "number");
        }

        if (calendarEventDuplicateFrequency !== undefined) {
            localVarFormParams['calendar_event[duplicate][frequency]'] = ObjectSerializer.serialize(calendarEventDuplicateFrequency, "string");
        }

        if (calendarEventDuplicateAppendIterator !== undefined) {
            localVarFormParams['calendar_event[duplicate][append_iterator]'] = ObjectSerializer.serialize(calendarEventDuplicateAppendIterator, "boolean");
        }

        if (calendarEventRrule !== undefined) {
            localVarFormParams['calendar_event[rrule]'] = ObjectSerializer.serialize(calendarEventRrule, "string");
        }

        if (calendarEventBlackoutDate !== undefined) {
            localVarFormParams['calendar_event[blackout_date]'] = ObjectSerializer.serialize(calendarEventBlackoutDate, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Creates and updates \"timetable\" events for a course or course section. Similar to {api:CalendarEventsApiController#set_course_timetable setting a course timetable}, but instead of generating a list of events based on a timetable schedule, this endpoint expects a complete list of events.
     * @summary Create or update events directly for a course timetable
     * @param courseId ID
     * @param courseSectionId Events will be created for the course section specified by course_section_id. If not present, events will be created for the entire course.
     * @param events An array of event objects to use.
     * @param eventsStartAt Start time for the event
     * @param eventsEndAt End time for the event
     * @param eventsLocationName Location name for the event
     * @param eventsCode A unique identifier that can be used to update the event at a later time If one is not specified, an identifier will be generated based on the start and end times
     * @param eventsTitle Title for the meeting. If not present, will default to the associated course\\\&#39;s name
     */
    public async createOrUpdateEventsDirectlyForCourseTimetable (courseId: string, courseSectionId?: string, events?: Array<Array<object>>, eventsStartAt?: Array<Date>, eventsEndAt?: Array<Date>, eventsLocationName?: Array<string>, eventsCode?: Array<string>, eventsTitle?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/calendar_events/timetable_events'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createOrUpdateEventsDirectlyForCourseTimetable.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (courseSectionId !== undefined) {
            localVarFormParams['course_section_id'] = ObjectSerializer.serialize(courseSectionId, "string");
        }

        if (events !== undefined) {
            localVarFormParams['events'] = ObjectSerializer.serialize(events, "Array<Array<object>>");
        }

        if (eventsStartAt !== undefined) {
            localVarFormParams['events[start_at]'] = ObjectSerializer.serialize(eventsStartAt, "Array<Date>");
        }

        if (eventsEndAt !== undefined) {
            localVarFormParams['events[end_at]'] = ObjectSerializer.serialize(eventsEndAt, "Array<Date>");
        }

        if (eventsLocationName !== undefined) {
            localVarFormParams['events[location_name]'] = ObjectSerializer.serialize(eventsLocationName, "Array<string>");
        }

        if (eventsCode !== undefined) {
            localVarFormParams['events[code]'] = ObjectSerializer.serialize(eventsCode, "Array<string>");
        }

        if (eventsTitle !== undefined) {
            localVarFormParams['events[title]'] = ObjectSerializer.serialize(eventsTitle, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete an event from the calendar and return the deleted event
     * @summary Delete a calendar event
     * @param id ID
     * @param cancelReason Reason for deleting/canceling the event.
     * @param which Valid if the event whose ID is in the URL is part of a series. Delete just the event whose ID is in in the URL, all events in the series, or the given event and all those following.
     */
    public async deleteCalendarEvent (id: string, cancelReason?: string, which?: 'one' | 'all' | 'following', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/calendar_events/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCalendarEvent.');
        }

        if (cancelReason !== undefined) {
            localVarQueryParameters['cancel_reason'] = ObjectSerializer.serialize(cancelReason, "string");
        }

        if (which !== undefined) {
            localVarQueryParameters['which'] = ObjectSerializer.serialize(which, "'one' | 'all' | 'following'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the last timetable set by the {api:CalendarEventsApiController#set_course_timetable Set a course timetable} endpoint
     * @summary Get course timetable
     * @param courseId ID
     */
    public async getCourseTimetable (courseId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/calendar_events/timetable'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getCourseTimetable.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Get a single calendar event or assignment
     * @param id ID
     */
    public async getSingleCalendarEventOrAssignment (id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CalendarEvent;  }> {
        const localVarPath = this.basePath + '/v1/calendar_events/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSingleCalendarEventOrAssignment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CalendarEvent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CalendarEvent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve the paginated list of calendar events or assignments for the current user
     * @summary List calendar events
     * @param type Defaults to \&quot;event\&quot;
     * @param startDate Only return events since the start_date (inclusive). Defaults to today. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
     * @param endDate Only return events before the end_date (inclusive). Defaults to start_date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ. If end_date is the same as start_date, then only events on that day are returned.
     * @param undated Defaults to false (dated events only). If true, only return undated events and ignore start_date and end_date.
     * @param allEvents Defaults to false (uses start_date, end_date, and undated criteria). If true, all events are returned, ignoring start_date, end_date, and undated criteria.
     * @param contextCodes List of context codes of courses, groups, users, or accounts whose events you want to see. If not specified, defaults to the current user (i.e personal calendar, no course/group events). Limited to 10 context codes, additional ones are ignored. The format of this field is the context type, followed by an underscore, followed by the context id. For example: course_42
     * @param excludes Array of attributes to exclude. Possible values are \&quot;description\&quot;, \&quot;child_events\&quot; and \&quot;assignment\&quot;
     * @param includes Array of optional attributes to include. Possible values are \&quot;web_conference\&quot; and \&quot;series_natural_language\&quot;
     * @param importantDates Defaults to false. If true, only events with important dates set to true will be returned.
     * @param blackoutDate Defaults to false. If true, only events with blackout date set to true will be returned.
     */
    public async listCalendarEvents (type?: 'event' | 'assignment' | 'sub_assignment', startDate?: string, endDate?: string, undated?: boolean, allEvents?: boolean, contextCodes?: Array<string>, excludes?: Array<Array<object>>, includes?: Array<Array<object>>, importantDates?: boolean, blackoutDate?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<CalendarEvent>;  }> {
        const localVarPath = this.basePath + '/v1/calendar_events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'event' | 'assignment' | 'sub_assignment'");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['start_date'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['end_date'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (undated !== undefined) {
            localVarQueryParameters['undated'] = ObjectSerializer.serialize(undated, "boolean");
        }

        if (allEvents !== undefined) {
            localVarQueryParameters['all_events'] = ObjectSerializer.serialize(allEvents, "boolean");
        }

        if (contextCodes !== undefined) {
            localVarQueryParameters['context_codes'] = ObjectSerializer.serialize(contextCodes, "Array<string>");
        }

        if (excludes !== undefined) {
            localVarQueryParameters['excludes'] = ObjectSerializer.serialize(excludes, "Array<Array<object>>");
        }

        if (includes !== undefined) {
            localVarQueryParameters['includes'] = ObjectSerializer.serialize(includes, "Array<Array<object>>");
        }

        if (importantDates !== undefined) {
            localVarQueryParameters['important_dates'] = ObjectSerializer.serialize(importantDates, "boolean");
        }

        if (blackoutDate !== undefined) {
            localVarQueryParameters['blackout_date'] = ObjectSerializer.serialize(blackoutDate, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<CalendarEvent>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<CalendarEvent>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve the paginated list of calendar events or assignments for the specified user. To view calendar events for a user other than yourself, you must either be an observer of that user or an administrator.
     * @summary List calendar events for a user
     * @param userId ID
     * @param type Defaults to \&quot;event\&quot;
     * @param startDate Only return events since the start_date (inclusive). Defaults to today. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
     * @param endDate Only return events before the end_date (inclusive). Defaults to start_date. The value should be formatted as: yyyy-mm-dd or ISO 8601 YYYY-MM-DDTHH:MM:SSZ. If end_date is the same as start_date, then only events on that day are returned.
     * @param undated Defaults to false (dated events only). If true, only return undated events and ignore start_date and end_date.
     * @param allEvents Defaults to false (uses start_date, end_date, and undated criteria). If true, all events are returned, ignoring start_date, end_date, and undated criteria.
     * @param contextCodes List of context codes of courses, groups, users, or accounts whose events you want to see. If not specified, defaults to the current user (i.e personal calendar, no course/group events). Limited to 10 context codes, additional ones are ignored. The format of this field is the context type, followed by an underscore, followed by the context id. For example: course_42
     * @param excludes Array of attributes to exclude. Possible values are \&quot;description\&quot;, \&quot;child_events\&quot; and \&quot;assignment\&quot;
     * @param submissionTypes When type is \&quot;assignment\&quot;, specifies the allowable submission types for returned assignments. Ignored if type is not \&quot;assignment\&quot; or if exclude_submission_types is provided.
     * @param excludeSubmissionTypes When type is \&quot;assignment\&quot;, specifies the submission types to be excluded from the returned assignments. Ignored if type is not \&quot;assignment\&quot;.
     * @param includes Array of optional attributes to include. Possible values are \&quot;web_conference\&quot; and \&quot;series_natural_language\&quot;
     * @param importantDates Defaults to false If true, only events with important dates set to true will be returned.
     * @param blackoutDate Defaults to false If true, only events with blackout date set to true will be returned.
     */
    public async listCalendarEventsForUser (userId: string, type?: 'event' | 'assignment', startDate?: string, endDate?: string, undated?: boolean, allEvents?: boolean, contextCodes?: Array<string>, excludes?: Array<Array<object>>, submissionTypes?: Array<Array<object>>, excludeSubmissionTypes?: Array<Array<object>>, includes?: Array<Array<object>>, importantDates?: boolean, blackoutDate?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<CalendarEvent>;  }> {
        const localVarPath = this.basePath + '/v1/users/{user_id}/calendar_events'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling listCalendarEventsForUser.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'event' | 'assignment'");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['start_date'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['end_date'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (undated !== undefined) {
            localVarQueryParameters['undated'] = ObjectSerializer.serialize(undated, "boolean");
        }

        if (allEvents !== undefined) {
            localVarQueryParameters['all_events'] = ObjectSerializer.serialize(allEvents, "boolean");
        }

        if (contextCodes !== undefined) {
            localVarQueryParameters['context_codes'] = ObjectSerializer.serialize(contextCodes, "Array<string>");
        }

        if (excludes !== undefined) {
            localVarQueryParameters['excludes'] = ObjectSerializer.serialize(excludes, "Array<Array<object>>");
        }

        if (submissionTypes !== undefined) {
            localVarQueryParameters['submission_types'] = ObjectSerializer.serialize(submissionTypes, "Array<Array<object>>");
        }

        if (excludeSubmissionTypes !== undefined) {
            localVarQueryParameters['exclude_submission_types'] = ObjectSerializer.serialize(excludeSubmissionTypes, "Array<Array<object>>");
        }

        if (includes !== undefined) {
            localVarQueryParameters['includes'] = ObjectSerializer.serialize(includes, "Array<Array<object>>");
        }

        if (importantDates !== undefined) {
            localVarQueryParameters['important_dates'] = ObjectSerializer.serialize(importantDates, "boolean");
        }

        if (blackoutDate !== undefined) {
            localVarQueryParameters['blackout_date'] = ObjectSerializer.serialize(blackoutDate, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<CalendarEvent>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<CalendarEvent>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Reserves a particular time slot and return the new reservation
     * @summary Reserve a time slot
     * @param id ID
     * @param participantId User or group id for whom you are making the reservation (depends on the participant type). Defaults to the current user (or user\\\&#39;s candidate group).
     * @param comments Comments to associate with this reservation
     * @param cancelExisting Defaults to false. If true, cancel any previous reservation(s) for this participant and appointment group.
     */
    public async reserveTimeSlot (id: string, participantId?: string, comments?: string, cancelExisting?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/calendar_events/{id}/reservations'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling reserveTimeSlot.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (participantId !== undefined) {
            localVarFormParams['participant_id'] = ObjectSerializer.serialize(participantId, "string");
        }

        if (comments !== undefined) {
            localVarFormParams['comments'] = ObjectSerializer.serialize(comments, "string");
        }

        if (cancelExisting !== undefined) {
            localVarFormParams['cancel_existing'] = ObjectSerializer.serialize(cancelExisting, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Reserves a particular time slot and return the new reservation
     * @summary Reserve a time slot
     * @param id ID
     * @param participantId User or group id for whom you are making the reservation (depends on the participant type). Defaults to the current user (or user\&#39;s candidate group).
     * @param comments Comments to associate with this reservation
     * @param cancelExisting Defaults to false. If true, cancel any previous reservation(s) for this participant and appointment group.
     */
    public async reserveTimeSlotParticipantId (id: string, participantId: string, comments?: string, cancelExisting?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/calendar_events/{id}/reservations/{participant_id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'participant_id' + '}', encodeURIComponent(String(participantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling reserveTimeSlotParticipantId.');
        }

        // verify required parameter 'participantId' is not null or undefined
        if (participantId === null || participantId === undefined) {
            throw new Error('Required parameter participantId was null or undefined when calling reserveTimeSlotParticipantId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (comments !== undefined) {
            localVarFormParams['comments'] = ObjectSerializer.serialize(comments, "string");
        }

        if (cancelExisting !== undefined) {
            localVarFormParams['cancel_existing'] = ObjectSerializer.serialize(cancelExisting, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Creates and updates the enabled_account_calendars and mark_feature_as_seen user preferences
     * @summary Save enabled account calendars
     * @param markFeatureAsSeen Flag to mark account calendars feature as seen
     * @param enabledAccountCalendars An array of account Ids to remember in the calendars list of the user
     */
    public async saveEnabledAccountCalendars (markFeatureAsSeen?: boolean, enabledAccountCalendars?: Array<Array<object>>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/calendar_events/save_enabled_account_calendars';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (markFeatureAsSeen !== undefined) {
            localVarFormParams['mark_feature_as_seen'] = ObjectSerializer.serialize(markFeatureAsSeen, "boolean");
        }

        if (enabledAccountCalendars !== undefined) {
            localVarFormParams['enabled_account_calendars'] = ObjectSerializer.serialize(enabledAccountCalendars, "Array<Array<object>>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Creates and updates \"timetable\" events for a course. Can automaticaly generate a series of calendar events based on simple schedules (e.g. \"Monday and Wednesday at 2:00pm\" )  Existing timetable events for the course and course sections will be updated if they still are part of the timetable. Otherwise, they will be deleted.
     * @summary Set a course timetable
     * @param courseId ID
     * @param timetablesCourseSectionId An array of timetable objects for the course section specified by course_section_id. If course_section_id is set to \\\&quot;all\\\&quot;, events will be created for the entire course.
     * @param timetablesCourseSectionIdWeekdays A comma-separated list of abbreviated weekdays (Mon-Monday, Tue-Tuesday, Wed-Wednesday, Thu-Thursday, Fri-Friday, Sat-Saturday, Sun-Sunday)
     * @param timetablesCourseSectionIdStartTime Time to start each event at (e.g. \\\&quot;9:00 am\\\&quot;)
     * @param timetablesCourseSectionIdEndTime Time to end each event at (e.g. \\\&quot;9:00 am\\\&quot;)
     * @param timetablesCourseSectionIdLocationName A location name to set for each event
     */
    public async setCourseTimetable (courseId: string, timetablesCourseSectionId?: Array<Array<object>>, timetablesCourseSectionIdWeekdays?: Array<string>, timetablesCourseSectionIdStartTime?: Array<string>, timetablesCourseSectionIdEndTime?: Array<string>, timetablesCourseSectionIdLocationName?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/calendar_events/timetable'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling setCourseTimetable.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (timetablesCourseSectionId !== undefined) {
            localVarFormParams['timetables[course_section_id]'] = ObjectSerializer.serialize(timetablesCourseSectionId, "Array<Array<object>>");
        }

        if (timetablesCourseSectionIdWeekdays !== undefined) {
            localVarFormParams['timetables[course_section_id][weekdays]'] = ObjectSerializer.serialize(timetablesCourseSectionIdWeekdays, "Array<string>");
        }

        if (timetablesCourseSectionIdStartTime !== undefined) {
            localVarFormParams['timetables[course_section_id][start_time]'] = ObjectSerializer.serialize(timetablesCourseSectionIdStartTime, "Array<string>");
        }

        if (timetablesCourseSectionIdEndTime !== undefined) {
            localVarFormParams['timetables[course_section_id][end_time]'] = ObjectSerializer.serialize(timetablesCourseSectionIdEndTime, "Array<string>");
        }

        if (timetablesCourseSectionIdLocationName !== undefined) {
            localVarFormParams['timetables[course_section_id][location_name]'] = ObjectSerializer.serialize(timetablesCourseSectionIdLocationName, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update and return a calendar event
     * @summary Update a calendar event
     * @param id ID
     * @param calendarEventContextCode Context code of the course, group, user, or account to move this event to. Scheduler appointments and events with section-specific times cannot be moved between calendars.
     * @param calendarEventTitle Short title for the calendar event.
     * @param calendarEventDescription Longer HTML description of the event.
     * @param calendarEventStartAt Start date/time of the event.
     * @param calendarEventEndAt End date/time of the event.
     * @param calendarEventLocationName Location name of the event.
     * @param calendarEventLocationAddress Location address
     * @param calendarEventTimeZoneEdited Time zone of the user editing the event. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
     * @param calendarEventAllDay When true event is considered to span the whole day and times are ignored.
     * @param calendarEventChildEventDataXStartAt Section-level start time(s) if this is a course event. X can be any identifier, provided that it is consistent across the start_at, end_at and context_code
     * @param calendarEventChildEventDataXEndAt Section-level end time(s) if this is a course event.
     * @param calendarEventChildEventDataXContextCode Context code(s) corresponding to the section-level start and end time(s).
     * @param calendarEventRrule Valid if the event whose ID is in the URL is part of a series. This defines the shape of the recurring event series after it\\\&#39;s updated. Its value is the iCalendar RRULE. Unending series are not supported.
     * @param which Valid if the event whose ID is in the URL is part of a series. Update just the event whose ID is in in the URL, all events in the series, or the given event and all those following. Some updates may create a new series. For example, changing the start time of this and all following events from the middle of a series.
     * @param calendarEventBlackoutDate If the blackout_date is true, this event represents a holiday or some other special day that does not count in course pacing.
     */
    public async updateCalendarEvent (id: string, calendarEventContextCode?: string, calendarEventTitle?: string, calendarEventDescription?: string, calendarEventStartAt?: Date, calendarEventEndAt?: Date, calendarEventLocationName?: string, calendarEventLocationAddress?: string, calendarEventTimeZoneEdited?: string, calendarEventAllDay?: boolean, calendarEventChildEventDataXStartAt?: Date, calendarEventChildEventDataXEndAt?: Date, calendarEventChildEventDataXContextCode?: string, calendarEventRrule?: string, which?: string, calendarEventBlackoutDate?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/calendar_events/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCalendarEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (calendarEventContextCode !== undefined) {
            localVarFormParams['calendar_event[context_code]'] = ObjectSerializer.serialize(calendarEventContextCode, "string");
        }

        if (calendarEventTitle !== undefined) {
            localVarFormParams['calendar_event[title]'] = ObjectSerializer.serialize(calendarEventTitle, "string");
        }

        if (calendarEventDescription !== undefined) {
            localVarFormParams['calendar_event[description]'] = ObjectSerializer.serialize(calendarEventDescription, "string");
        }

        if (calendarEventStartAt !== undefined) {
            localVarFormParams['calendar_event[start_at]'] = ObjectSerializer.serialize(calendarEventStartAt, "Date");
        }

        if (calendarEventEndAt !== undefined) {
            localVarFormParams['calendar_event[end_at]'] = ObjectSerializer.serialize(calendarEventEndAt, "Date");
        }

        if (calendarEventLocationName !== undefined) {
            localVarFormParams['calendar_event[location_name]'] = ObjectSerializer.serialize(calendarEventLocationName, "string");
        }

        if (calendarEventLocationAddress !== undefined) {
            localVarFormParams['calendar_event[location_address]'] = ObjectSerializer.serialize(calendarEventLocationAddress, "string");
        }

        if (calendarEventTimeZoneEdited !== undefined) {
            localVarFormParams['calendar_event[time_zone_edited]'] = ObjectSerializer.serialize(calendarEventTimeZoneEdited, "string");
        }

        if (calendarEventAllDay !== undefined) {
            localVarFormParams['calendar_event[all_day]'] = ObjectSerializer.serialize(calendarEventAllDay, "boolean");
        }

        if (calendarEventChildEventDataXStartAt !== undefined) {
            localVarFormParams['calendar_event[child_event_data][X][start_at]'] = ObjectSerializer.serialize(calendarEventChildEventDataXStartAt, "Date");
        }

        if (calendarEventChildEventDataXEndAt !== undefined) {
            localVarFormParams['calendar_event[child_event_data][X][end_at]'] = ObjectSerializer.serialize(calendarEventChildEventDataXEndAt, "Date");
        }

        if (calendarEventChildEventDataXContextCode !== undefined) {
            localVarFormParams['calendar_event[child_event_data][X][context_code]'] = ObjectSerializer.serialize(calendarEventChildEventDataXContextCode, "string");
        }

        if (calendarEventRrule !== undefined) {
            localVarFormParams['calendar_event[rrule]'] = ObjectSerializer.serialize(calendarEventRrule, "string");
        }

        if (which !== undefined) {
            localVarFormParams['which'] = ObjectSerializer.serialize(which, "string");
        }

        if (calendarEventBlackoutDate !== undefined) {
            localVarFormParams['calendar_event[blackout_date]'] = ObjectSerializer.serialize(calendarEventBlackoutDate, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
