/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ExternalToolsApiApiKeys {
}

export class ExternalToolsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ExternalToolsApiApiKeys, value: string) {
        (this.authentications as any)[ExternalToolsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Add the specified editor_button external tool to a preferred location in the RCE for courses in the given account and its subaccounts (if the subaccounts haven\'t set their own RCE Favorites). Cannot set more than 2 RCE Favorites.
     * @summary Add tool to RCE Favorites
     * @param accountId ID
     * @param id ID
     */
    public async addToolToRceFavorites (accountId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/external_tools/rce_favorites/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling addToolToRceFavorites.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addToolToRceFavorites.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Adds a dedicated button in Top Navigation for the specified tool for the given account. Cannot set more than 2 top_navigation Favorites.
     * @summary Add tool to Top Navigation Favorites
     * @param accountId ID
     * @param id ID
     */
    public async addToolToTopNavigationFavorites (accountId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/external_tools/top_nav_favorites/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling addToolToTopNavigationFavorites.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addToolToTopNavigationFavorites.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create an external tool in the specified course/account. The created tool will be returned, see the \"show\" endpoint for an example. If a client ID is supplied canvas will attempt to create a context external tool using the LTI 1.3 standard.
     * @summary Create an external tool
     * @param accountId ID
     * @param clientId The client id is attached to the developer key. If supplied all other parameters are unnecessary and will be ignored
     * @param name The name of the tool
     * @param privacyLevel How much user information to send to the external tool.
     * @param consumerKey The consumer key for the external tool
     * @param sharedSecret The shared secret with the external tool
     * @param description A description of the tool
     * @param url The url to match links against. Either \\\&quot;url\\\&quot; or \\\&quot;domain\\\&quot; should be set, not both.
     * @param domain The domain to match links against. Either \\\&quot;url\\\&quot; or \\\&quot;domain\\\&quot; should be set, not both.
     * @param iconUrl The url of the icon to show for this tool
     * @param text The default text to show for this tool
     * @param customFieldsFieldName Custom fields that will be sent to the tool consumer; can be used multiple times
     * @param isRceFavorite (Deprecated in favor of {api:ExternalToolsController#add_rce_favorite Add tool to RCE Favorites} and {api:ExternalToolsController#remove_rce_favorite Remove tool from RCE Favorites}) Whether this tool should appear in a preferred location in the RCE. This only applies to tools in root account contexts that have an editor button placement.
     * @param accountNavigationUrl The url of the external tool for account navigation
     * @param accountNavigationEnabled Set this to enable this feature
     * @param accountNavigationText The text that will show on the left-tab in the account navigation
     * @param accountNavigationSelectionWidth The width of the dialog the tool is launched in
     * @param accountNavigationSelectionHeight The height of the dialog the tool is launched in
     * @param accountNavigationDisplayType The layout type to use when launching the tool. Must be \\\&quot;full_width\\\&quot;, \\\&quot;full_width_in_context\\\&quot;, \\\&quot;full_width_with_nav\\\&quot;, \\\&quot;in_nav_context\\\&quot;, \\\&quot;borderless\\\&quot;, or \\\&quot;default\\\&quot;
     * @param userNavigationUrl The url of the external tool for user navigation
     * @param userNavigationEnabled Set this to enable this feature
     * @param userNavigationText The text that will show on the left-tab in the user navigation
     * @param userNavigationVisibility Who will see the navigation tab. \\\&quot;admins\\\&quot; for admins, \\\&quot;public\\\&quot; or \\\&quot;members\\\&quot; for everyone. Setting this to &#x60;null&#x60; will remove this configuration and use the default behavior, which is \\\&quot;public\\\&quot;.
     * @param courseHomeSubNavigationUrl The url of the external tool for right-side course home navigation menu
     * @param courseHomeSubNavigationEnabled Set this to enable this feature
     * @param courseHomeSubNavigationText The text that will show on the right-side course home navigation menu
     * @param courseHomeSubNavigationIconUrl The url of the icon to show in the right-side course home navigation menu
     * @param courseNavigationEnabled Set this to enable this feature
     * @param courseNavigationText The text that will show on the left-tab in the course navigation
     * @param courseNavigationVisibility Who will see the navigation tab. \\\&quot;admins\\\&quot; for course admins, \\\&quot;members\\\&quot; for students, \\\&quot;public\\\&quot; for everyone. Setting this to &#x60;null&#x60; will remove this configuration and use the default behavior, which is \\\&quot;public\\\&quot;.
     * @param courseNavigationWindowTarget Determines how the navigation tab will be opened. \\\&quot;_blank\\\&quot; Launches the external tool in a new window or tab. \\\&quot;_self\\\&quot; (Default) Launches the external tool in an iframe inside of Canvas.
     * @param courseNavigationDefault If set to \\\&quot;disabled\\\&quot; the tool will not appear in the course navigation until a teacher explicitly enables it.  If set to \\\&quot;enabled\\\&quot; the tool will appear in the course navigation without requiring a teacher to explicitly enable it.  defaults to \\\&quot;enabled\\\&quot;
     * @param courseNavigationDisplayType The layout type to use when launching the tool. Must be \\\&quot;full_width\\\&quot;, \\\&quot;full_width_in_context\\\&quot;, \\\&quot;full_width_with_nav\\\&quot;, \\\&quot;in_nav_context\\\&quot;, \\\&quot;borderless\\\&quot;, or \\\&quot;default\\\&quot;
     * @param editorButtonUrl The url of the external tool
     * @param editorButtonEnabled Set this to enable this feature
     * @param editorButtonIconUrl The url of the icon to show in the WYSIWYG editor
     * @param editorButtonSelectionWidth The width of the dialog the tool is launched in
     * @param editorButtonSelectionHeight The height of the dialog the tool is launched in
     * @param editorButtonMessageType Set this to ContentItemSelectionRequest to tell the tool to use content-item; otherwise, omit
     * @param homeworkSubmissionUrl The url of the external tool
     * @param homeworkSubmissionEnabled Set this to enable this feature
     * @param homeworkSubmissionText The text that will show on the homework submission tab
     * @param homeworkSubmissionMessageType Set this to ContentItemSelectionRequest to tell the tool to use content-item; otherwise, omit
     * @param linkSelectionUrl The url of the external tool
     * @param linkSelectionEnabled Set this to enable this feature
     * @param linkSelectionText The text that will show for the link selection text
     * @param linkSelectionMessageType Set this to ContentItemSelectionRequest to tell the tool to use content-item; otherwise, omit
     * @param migrationSelectionUrl The url of the external tool
     * @param migrationSelectionEnabled Set this to enable this feature
     * @param migrationSelectionMessageType Set this to ContentItemSelectionRequest to tell the tool to use content-item; otherwise, omit
     * @param toolConfigurationUrl The url of the external tool
     * @param toolConfigurationEnabled Set this to enable this feature
     * @param toolConfigurationMessageType Set this to ContentItemSelectionRequest to tell the tool to use content-item; otherwise, omit
     * @param toolConfigurationPreferSisEmail Set this to default the lis_person_contact_email_primary to prefer provisioned sis_email; otherwise, omit
     * @param resourceSelectionUrl The url of the external tool
     * @param resourceSelectionEnabled Set this to enable this feature. If set to false, not_selectable must also be set to true in order to hide this tool from the selection UI in modules and assignments.
     * @param resourceSelectionIconUrl The url of the icon to show in the module external tool list
     * @param resourceSelectionSelectionWidth The width of the dialog the tool is launched in
     * @param resourceSelectionSelectionHeight The height of the dialog the tool is launched in
     * @param configType Configuration can be passed in as CC xml instead of using query parameters. If this value is \\\&quot;by_url\\\&quot; or \\\&quot;by_xml\\\&quot; then an xml configuration will be expected in either the \\\&quot;config_xml\\\&quot; or \\\&quot;config_url\\\&quot; parameter. Note that the name parameter overrides the tool name provided in the xml
     * @param configXml XML tool configuration, as specified in the CC xml specification. This is required if \\\&quot;config_type\\\&quot; is set to \\\&quot;by_xml\\\&quot;
     * @param configUrl URL where the server can retrieve an XML tool configuration, as specified in the CC xml specification. This is required if \\\&quot;config_type\\\&quot; is set to \\\&quot;by_url\\\&quot;
     * @param notSelectable Default: false. If set to true, and if resource_selection is set to false, the tool won\\\&#39;t show up in the external tool selection UI in modules and assignments
     * @param oauthCompliant Default: false, if set to true LTI query params will not be copied to the post body.
     * @param unifiedToolId The unique identifier for the tool in LearnPlatform
     */
    public async createExternalToolAccounts (accountId: string, clientId: string, name: string, privacyLevel: string, consumerKey: string, sharedSecret: string, description?: string, url?: string, domain?: string, iconUrl?: string, text?: string, customFieldsFieldName?: string, isRceFavorite?: boolean, accountNavigationUrl?: string, accountNavigationEnabled?: boolean, accountNavigationText?: string, accountNavigationSelectionWidth?: string, accountNavigationSelectionHeight?: string, accountNavigationDisplayType?: string, userNavigationUrl?: string, userNavigationEnabled?: boolean, userNavigationText?: string, userNavigationVisibility?: string, courseHomeSubNavigationUrl?: string, courseHomeSubNavigationEnabled?: boolean, courseHomeSubNavigationText?: string, courseHomeSubNavigationIconUrl?: string, courseNavigationEnabled?: boolean, courseNavigationText?: string, courseNavigationVisibility?: string, courseNavigationWindowTarget?: string, courseNavigationDefault?: string, courseNavigationDisplayType?: string, editorButtonUrl?: string, editorButtonEnabled?: boolean, editorButtonIconUrl?: string, editorButtonSelectionWidth?: string, editorButtonSelectionHeight?: string, editorButtonMessageType?: string, homeworkSubmissionUrl?: string, homeworkSubmissionEnabled?: boolean, homeworkSubmissionText?: string, homeworkSubmissionMessageType?: string, linkSelectionUrl?: string, linkSelectionEnabled?: boolean, linkSelectionText?: string, linkSelectionMessageType?: string, migrationSelectionUrl?: string, migrationSelectionEnabled?: boolean, migrationSelectionMessageType?: string, toolConfigurationUrl?: string, toolConfigurationEnabled?: boolean, toolConfigurationMessageType?: string, toolConfigurationPreferSisEmail?: boolean, resourceSelectionUrl?: string, resourceSelectionEnabled?: boolean, resourceSelectionIconUrl?: string, resourceSelectionSelectionWidth?: string, resourceSelectionSelectionHeight?: string, configType?: string, configXml?: string, configUrl?: string, notSelectable?: boolean, oauthCompliant?: boolean, unifiedToolId?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/external_tools'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createExternalToolAccounts.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling createExternalToolAccounts.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createExternalToolAccounts.');
        }

        // verify required parameter 'privacyLevel' is not null or undefined
        if (privacyLevel === null || privacyLevel === undefined) {
            throw new Error('Required parameter privacyLevel was null or undefined when calling createExternalToolAccounts.');
        }

        // verify required parameter 'consumerKey' is not null or undefined
        if (consumerKey === null || consumerKey === undefined) {
            throw new Error('Required parameter consumerKey was null or undefined when calling createExternalToolAccounts.');
        }

        // verify required parameter 'sharedSecret' is not null or undefined
        if (sharedSecret === null || sharedSecret === undefined) {
            throw new Error('Required parameter sharedSecret was null or undefined when calling createExternalToolAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (clientId !== undefined) {
            localVarFormParams['client_id'] = ObjectSerializer.serialize(clientId, "string");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (privacyLevel !== undefined) {
            localVarFormParams['privacy_level'] = ObjectSerializer.serialize(privacyLevel, "string");
        }

        if (consumerKey !== undefined) {
            localVarFormParams['consumer_key'] = ObjectSerializer.serialize(consumerKey, "string");
        }

        if (sharedSecret !== undefined) {
            localVarFormParams['shared_secret'] = ObjectSerializer.serialize(sharedSecret, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (url !== undefined) {
            localVarFormParams['url'] = ObjectSerializer.serialize(url, "string");
        }

        if (domain !== undefined) {
            localVarFormParams['domain'] = ObjectSerializer.serialize(domain, "string");
        }

        if (iconUrl !== undefined) {
            localVarFormParams['icon_url'] = ObjectSerializer.serialize(iconUrl, "string");
        }

        if (text !== undefined) {
            localVarFormParams['text'] = ObjectSerializer.serialize(text, "string");
        }

        if (customFieldsFieldName !== undefined) {
            localVarFormParams['custom_fields[field_name]'] = ObjectSerializer.serialize(customFieldsFieldName, "string");
        }

        if (isRceFavorite !== undefined) {
            localVarFormParams['is_rce_favorite'] = ObjectSerializer.serialize(isRceFavorite, "boolean");
        }

        if (accountNavigationUrl !== undefined) {
            localVarFormParams['account_navigation[url]'] = ObjectSerializer.serialize(accountNavigationUrl, "string");
        }

        if (accountNavigationEnabled !== undefined) {
            localVarFormParams['account_navigation[enabled]'] = ObjectSerializer.serialize(accountNavigationEnabled, "boolean");
        }

        if (accountNavigationText !== undefined) {
            localVarFormParams['account_navigation[text]'] = ObjectSerializer.serialize(accountNavigationText, "string");
        }

        if (accountNavigationSelectionWidth !== undefined) {
            localVarFormParams['account_navigation[selection_width]'] = ObjectSerializer.serialize(accountNavigationSelectionWidth, "string");
        }

        if (accountNavigationSelectionHeight !== undefined) {
            localVarFormParams['account_navigation[selection_height]'] = ObjectSerializer.serialize(accountNavigationSelectionHeight, "string");
        }

        if (accountNavigationDisplayType !== undefined) {
            localVarFormParams['account_navigation[display_type]'] = ObjectSerializer.serialize(accountNavigationDisplayType, "string");
        }

        if (userNavigationUrl !== undefined) {
            localVarFormParams['user_navigation[url]'] = ObjectSerializer.serialize(userNavigationUrl, "string");
        }

        if (userNavigationEnabled !== undefined) {
            localVarFormParams['user_navigation[enabled]'] = ObjectSerializer.serialize(userNavigationEnabled, "boolean");
        }

        if (userNavigationText !== undefined) {
            localVarFormParams['user_navigation[text]'] = ObjectSerializer.serialize(userNavigationText, "string");
        }

        if (userNavigationVisibility !== undefined) {
            localVarFormParams['user_navigation[visibility]'] = ObjectSerializer.serialize(userNavigationVisibility, "string");
        }

        if (courseHomeSubNavigationUrl !== undefined) {
            localVarFormParams['course_home_sub_navigation[url]'] = ObjectSerializer.serialize(courseHomeSubNavigationUrl, "string");
        }

        if (courseHomeSubNavigationEnabled !== undefined) {
            localVarFormParams['course_home_sub_navigation[enabled]'] = ObjectSerializer.serialize(courseHomeSubNavigationEnabled, "boolean");
        }

        if (courseHomeSubNavigationText !== undefined) {
            localVarFormParams['course_home_sub_navigation[text]'] = ObjectSerializer.serialize(courseHomeSubNavigationText, "string");
        }

        if (courseHomeSubNavigationIconUrl !== undefined) {
            localVarFormParams['course_home_sub_navigation[icon_url]'] = ObjectSerializer.serialize(courseHomeSubNavigationIconUrl, "string");
        }

        if (courseNavigationEnabled !== undefined) {
            localVarFormParams['course_navigation[enabled]'] = ObjectSerializer.serialize(courseNavigationEnabled, "boolean");
        }

        if (courseNavigationText !== undefined) {
            localVarFormParams['course_navigation[text]'] = ObjectSerializer.serialize(courseNavigationText, "string");
        }

        if (courseNavigationVisibility !== undefined) {
            localVarFormParams['course_navigation[visibility]'] = ObjectSerializer.serialize(courseNavigationVisibility, "string");
        }

        if (courseNavigationWindowTarget !== undefined) {
            localVarFormParams['course_navigation[windowTarget]'] = ObjectSerializer.serialize(courseNavigationWindowTarget, "string");
        }

        if (courseNavigationDefault !== undefined) {
            localVarFormParams['course_navigation[default]'] = ObjectSerializer.serialize(courseNavigationDefault, "string");
        }

        if (courseNavigationDisplayType !== undefined) {
            localVarFormParams['course_navigation[display_type]'] = ObjectSerializer.serialize(courseNavigationDisplayType, "string");
        }

        if (editorButtonUrl !== undefined) {
            localVarFormParams['editor_button[url]'] = ObjectSerializer.serialize(editorButtonUrl, "string");
        }

        if (editorButtonEnabled !== undefined) {
            localVarFormParams['editor_button[enabled]'] = ObjectSerializer.serialize(editorButtonEnabled, "boolean");
        }

        if (editorButtonIconUrl !== undefined) {
            localVarFormParams['editor_button[icon_url]'] = ObjectSerializer.serialize(editorButtonIconUrl, "string");
        }

        if (editorButtonSelectionWidth !== undefined) {
            localVarFormParams['editor_button[selection_width]'] = ObjectSerializer.serialize(editorButtonSelectionWidth, "string");
        }

        if (editorButtonSelectionHeight !== undefined) {
            localVarFormParams['editor_button[selection_height]'] = ObjectSerializer.serialize(editorButtonSelectionHeight, "string");
        }

        if (editorButtonMessageType !== undefined) {
            localVarFormParams['editor_button[message_type]'] = ObjectSerializer.serialize(editorButtonMessageType, "string");
        }

        if (homeworkSubmissionUrl !== undefined) {
            localVarFormParams['homework_submission[url]'] = ObjectSerializer.serialize(homeworkSubmissionUrl, "string");
        }

        if (homeworkSubmissionEnabled !== undefined) {
            localVarFormParams['homework_submission[enabled]'] = ObjectSerializer.serialize(homeworkSubmissionEnabled, "boolean");
        }

        if (homeworkSubmissionText !== undefined) {
            localVarFormParams['homework_submission[text]'] = ObjectSerializer.serialize(homeworkSubmissionText, "string");
        }

        if (homeworkSubmissionMessageType !== undefined) {
            localVarFormParams['homework_submission[message_type]'] = ObjectSerializer.serialize(homeworkSubmissionMessageType, "string");
        }

        if (linkSelectionUrl !== undefined) {
            localVarFormParams['link_selection[url]'] = ObjectSerializer.serialize(linkSelectionUrl, "string");
        }

        if (linkSelectionEnabled !== undefined) {
            localVarFormParams['link_selection[enabled]'] = ObjectSerializer.serialize(linkSelectionEnabled, "boolean");
        }

        if (linkSelectionText !== undefined) {
            localVarFormParams['link_selection[text]'] = ObjectSerializer.serialize(linkSelectionText, "string");
        }

        if (linkSelectionMessageType !== undefined) {
            localVarFormParams['link_selection[message_type]'] = ObjectSerializer.serialize(linkSelectionMessageType, "string");
        }

        if (migrationSelectionUrl !== undefined) {
            localVarFormParams['migration_selection[url]'] = ObjectSerializer.serialize(migrationSelectionUrl, "string");
        }

        if (migrationSelectionEnabled !== undefined) {
            localVarFormParams['migration_selection[enabled]'] = ObjectSerializer.serialize(migrationSelectionEnabled, "boolean");
        }

        if (migrationSelectionMessageType !== undefined) {
            localVarFormParams['migration_selection[message_type]'] = ObjectSerializer.serialize(migrationSelectionMessageType, "string");
        }

        if (toolConfigurationUrl !== undefined) {
            localVarFormParams['tool_configuration[url]'] = ObjectSerializer.serialize(toolConfigurationUrl, "string");
        }

        if (toolConfigurationEnabled !== undefined) {
            localVarFormParams['tool_configuration[enabled]'] = ObjectSerializer.serialize(toolConfigurationEnabled, "boolean");
        }

        if (toolConfigurationMessageType !== undefined) {
            localVarFormParams['tool_configuration[message_type]'] = ObjectSerializer.serialize(toolConfigurationMessageType, "string");
        }

        if (toolConfigurationPreferSisEmail !== undefined) {
            localVarFormParams['tool_configuration[prefer_sis_email]'] = ObjectSerializer.serialize(toolConfigurationPreferSisEmail, "boolean");
        }

        if (resourceSelectionUrl !== undefined) {
            localVarFormParams['resource_selection[url]'] = ObjectSerializer.serialize(resourceSelectionUrl, "string");
        }

        if (resourceSelectionEnabled !== undefined) {
            localVarFormParams['resource_selection[enabled]'] = ObjectSerializer.serialize(resourceSelectionEnabled, "boolean");
        }

        if (resourceSelectionIconUrl !== undefined) {
            localVarFormParams['resource_selection[icon_url]'] = ObjectSerializer.serialize(resourceSelectionIconUrl, "string");
        }

        if (resourceSelectionSelectionWidth !== undefined) {
            localVarFormParams['resource_selection[selection_width]'] = ObjectSerializer.serialize(resourceSelectionSelectionWidth, "string");
        }

        if (resourceSelectionSelectionHeight !== undefined) {
            localVarFormParams['resource_selection[selection_height]'] = ObjectSerializer.serialize(resourceSelectionSelectionHeight, "string");
        }

        if (configType !== undefined) {
            localVarFormParams['config_type'] = ObjectSerializer.serialize(configType, "string");
        }

        if (configXml !== undefined) {
            localVarFormParams['config_xml'] = ObjectSerializer.serialize(configXml, "string");
        }

        if (configUrl !== undefined) {
            localVarFormParams['config_url'] = ObjectSerializer.serialize(configUrl, "string");
        }

        if (notSelectable !== undefined) {
            localVarFormParams['not_selectable'] = ObjectSerializer.serialize(notSelectable, "boolean");
        }

        if (oauthCompliant !== undefined) {
            localVarFormParams['oauth_compliant'] = ObjectSerializer.serialize(oauthCompliant, "boolean");
        }

        if (unifiedToolId !== undefined) {
            localVarFormParams['unified_tool_id'] = ObjectSerializer.serialize(unifiedToolId, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create an external tool in the specified course/account. The created tool will be returned, see the \"show\" endpoint for an example. If a client ID is supplied canvas will attempt to create a context external tool using the LTI 1.3 standard.
     * @summary Create an external tool
     * @param courseId ID
     * @param clientId The client id is attached to the developer key. If supplied all other parameters are unnecessary and will be ignored
     * @param name The name of the tool
     * @param privacyLevel How much user information to send to the external tool.
     * @param consumerKey The consumer key for the external tool
     * @param sharedSecret The shared secret with the external tool
     * @param description A description of the tool
     * @param url The url to match links against. Either \\\&quot;url\\\&quot; or \\\&quot;domain\\\&quot; should be set, not both.
     * @param domain The domain to match links against. Either \\\&quot;url\\\&quot; or \\\&quot;domain\\\&quot; should be set, not both.
     * @param iconUrl The url of the icon to show for this tool
     * @param text The default text to show for this tool
     * @param customFieldsFieldName Custom fields that will be sent to the tool consumer; can be used multiple times
     * @param isRceFavorite (Deprecated in favor of {api:ExternalToolsController#add_rce_favorite Add tool to RCE Favorites} and {api:ExternalToolsController#remove_rce_favorite Remove tool from RCE Favorites}) Whether this tool should appear in a preferred location in the RCE. This only applies to tools in root account contexts that have an editor button placement.
     * @param accountNavigationUrl The url of the external tool for account navigation
     * @param accountNavigationEnabled Set this to enable this feature
     * @param accountNavigationText The text that will show on the left-tab in the account navigation
     * @param accountNavigationSelectionWidth The width of the dialog the tool is launched in
     * @param accountNavigationSelectionHeight The height of the dialog the tool is launched in
     * @param accountNavigationDisplayType The layout type to use when launching the tool. Must be \\\&quot;full_width\\\&quot;, \\\&quot;full_width_in_context\\\&quot;, \\\&quot;full_width_with_nav\\\&quot;, \\\&quot;in_nav_context\\\&quot;, \\\&quot;borderless\\\&quot;, or \\\&quot;default\\\&quot;
     * @param userNavigationUrl The url of the external tool for user navigation
     * @param userNavigationEnabled Set this to enable this feature
     * @param userNavigationText The text that will show on the left-tab in the user navigation
     * @param userNavigationVisibility Who will see the navigation tab. \\\&quot;admins\\\&quot; for admins, \\\&quot;public\\\&quot; or \\\&quot;members\\\&quot; for everyone. Setting this to &#x60;null&#x60; will remove this configuration and use the default behavior, which is \\\&quot;public\\\&quot;.
     * @param courseHomeSubNavigationUrl The url of the external tool for right-side course home navigation menu
     * @param courseHomeSubNavigationEnabled Set this to enable this feature
     * @param courseHomeSubNavigationText The text that will show on the right-side course home navigation menu
     * @param courseHomeSubNavigationIconUrl The url of the icon to show in the right-side course home navigation menu
     * @param courseNavigationEnabled Set this to enable this feature
     * @param courseNavigationText The text that will show on the left-tab in the course navigation
     * @param courseNavigationVisibility Who will see the navigation tab. \\\&quot;admins\\\&quot; for course admins, \\\&quot;members\\\&quot; for students, \\\&quot;public\\\&quot; for everyone. Setting this to &#x60;null&#x60; will remove this configuration and use the default behavior, which is \\\&quot;public\\\&quot;.
     * @param courseNavigationWindowTarget Determines how the navigation tab will be opened. \\\&quot;_blank\\\&quot; Launches the external tool in a new window or tab. \\\&quot;_self\\\&quot; (Default) Launches the external tool in an iframe inside of Canvas.
     * @param courseNavigationDefault If set to \\\&quot;disabled\\\&quot; the tool will not appear in the course navigation until a teacher explicitly enables it.  If set to \\\&quot;enabled\\\&quot; the tool will appear in the course navigation without requiring a teacher to explicitly enable it.  defaults to \\\&quot;enabled\\\&quot;
     * @param courseNavigationDisplayType The layout type to use when launching the tool. Must be \\\&quot;full_width\\\&quot;, \\\&quot;full_width_in_context\\\&quot;, \\\&quot;full_width_with_nav\\\&quot;, \\\&quot;in_nav_context\\\&quot;, \\\&quot;borderless\\\&quot;, or \\\&quot;default\\\&quot;
     * @param editorButtonUrl The url of the external tool
     * @param editorButtonEnabled Set this to enable this feature
     * @param editorButtonIconUrl The url of the icon to show in the WYSIWYG editor
     * @param editorButtonSelectionWidth The width of the dialog the tool is launched in
     * @param editorButtonSelectionHeight The height of the dialog the tool is launched in
     * @param editorButtonMessageType Set this to ContentItemSelectionRequest to tell the tool to use content-item; otherwise, omit
     * @param homeworkSubmissionUrl The url of the external tool
     * @param homeworkSubmissionEnabled Set this to enable this feature
     * @param homeworkSubmissionText The text that will show on the homework submission tab
     * @param homeworkSubmissionMessageType Set this to ContentItemSelectionRequest to tell the tool to use content-item; otherwise, omit
     * @param linkSelectionUrl The url of the external tool
     * @param linkSelectionEnabled Set this to enable this feature
     * @param linkSelectionText The text that will show for the link selection text
     * @param linkSelectionMessageType Set this to ContentItemSelectionRequest to tell the tool to use content-item; otherwise, omit
     * @param migrationSelectionUrl The url of the external tool
     * @param migrationSelectionEnabled Set this to enable this feature
     * @param migrationSelectionMessageType Set this to ContentItemSelectionRequest to tell the tool to use content-item; otherwise, omit
     * @param toolConfigurationUrl The url of the external tool
     * @param toolConfigurationEnabled Set this to enable this feature
     * @param toolConfigurationMessageType Set this to ContentItemSelectionRequest to tell the tool to use content-item; otherwise, omit
     * @param toolConfigurationPreferSisEmail Set this to default the lis_person_contact_email_primary to prefer provisioned sis_email; otherwise, omit
     * @param resourceSelectionUrl The url of the external tool
     * @param resourceSelectionEnabled Set this to enable this feature. If set to false, not_selectable must also be set to true in order to hide this tool from the selection UI in modules and assignments.
     * @param resourceSelectionIconUrl The url of the icon to show in the module external tool list
     * @param resourceSelectionSelectionWidth The width of the dialog the tool is launched in
     * @param resourceSelectionSelectionHeight The height of the dialog the tool is launched in
     * @param configType Configuration can be passed in as CC xml instead of using query parameters. If this value is \\\&quot;by_url\\\&quot; or \\\&quot;by_xml\\\&quot; then an xml configuration will be expected in either the \\\&quot;config_xml\\\&quot; or \\\&quot;config_url\\\&quot; parameter. Note that the name parameter overrides the tool name provided in the xml
     * @param configXml XML tool configuration, as specified in the CC xml specification. This is required if \\\&quot;config_type\\\&quot; is set to \\\&quot;by_xml\\\&quot;
     * @param configUrl URL where the server can retrieve an XML tool configuration, as specified in the CC xml specification. This is required if \\\&quot;config_type\\\&quot; is set to \\\&quot;by_url\\\&quot;
     * @param notSelectable Default: false. If set to true, and if resource_selection is set to false, the tool won\\\&#39;t show up in the external tool selection UI in modules and assignments
     * @param oauthCompliant Default: false, if set to true LTI query params will not be copied to the post body.
     * @param unifiedToolId The unique identifier for the tool in LearnPlatform
     */
    public async createExternalToolCourses (courseId: string, clientId: string, name: string, privacyLevel: string, consumerKey: string, sharedSecret: string, description?: string, url?: string, domain?: string, iconUrl?: string, text?: string, customFieldsFieldName?: string, isRceFavorite?: boolean, accountNavigationUrl?: string, accountNavigationEnabled?: boolean, accountNavigationText?: string, accountNavigationSelectionWidth?: string, accountNavigationSelectionHeight?: string, accountNavigationDisplayType?: string, userNavigationUrl?: string, userNavigationEnabled?: boolean, userNavigationText?: string, userNavigationVisibility?: string, courseHomeSubNavigationUrl?: string, courseHomeSubNavigationEnabled?: boolean, courseHomeSubNavigationText?: string, courseHomeSubNavigationIconUrl?: string, courseNavigationEnabled?: boolean, courseNavigationText?: string, courseNavigationVisibility?: string, courseNavigationWindowTarget?: string, courseNavigationDefault?: string, courseNavigationDisplayType?: string, editorButtonUrl?: string, editorButtonEnabled?: boolean, editorButtonIconUrl?: string, editorButtonSelectionWidth?: string, editorButtonSelectionHeight?: string, editorButtonMessageType?: string, homeworkSubmissionUrl?: string, homeworkSubmissionEnabled?: boolean, homeworkSubmissionText?: string, homeworkSubmissionMessageType?: string, linkSelectionUrl?: string, linkSelectionEnabled?: boolean, linkSelectionText?: string, linkSelectionMessageType?: string, migrationSelectionUrl?: string, migrationSelectionEnabled?: boolean, migrationSelectionMessageType?: string, toolConfigurationUrl?: string, toolConfigurationEnabled?: boolean, toolConfigurationMessageType?: string, toolConfigurationPreferSisEmail?: boolean, resourceSelectionUrl?: string, resourceSelectionEnabled?: boolean, resourceSelectionIconUrl?: string, resourceSelectionSelectionWidth?: string, resourceSelectionSelectionHeight?: string, configType?: string, configXml?: string, configUrl?: string, notSelectable?: boolean, oauthCompliant?: boolean, unifiedToolId?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/external_tools'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createExternalToolCourses.');
        }

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling createExternalToolCourses.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createExternalToolCourses.');
        }

        // verify required parameter 'privacyLevel' is not null or undefined
        if (privacyLevel === null || privacyLevel === undefined) {
            throw new Error('Required parameter privacyLevel was null or undefined when calling createExternalToolCourses.');
        }

        // verify required parameter 'consumerKey' is not null or undefined
        if (consumerKey === null || consumerKey === undefined) {
            throw new Error('Required parameter consumerKey was null or undefined when calling createExternalToolCourses.');
        }

        // verify required parameter 'sharedSecret' is not null or undefined
        if (sharedSecret === null || sharedSecret === undefined) {
            throw new Error('Required parameter sharedSecret was null or undefined when calling createExternalToolCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (clientId !== undefined) {
            localVarFormParams['client_id'] = ObjectSerializer.serialize(clientId, "string");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (privacyLevel !== undefined) {
            localVarFormParams['privacy_level'] = ObjectSerializer.serialize(privacyLevel, "string");
        }

        if (consumerKey !== undefined) {
            localVarFormParams['consumer_key'] = ObjectSerializer.serialize(consumerKey, "string");
        }

        if (sharedSecret !== undefined) {
            localVarFormParams['shared_secret'] = ObjectSerializer.serialize(sharedSecret, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (url !== undefined) {
            localVarFormParams['url'] = ObjectSerializer.serialize(url, "string");
        }

        if (domain !== undefined) {
            localVarFormParams['domain'] = ObjectSerializer.serialize(domain, "string");
        }

        if (iconUrl !== undefined) {
            localVarFormParams['icon_url'] = ObjectSerializer.serialize(iconUrl, "string");
        }

        if (text !== undefined) {
            localVarFormParams['text'] = ObjectSerializer.serialize(text, "string");
        }

        if (customFieldsFieldName !== undefined) {
            localVarFormParams['custom_fields[field_name]'] = ObjectSerializer.serialize(customFieldsFieldName, "string");
        }

        if (isRceFavorite !== undefined) {
            localVarFormParams['is_rce_favorite'] = ObjectSerializer.serialize(isRceFavorite, "boolean");
        }

        if (accountNavigationUrl !== undefined) {
            localVarFormParams['account_navigation[url]'] = ObjectSerializer.serialize(accountNavigationUrl, "string");
        }

        if (accountNavigationEnabled !== undefined) {
            localVarFormParams['account_navigation[enabled]'] = ObjectSerializer.serialize(accountNavigationEnabled, "boolean");
        }

        if (accountNavigationText !== undefined) {
            localVarFormParams['account_navigation[text]'] = ObjectSerializer.serialize(accountNavigationText, "string");
        }

        if (accountNavigationSelectionWidth !== undefined) {
            localVarFormParams['account_navigation[selection_width]'] = ObjectSerializer.serialize(accountNavigationSelectionWidth, "string");
        }

        if (accountNavigationSelectionHeight !== undefined) {
            localVarFormParams['account_navigation[selection_height]'] = ObjectSerializer.serialize(accountNavigationSelectionHeight, "string");
        }

        if (accountNavigationDisplayType !== undefined) {
            localVarFormParams['account_navigation[display_type]'] = ObjectSerializer.serialize(accountNavigationDisplayType, "string");
        }

        if (userNavigationUrl !== undefined) {
            localVarFormParams['user_navigation[url]'] = ObjectSerializer.serialize(userNavigationUrl, "string");
        }

        if (userNavigationEnabled !== undefined) {
            localVarFormParams['user_navigation[enabled]'] = ObjectSerializer.serialize(userNavigationEnabled, "boolean");
        }

        if (userNavigationText !== undefined) {
            localVarFormParams['user_navigation[text]'] = ObjectSerializer.serialize(userNavigationText, "string");
        }

        if (userNavigationVisibility !== undefined) {
            localVarFormParams['user_navigation[visibility]'] = ObjectSerializer.serialize(userNavigationVisibility, "string");
        }

        if (courseHomeSubNavigationUrl !== undefined) {
            localVarFormParams['course_home_sub_navigation[url]'] = ObjectSerializer.serialize(courseHomeSubNavigationUrl, "string");
        }

        if (courseHomeSubNavigationEnabled !== undefined) {
            localVarFormParams['course_home_sub_navigation[enabled]'] = ObjectSerializer.serialize(courseHomeSubNavigationEnabled, "boolean");
        }

        if (courseHomeSubNavigationText !== undefined) {
            localVarFormParams['course_home_sub_navigation[text]'] = ObjectSerializer.serialize(courseHomeSubNavigationText, "string");
        }

        if (courseHomeSubNavigationIconUrl !== undefined) {
            localVarFormParams['course_home_sub_navigation[icon_url]'] = ObjectSerializer.serialize(courseHomeSubNavigationIconUrl, "string");
        }

        if (courseNavigationEnabled !== undefined) {
            localVarFormParams['course_navigation[enabled]'] = ObjectSerializer.serialize(courseNavigationEnabled, "boolean");
        }

        if (courseNavigationText !== undefined) {
            localVarFormParams['course_navigation[text]'] = ObjectSerializer.serialize(courseNavigationText, "string");
        }

        if (courseNavigationVisibility !== undefined) {
            localVarFormParams['course_navigation[visibility]'] = ObjectSerializer.serialize(courseNavigationVisibility, "string");
        }

        if (courseNavigationWindowTarget !== undefined) {
            localVarFormParams['course_navigation[windowTarget]'] = ObjectSerializer.serialize(courseNavigationWindowTarget, "string");
        }

        if (courseNavigationDefault !== undefined) {
            localVarFormParams['course_navigation[default]'] = ObjectSerializer.serialize(courseNavigationDefault, "string");
        }

        if (courseNavigationDisplayType !== undefined) {
            localVarFormParams['course_navigation[display_type]'] = ObjectSerializer.serialize(courseNavigationDisplayType, "string");
        }

        if (editorButtonUrl !== undefined) {
            localVarFormParams['editor_button[url]'] = ObjectSerializer.serialize(editorButtonUrl, "string");
        }

        if (editorButtonEnabled !== undefined) {
            localVarFormParams['editor_button[enabled]'] = ObjectSerializer.serialize(editorButtonEnabled, "boolean");
        }

        if (editorButtonIconUrl !== undefined) {
            localVarFormParams['editor_button[icon_url]'] = ObjectSerializer.serialize(editorButtonIconUrl, "string");
        }

        if (editorButtonSelectionWidth !== undefined) {
            localVarFormParams['editor_button[selection_width]'] = ObjectSerializer.serialize(editorButtonSelectionWidth, "string");
        }

        if (editorButtonSelectionHeight !== undefined) {
            localVarFormParams['editor_button[selection_height]'] = ObjectSerializer.serialize(editorButtonSelectionHeight, "string");
        }

        if (editorButtonMessageType !== undefined) {
            localVarFormParams['editor_button[message_type]'] = ObjectSerializer.serialize(editorButtonMessageType, "string");
        }

        if (homeworkSubmissionUrl !== undefined) {
            localVarFormParams['homework_submission[url]'] = ObjectSerializer.serialize(homeworkSubmissionUrl, "string");
        }

        if (homeworkSubmissionEnabled !== undefined) {
            localVarFormParams['homework_submission[enabled]'] = ObjectSerializer.serialize(homeworkSubmissionEnabled, "boolean");
        }

        if (homeworkSubmissionText !== undefined) {
            localVarFormParams['homework_submission[text]'] = ObjectSerializer.serialize(homeworkSubmissionText, "string");
        }

        if (homeworkSubmissionMessageType !== undefined) {
            localVarFormParams['homework_submission[message_type]'] = ObjectSerializer.serialize(homeworkSubmissionMessageType, "string");
        }

        if (linkSelectionUrl !== undefined) {
            localVarFormParams['link_selection[url]'] = ObjectSerializer.serialize(linkSelectionUrl, "string");
        }

        if (linkSelectionEnabled !== undefined) {
            localVarFormParams['link_selection[enabled]'] = ObjectSerializer.serialize(linkSelectionEnabled, "boolean");
        }

        if (linkSelectionText !== undefined) {
            localVarFormParams['link_selection[text]'] = ObjectSerializer.serialize(linkSelectionText, "string");
        }

        if (linkSelectionMessageType !== undefined) {
            localVarFormParams['link_selection[message_type]'] = ObjectSerializer.serialize(linkSelectionMessageType, "string");
        }

        if (migrationSelectionUrl !== undefined) {
            localVarFormParams['migration_selection[url]'] = ObjectSerializer.serialize(migrationSelectionUrl, "string");
        }

        if (migrationSelectionEnabled !== undefined) {
            localVarFormParams['migration_selection[enabled]'] = ObjectSerializer.serialize(migrationSelectionEnabled, "boolean");
        }

        if (migrationSelectionMessageType !== undefined) {
            localVarFormParams['migration_selection[message_type]'] = ObjectSerializer.serialize(migrationSelectionMessageType, "string");
        }

        if (toolConfigurationUrl !== undefined) {
            localVarFormParams['tool_configuration[url]'] = ObjectSerializer.serialize(toolConfigurationUrl, "string");
        }

        if (toolConfigurationEnabled !== undefined) {
            localVarFormParams['tool_configuration[enabled]'] = ObjectSerializer.serialize(toolConfigurationEnabled, "boolean");
        }

        if (toolConfigurationMessageType !== undefined) {
            localVarFormParams['tool_configuration[message_type]'] = ObjectSerializer.serialize(toolConfigurationMessageType, "string");
        }

        if (toolConfigurationPreferSisEmail !== undefined) {
            localVarFormParams['tool_configuration[prefer_sis_email]'] = ObjectSerializer.serialize(toolConfigurationPreferSisEmail, "boolean");
        }

        if (resourceSelectionUrl !== undefined) {
            localVarFormParams['resource_selection[url]'] = ObjectSerializer.serialize(resourceSelectionUrl, "string");
        }

        if (resourceSelectionEnabled !== undefined) {
            localVarFormParams['resource_selection[enabled]'] = ObjectSerializer.serialize(resourceSelectionEnabled, "boolean");
        }

        if (resourceSelectionIconUrl !== undefined) {
            localVarFormParams['resource_selection[icon_url]'] = ObjectSerializer.serialize(resourceSelectionIconUrl, "string");
        }

        if (resourceSelectionSelectionWidth !== undefined) {
            localVarFormParams['resource_selection[selection_width]'] = ObjectSerializer.serialize(resourceSelectionSelectionWidth, "string");
        }

        if (resourceSelectionSelectionHeight !== undefined) {
            localVarFormParams['resource_selection[selection_height]'] = ObjectSerializer.serialize(resourceSelectionSelectionHeight, "string");
        }

        if (configType !== undefined) {
            localVarFormParams['config_type'] = ObjectSerializer.serialize(configType, "string");
        }

        if (configXml !== undefined) {
            localVarFormParams['config_xml'] = ObjectSerializer.serialize(configXml, "string");
        }

        if (configUrl !== undefined) {
            localVarFormParams['config_url'] = ObjectSerializer.serialize(configUrl, "string");
        }

        if (notSelectable !== undefined) {
            localVarFormParams['not_selectable'] = ObjectSerializer.serialize(notSelectable, "boolean");
        }

        if (oauthCompliant !== undefined) {
            localVarFormParams['oauth_compliant'] = ObjectSerializer.serialize(oauthCompliant, "boolean");
        }

        if (unifiedToolId !== undefined) {
            localVarFormParams['unified_tool_id'] = ObjectSerializer.serialize(unifiedToolId, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Remove the specified external tool
     * @summary Delete an external tool
     * @param accountId ID
     * @param externalToolId ID
     */
    public async deleteExternalToolAccounts (accountId: string, externalToolId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/external_tools/{external_tool_id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'external_tool_id' + '}', encodeURIComponent(String(externalToolId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteExternalToolAccounts.');
        }

        // verify required parameter 'externalToolId' is not null or undefined
        if (externalToolId === null || externalToolId === undefined) {
            throw new Error('Required parameter externalToolId was null or undefined when calling deleteExternalToolAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Remove the specified external tool
     * @summary Delete an external tool
     * @param courseId ID
     * @param externalToolId ID
     */
    public async deleteExternalToolCourses (courseId: string, externalToolId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/external_tools/{external_tool_id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'external_tool_id' + '}', encodeURIComponent(String(externalToolId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling deleteExternalToolCourses.');
        }

        // verify required parameter 'externalToolId' is not null or undefined
        if (externalToolId === null || externalToolId === undefined) {
            throw new Error('Required parameter externalToolId was null or undefined when calling deleteExternalToolCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the specified external tool. Uses same parameters as create
     * @summary Edit an external tool
     * @param accountId ID
     * @param externalToolId ID
     */
    public async editExternalToolAccounts (accountId: string, externalToolId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/external_tools/{external_tool_id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'external_tool_id' + '}', encodeURIComponent(String(externalToolId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling editExternalToolAccounts.');
        }

        // verify required parameter 'externalToolId' is not null or undefined
        if (externalToolId === null || externalToolId === undefined) {
            throw new Error('Required parameter externalToolId was null or undefined when calling editExternalToolAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the specified external tool. Uses same parameters as create
     * @summary Edit an external tool
     * @param courseId ID
     * @param externalToolId ID
     */
    public async editExternalToolCourses (courseId: string, externalToolId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/external_tools/{external_tool_id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'external_tool_id' + '}', encodeURIComponent(String(externalToolId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling editExternalToolCourses.');
        }

        // verify required parameter 'externalToolId' is not null or undefined
        if (externalToolId === null || externalToolId === undefined) {
            throw new Error('Required parameter externalToolId was null or undefined when calling editExternalToolCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns a sessionless launch url for an external tool. Prefers the resource_link_lookup_uuid, but defaults to the other passed   parameters id, url, and launch_type  NOTE: Either the resource_link_lookup_uuid, id, or url must be provided unless launch_type is assessment or module_item.
     * @summary Get a sessionless launch url for an external tool.
     * @param accountId ID
     * @param id The external id of the tool to launch.
     * @param url The LTI launch url for the external tool.
     * @param assignmentId The assignment id for an assignment launch. Required if launch_type is set to \&quot;assessment\&quot;.
     * @param moduleItemId The assignment id for a module item launch. Required if launch_type is set to \&quot;module_item\&quot;.
     * @param launchType The type of launch to perform on the external tool. Placement names (eg. \&quot;course_navigation\&quot;) can also be specified to use the custom launch url for that placement; if done, the tool id must be provided.
     * @param resourceLinkLookupUuid The identifier to lookup a resource link.
     */
    public async getSessionlessLaunchUrlForExternalToolAccounts (accountId: string, id?: string, url?: string, assignmentId?: string, moduleItemId?: string, launchType?: 'assessment' | 'module_item', resourceLinkLookupUuid?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/external_tools/sessionless_launch'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getSessionlessLaunchUrlForExternalToolAccounts.');
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "string");
        }

        if (assignmentId !== undefined) {
            localVarQueryParameters['assignment_id'] = ObjectSerializer.serialize(assignmentId, "string");
        }

        if (moduleItemId !== undefined) {
            localVarQueryParameters['module_item_id'] = ObjectSerializer.serialize(moduleItemId, "string");
        }

        if (launchType !== undefined) {
            localVarQueryParameters['launch_type'] = ObjectSerializer.serialize(launchType, "'assessment' | 'module_item'");
        }

        if (resourceLinkLookupUuid !== undefined) {
            localVarQueryParameters['resource_link_lookup_uuid'] = ObjectSerializer.serialize(resourceLinkLookupUuid, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns a sessionless launch url for an external tool. Prefers the resource_link_lookup_uuid, but defaults to the other passed   parameters id, url, and launch_type  NOTE: Either the resource_link_lookup_uuid, id, or url must be provided unless launch_type is assessment or module_item.
     * @summary Get a sessionless launch url for an external tool.
     * @param courseId ID
     * @param id The external id of the tool to launch.
     * @param url The LTI launch url for the external tool.
     * @param assignmentId The assignment id for an assignment launch. Required if launch_type is set to \&quot;assessment\&quot;.
     * @param moduleItemId The assignment id for a module item launch. Required if launch_type is set to \&quot;module_item\&quot;.
     * @param launchType The type of launch to perform on the external tool. Placement names (eg. \&quot;course_navigation\&quot;) can also be specified to use the custom launch url for that placement; if done, the tool id must be provided.
     * @param resourceLinkLookupUuid The identifier to lookup a resource link.
     */
    public async getSessionlessLaunchUrlForExternalToolCourses (courseId: string, id?: string, url?: string, assignmentId?: string, moduleItemId?: string, launchType?: 'assessment' | 'module_item', resourceLinkLookupUuid?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/external_tools/sessionless_launch'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getSessionlessLaunchUrlForExternalToolCourses.');
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "string");
        }

        if (assignmentId !== undefined) {
            localVarQueryParameters['assignment_id'] = ObjectSerializer.serialize(assignmentId, "string");
        }

        if (moduleItemId !== undefined) {
            localVarQueryParameters['module_item_id'] = ObjectSerializer.serialize(moduleItemId, "string");
        }

        if (launchType !== undefined) {
            localVarQueryParameters['launch_type'] = ObjectSerializer.serialize(launchType, "'assessment' | 'module_item'");
        }

        if (resourceLinkLookupUuid !== undefined) {
            localVarQueryParameters['resource_link_lookup_uuid'] = ObjectSerializer.serialize(resourceLinkLookupUuid, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the specified external tool.
     * @summary Get a single external tool
     * @param accountId ID
     * @param externalToolId ID
     */
    public async getSingleExternalToolAccounts (accountId: string, externalToolId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/external_tools/{external_tool_id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'external_tool_id' + '}', encodeURIComponent(String(externalToolId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getSingleExternalToolAccounts.');
        }

        // verify required parameter 'externalToolId' is not null or undefined
        if (externalToolId === null || externalToolId === undefined) {
            throw new Error('Required parameter externalToolId was null or undefined when calling getSingleExternalToolAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the specified external tool.
     * @summary Get a single external tool
     * @param courseId ID
     * @param externalToolId ID
     */
    public async getSingleExternalToolCourses (courseId: string, externalToolId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/external_tools/{external_tool_id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'external_tool_id' + '}', encodeURIComponent(String(externalToolId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getSingleExternalToolCourses.');
        }

        // verify required parameter 'externalToolId' is not null or undefined
        if (externalToolId === null || externalToolId === undefined) {
            throw new Error('Required parameter externalToolId was null or undefined when calling getSingleExternalToolCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a list of external tools with the course_navigation placement that have not been hidden in course settings and whose visibility settings apply to the requesting user. These tools are the same that appear in the course navigation.  The response format is the same as for List external tools, but with additional context_id and context_name fields on each element in the array.
     * @summary Get visible course navigation tools
     * @param contextCodes List of context_codes to retrieve visible course nav tools for (for example, +course_123+). Only courses are presently supported.
     */
    public async getVisibleCourseNavigationTools (contextCodes: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/external_tools/visible_course_nav_tools';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contextCodes' is not null or undefined
        if (contextCodes === null || contextCodes === undefined) {
            throw new Error('Required parameter contextCodes was null or undefined when calling getVisibleCourseNavigationTools.');
        }

        if (contextCodes !== undefined) {
            localVarQueryParameters['context_codes'] = ObjectSerializer.serialize(contextCodes, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a list of external tools with the course_navigation placement that have not been hidden in course settings and whose visibility settings apply to the requesting user. These tools are the same that appear in the course navigation.  The response format is the same as Get visible course navigation tools.
     * @summary Get visible course navigation tools for a single course
     * @param courseId ID
     */
    public async getVisibleCourseNavigationToolsForSingleCourse (courseId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/external_tools/visible_course_nav_tools'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getVisibleCourseNavigationToolsForSingleCourse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the paginated list of external tools for the current context. See the get request docs for a single tool for a list of properties on an external tool.
     * @summary List external tools
     * @param accountId ID
     * @param searchTerm The partial name of the tools to match and return.
     * @param selectable If true, then only tools that are meant to be selectable are returned.
     * @param includeParents If true, then include tools installed in all accounts above the current context
     * @param placement The placement type to filter by.
     */
    public async listExternalToolsAccounts (accountId: string, searchTerm?: string, selectable?: boolean, includeParents?: boolean, placement?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/external_tools'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listExternalToolsAccounts.');
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['search_term'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (selectable !== undefined) {
            localVarQueryParameters['selectable'] = ObjectSerializer.serialize(selectable, "boolean");
        }

        if (includeParents !== undefined) {
            localVarQueryParameters['include_parents'] = ObjectSerializer.serialize(includeParents, "boolean");
        }

        if (placement !== undefined) {
            localVarQueryParameters['placement'] = ObjectSerializer.serialize(placement, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the paginated list of external tools for the current context. See the get request docs for a single tool for a list of properties on an external tool.
     * @summary List external tools
     * @param courseId ID
     * @param searchTerm The partial name of the tools to match and return.
     * @param selectable If true, then only tools that are meant to be selectable are returned.
     * @param includeParents If true, then include tools installed in all accounts above the current context
     * @param placement The placement type to filter by.
     */
    public async listExternalToolsCourses (courseId: string, searchTerm?: string, selectable?: boolean, includeParents?: boolean, placement?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/external_tools'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listExternalToolsCourses.');
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['search_term'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (selectable !== undefined) {
            localVarQueryParameters['selectable'] = ObjectSerializer.serialize(selectable, "boolean");
        }

        if (includeParents !== undefined) {
            localVarQueryParameters['include_parents'] = ObjectSerializer.serialize(includeParents, "boolean");
        }

        if (placement !== undefined) {
            localVarQueryParameters['placement'] = ObjectSerializer.serialize(placement, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the paginated list of external tools for the current context. See the get request docs for a single tool for a list of properties on an external tool.
     * @summary List external tools
     * @param groupId ID
     * @param searchTerm The partial name of the tools to match and return.
     * @param selectable If true, then only tools that are meant to be selectable are returned.
     * @param includeParents If true, then include tools installed in all accounts above the current context
     * @param placement The placement type to filter by.
     */
    public async listExternalToolsGroups (groupId: string, searchTerm?: string, selectable?: boolean, includeParents?: boolean, placement?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/external_tools'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling listExternalToolsGroups.');
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['search_term'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (selectable !== undefined) {
            localVarQueryParameters['selectable'] = ObjectSerializer.serialize(selectable, "boolean");
        }

        if (includeParents !== undefined) {
            localVarQueryParameters['include_parents'] = ObjectSerializer.serialize(includeParents, "boolean");
        }

        if (placement !== undefined) {
            localVarQueryParameters['placement'] = ObjectSerializer.serialize(placement, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Remove the specified external tool from a preferred location in the RCE for the given account
     * @summary Remove tool from RCE Favorites
     * @param accountId ID
     * @param id ID
     */
    public async removeToolFromRceFavorites (accountId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/external_tools/rce_favorites/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling removeToolFromRceFavorites.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeToolFromRceFavorites.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Removes the dedicated button in Top Navigation for the specified tool for the given account.
     * @summary Remove tool from Top Navigation Favorites
     * @param accountId ID
     * @param id ID
     */
    public async removeToolFromTopNavigationFavorites (accountId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/external_tools/top_nav_favorites/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling removeToolFromTopNavigationFavorites.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeToolFromTopNavigationFavorites.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
