/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum OutcomeResultsApiApiKeys {
}

export class OutcomeResultsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: OutcomeResultsApiApiKeys, value: string) {
        (this.authentications as any)[OutcomeResultsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Gets the outcome rollups for the users and outcomes in the specified context.
     * @summary Get outcome result rollups
     * @param courseId ID
     * @param aggregate If specified, instead of returning one rollup for each user, all the user rollups will be combined into one rollup for the course that will contain the average (or median, see below) rollup score for each outcome.
     * @param aggregateStat If aggregate rollups requested, then this value determines what statistic is used for the aggregate. Defaults to \&quot;mean\&quot; if this value is not specified.
     * @param userIds If specified, only the users whose ids are given will be included in the results or used in an aggregate result. it is an error to specify an id for a user who is not a student in the context
     * @param outcomeIds If specified, only the outcomes whose ids are given will be included in the results. it is an error to specify an id for an outcome which is not linked to the context.
     * @param include [String, \&quot;courses\&quot;|\&quot;outcomes\&quot;|\&quot;outcomes.alignments\&quot;|\&quot;outcome_groups\&quot;|\&quot;outcome_links\&quot;|\&quot;outcome_paths\&quot;|\&quot;users\&quot;] Specify additional collections to be side loaded with the result.
     * @param exclude Specify additional values to exclude. \&quot;missing_user_rollups\&quot; excludes rollups for users without results.
     * @param sortBy If specified, sorts outcome result rollups. \&quot;student\&quot; sorting will sort by a user\&#39;s sortable name. \&quot;outcome\&quot; sorting will sort by the given outcome\&#39;s rollup score. The latter requires specifying the \&quot;sort_outcome_id\&quot; parameter. By default, the sort order is ascending.
     * @param sortOutcomeId If outcome sorting requested, then this determines which outcome to use for rollup score sorting.
     * @param sortOrder If sorting requested, then this allows changing the default sort order of ascending to descending.
     * @param addDefaults If defaults are requested, then color and mastery level defaults will be added to outcome ratings in the rollup. This will only take effect if the Account Level Mastery Scales FF is DISABLED
     * @param contributingScores If contributing scores are requested, then each individual outcome score will also include all graded artifacts that contributed to the outcome score
     */
    public async getOutcomeResultRollups (courseId: string, aggregate?: 'course', aggregateStat?: 'mean' | 'median', userIds?: Array<number>, outcomeIds?: Array<number>, include?: Array<string>, exclude?: Array<string>, sortBy?: 'student' | 'outcome', sortOutcomeId?: number, sortOrder?: 'asc' | 'desc', addDefaults?: boolean, contributingScores?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/outcome_rollups'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getOutcomeResultRollups.');
        }

        if (aggregate !== undefined) {
            localVarQueryParameters['aggregate'] = ObjectSerializer.serialize(aggregate, "'course'");
        }

        if (aggregateStat !== undefined) {
            localVarQueryParameters['aggregate_stat'] = ObjectSerializer.serialize(aggregateStat, "'mean' | 'median'");
        }

        if (userIds !== undefined) {
            localVarQueryParameters['user_ids'] = ObjectSerializer.serialize(userIds, "Array<number>");
        }

        if (outcomeIds !== undefined) {
            localVarQueryParameters['outcome_ids'] = ObjectSerializer.serialize(outcomeIds, "Array<number>");
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (exclude !== undefined) {
            localVarQueryParameters['exclude'] = ObjectSerializer.serialize(exclude, "Array<string>");
        }

        if (sortBy !== undefined) {
            localVarQueryParameters['sort_by'] = ObjectSerializer.serialize(sortBy, "'student' | 'outcome'");
        }

        if (sortOutcomeId !== undefined) {
            localVarQueryParameters['sort_outcome_id'] = ObjectSerializer.serialize(sortOutcomeId, "number");
        }

        if (sortOrder !== undefined) {
            localVarQueryParameters['sort_order'] = ObjectSerializer.serialize(sortOrder, "'asc' | 'desc'");
        }

        if (addDefaults !== undefined) {
            localVarQueryParameters['add_defaults'] = ObjectSerializer.serialize(addDefaults, "boolean");
        }

        if (contributingScores !== undefined) {
            localVarQueryParameters['contributing_scores'] = ObjectSerializer.serialize(contributingScores, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Gets the outcome results for users and outcomes in the specified context.  used in sLMGB
     * @summary Get outcome results
     * @param courseId ID
     * @param userIds If specified, only the users whose ids are given will be included in the results. SIS ids can be used, prefixed by \&quot;sis_user_id:\&quot;. It is an error to specify an id for a user who is not a student in the context.
     * @param outcomeIds If specified, only the outcomes whose ids are given will be included in the results. it is an error to specify an id for an outcome which is not linked to the context.
     * @param include [String, \&quot;alignments\&quot;|\&quot;outcomes\&quot;|\&quot;outcomes.alignments\&quot;|\&quot;outcome_groups\&quot;|\&quot;outcome_links\&quot;|\&quot;outcome_paths\&quot;|\&quot;users\&quot;] Specify additional collections to be side loaded with the result. \&quot;alignments\&quot; includes only the alignments referenced by the returned results. \&quot;outcomes.alignments\&quot; includes all alignments referenced by outcomes in the context.
     * @param includeHidden If true, results that are hidden from the learning mastery gradebook and student rollup scores will be included
     */
    public async getOutcomeResults (courseId: string, userIds?: Array<number>, outcomeIds?: Array<number>, include?: Array<string>, includeHidden?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/outcome_results'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getOutcomeResults.');
        }

        if (userIds !== undefined) {
            localVarQueryParameters['user_ids'] = ObjectSerializer.serialize(userIds, "Array<number>");
        }

        if (outcomeIds !== undefined) {
            localVarQueryParameters['outcome_ids'] = ObjectSerializer.serialize(outcomeIds, "Array<number>");
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (includeHidden !== undefined) {
            localVarQueryParameters['include_hidden'] = ObjectSerializer.serialize(includeHidden, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Saves the ordering of outcomes in LMGB for a user
     * @summary Set outcome ordering for LMGB
     * @param courseId ID
     */
    public async setOutcomeOrderingForLmgb (courseId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assign_outcome_order'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling setOutcomeOrderingForLmgb.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
