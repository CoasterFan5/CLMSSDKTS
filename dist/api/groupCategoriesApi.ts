/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { GroupCategory } from '../model/groupCategory';
import { GroupCategoryandgroupsoperationresults } from '../model/groupCategoryandgroupsoperationresults';
import { GroupMembership } from '../model/groupMembership';
import { Progress } from '../model/progress';
import { User } from '../model/user';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum GroupCategoriesApiApiKeys {
}

export class GroupCategoriesApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: GroupCategoriesApiApiKeys, value: string) {
        (this.authentications as any)[GroupCategoriesApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Assign all unassigned members as evenly as possible among the existing student groups.
     * @summary Assign unassigned members
     * @param groupCategoryId ID
     * @param sync The assigning is done asynchronously by default. If you would like to override this and have the assigning done synchronously, set this value to true.
     */
    public async assignUnassignedMembers (groupCategoryId: string, sync?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GroupMembership | Progress;  }> {
        const localVarPath = this.basePath + '/v1/group_categories/{group_category_id}/assign_unassigned_members'
            .replace('{' + 'group_category_id' + '}', encodeURIComponent(String(groupCategoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupCategoryId' is not null or undefined
        if (groupCategoryId === null || groupCategoryId === undefined) {
            throw new Error('Required parameter groupCategoryId was null or undefined when calling assignUnassignedMembers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (sync !== undefined) {
            localVarFormParams['sync'] = ObjectSerializer.serialize(sync, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GroupMembership | Progress;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GroupMembership | Progress");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This API is only meant for Groups and GroupCategories where non_collaborative is true.  Perform bulk operations on groups within a group category, or create a new group category along with the groups in one transaction. If creation of the GroupCategory or any Group fails, the entire operation will be rolled back.
     * @summary Bulk manage differentiation tags
     * @param courseId ID
     * @param operations A hash containing arrays of create/update/delete operations: {   \\\&quot;create\\\&quot;: [     { \\\&quot;name\\\&quot;: \\\&quot;New Group A\\\&quot; },     { \\\&quot;name\\\&quot;: \\\&quot;New Group B\\\&quot; }   ],   \\\&quot;update\\\&quot;: [     { \\\&quot;id\\\&quot;: 123, \\\&quot;name\\\&quot;: \\\&quot;Updated Group Name A\\\&quot; },     { \\\&quot;id\\\&quot;: 456, \\\&quot;name\\\&quot;: \\\&quot;Updated Group Name B\\\&quot; }   ],   \\\&quot;delete\\\&quot;: [     { \\\&quot;id\\\&quot;: 789 },     { \\\&quot;id\\\&quot;: 101 }   ] }
     * @param groupCategory Attributes for the GroupCategory. May include:   - id [Optional, Integer]: The ID of an existing GroupCategory.   - name [Optional, String]: A new name for the GroupCategory. If provided with an ID, the category name will be updated.
     */
    public async bulkManageDifferentiationTags (courseId: string, operations: any, groupCategory: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GroupCategory and groups operation results;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/group_categories/bulk_manage_differentiation_tag'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling bulkManageDifferentiationTags.');
        }

        // verify required parameter 'operations' is not null or undefined
        if (operations === null || operations === undefined) {
            throw new Error('Required parameter operations was null or undefined when calling bulkManageDifferentiationTags.');
        }

        // verify required parameter 'groupCategory' is not null or undefined
        if (groupCategory === null || groupCategory === undefined) {
            throw new Error('Required parameter groupCategory was null or undefined when calling bulkManageDifferentiationTags.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (operations !== undefined) {
            localVarFormParams['operations'] = ObjectSerializer.serialize(operations, "any");
        }

        if (groupCategory !== undefined) {
            localVarFormParams['group_category'] = ObjectSerializer.serialize(groupCategory, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GroupCategory and groups operation results;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GroupCategory and groups operation results");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a new group category
     * @summary Create a Group Category
     * @param accountId ID
     * @param name Name of the group category
     * @param nonCollaborative Can only be set by users with the Differentiated Tag Add permission  If set to true, groups in this category will be only be visible to users with the Differentiated Tag Manage permission.
     * @param selfSignup Allow students to sign up for a group themselves (Course Only). valid values are: \\\&quot;enabled\\\&quot;:: allows students to self sign up for any group in course \\\&quot;restricted\\\&quot;:: allows students to self sign up only for groups in the                same section null disallows self sign up
     * @param autoLeader Assigns group leaders automatically when generating and allocating students to groups Valid values are: \\\&quot;first\\\&quot;:: the first student to be allocated to a group is the leader \\\&quot;random\\\&quot;:: a random student from all members is chosen as the leader
     * @param groupLimit Limit the maximum number of users in each group (Course Only). Requires self signup.
     * @param sisGroupCategoryId The unique SIS identifier.
     * @param createGroupCount Create this number of groups (Course Only).
     * @param splitGroupCount (Deprecated) Create this number of groups, and evenly distribute students among them. not allowed with \\\&quot;enable_self_signup\\\&quot;. because the group assignment happens synchronously, it\\\&#39;s recommended that you instead use the assign_unassigned_members endpoint. (Course Only)
     */
    public async createGroupCategoryAccounts (accountId: string, name: string, nonCollaborative?: boolean, selfSignup?: string, autoLeader?: string, groupLimit?: number, sisGroupCategoryId?: string, createGroupCount?: number, splitGroupCount?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GroupCategory;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/group_categories'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createGroupCategoryAccounts.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createGroupCategoryAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (nonCollaborative !== undefined) {
            localVarFormParams['non_collaborative'] = ObjectSerializer.serialize(nonCollaborative, "boolean");
        }

        if (selfSignup !== undefined) {
            localVarFormParams['self_signup'] = ObjectSerializer.serialize(selfSignup, "string");
        }

        if (autoLeader !== undefined) {
            localVarFormParams['auto_leader'] = ObjectSerializer.serialize(autoLeader, "string");
        }

        if (groupLimit !== undefined) {
            localVarFormParams['group_limit'] = ObjectSerializer.serialize(groupLimit, "number");
        }

        if (sisGroupCategoryId !== undefined) {
            localVarFormParams['sis_group_category_id'] = ObjectSerializer.serialize(sisGroupCategoryId, "string");
        }

        if (createGroupCount !== undefined) {
            localVarFormParams['create_group_count'] = ObjectSerializer.serialize(createGroupCount, "number");
        }

        if (splitGroupCount !== undefined) {
            localVarFormParams['split_group_count'] = ObjectSerializer.serialize(splitGroupCount, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GroupCategory;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GroupCategory");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a new group category
     * @summary Create a Group Category
     * @param courseId ID
     * @param name Name of the group category
     * @param nonCollaborative Can only be set by users with the Differentiated Tag Add permission  If set to true, groups in this category will be only be visible to users with the Differentiated Tag Manage permission.
     * @param selfSignup Allow students to sign up for a group themselves (Course Only). valid values are: \\\&quot;enabled\\\&quot;:: allows students to self sign up for any group in course \\\&quot;restricted\\\&quot;:: allows students to self sign up only for groups in the                same section null disallows self sign up
     * @param autoLeader Assigns group leaders automatically when generating and allocating students to groups Valid values are: \\\&quot;first\\\&quot;:: the first student to be allocated to a group is the leader \\\&quot;random\\\&quot;:: a random student from all members is chosen as the leader
     * @param groupLimit Limit the maximum number of users in each group (Course Only). Requires self signup.
     * @param sisGroupCategoryId The unique SIS identifier.
     * @param createGroupCount Create this number of groups (Course Only).
     * @param splitGroupCount (Deprecated) Create this number of groups, and evenly distribute students among them. not allowed with \\\&quot;enable_self_signup\\\&quot;. because the group assignment happens synchronously, it\\\&#39;s recommended that you instead use the assign_unassigned_members endpoint. (Course Only)
     */
    public async createGroupCategoryCourses (courseId: string, name: string, nonCollaborative?: boolean, selfSignup?: string, autoLeader?: string, groupLimit?: number, sisGroupCategoryId?: string, createGroupCount?: number, splitGroupCount?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GroupCategory;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/group_categories'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createGroupCategoryCourses.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createGroupCategoryCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (nonCollaborative !== undefined) {
            localVarFormParams['non_collaborative'] = ObjectSerializer.serialize(nonCollaborative, "boolean");
        }

        if (selfSignup !== undefined) {
            localVarFormParams['self_signup'] = ObjectSerializer.serialize(selfSignup, "string");
        }

        if (autoLeader !== undefined) {
            localVarFormParams['auto_leader'] = ObjectSerializer.serialize(autoLeader, "string");
        }

        if (groupLimit !== undefined) {
            localVarFormParams['group_limit'] = ObjectSerializer.serialize(groupLimit, "number");
        }

        if (sisGroupCategoryId !== undefined) {
            localVarFormParams['sis_group_category_id'] = ObjectSerializer.serialize(sisGroupCategoryId, "string");
        }

        if (createGroupCount !== undefined) {
            localVarFormParams['create_group_count'] = ObjectSerializer.serialize(createGroupCount, "number");
        }

        if (splitGroupCount !== undefined) {
            localVarFormParams['split_group_count'] = ObjectSerializer.serialize(splitGroupCount, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GroupCategory;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GroupCategory");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes a group category and all groups under it. Protected group categories can not be deleted, i.e. \"communities\" and \"student_organized\".
     * @summary Delete a Group Category
     * @param groupCategoryId ID
     */
    public async deleteGroupCategory (groupCategoryId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/group_categories/{group_category_id}'
            .replace('{' + 'group_category_id' + '}', encodeURIComponent(String(groupCategoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupCategoryId' is not null or undefined
        if (groupCategoryId === null || groupCategoryId === undefined) {
            throw new Error('Required parameter groupCategoryId was null or undefined when calling deleteGroupCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns a csv file of users in format ready to import.
     * @summary export groups in and users in category
     * @param groupCategoryId ID
     */
    public async exportGroupsInAndUsersInCategory (groupCategoryId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/group_categories/{group_category_id}/export'
            .replace('{' + 'group_category_id' + '}', encodeURIComponent(String(groupCategoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupCategoryId' is not null or undefined
        if (groupCategoryId === null || groupCategoryId === undefined) {
            throw new Error('Required parameter groupCategoryId was null or undefined when calling exportGroupsInAndUsersInCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the data for a single group category, or a 401 if the caller doesn\'t have the rights to see it.
     * @summary Get a single group category
     * @param groupCategoryId ID
     */
    public async getSingleGroupCategory (groupCategoryId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GroupCategory;  }> {
        const localVarPath = this.basePath + '/v1/group_categories/{group_category_id}'
            .replace('{' + 'group_category_id' + '}', encodeURIComponent(String(groupCategoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupCategoryId' is not null or undefined
        if (groupCategoryId === null || groupCategoryId === undefined) {
            throw new Error('Required parameter groupCategoryId was null or undefined when calling getSingleGroupCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GroupCategory;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GroupCategory");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create Groups in a Group Category through a CSV import  For more information on the format that\'s expected here, please see the \"Group Category CSV\" section in the API docs.
     * @summary Import category groups
     * @param groupCategoryId ID
     * @param attachment There are two ways to post group category import data - either via a multipart/form-data form-field-style attachment, or via a non-multipart raw post request.  \\\&#39;attachment\\\&#39; is required for multipart/form-data style posts. Assumed to be outcome data from a file upload form field named \\\&#39;attachment\\\&#39;.  Examples:   curl -F attachment&#x3D;@&lt;filename&gt; -H \\\&quot;Authorization: Bearer &lt;token&gt;\\\&quot; \\\\       \\\&#39;https://&lt;canvas&gt;/api/v1/group_categories/&lt;category_id&gt;/import\\\&#39;  If you decide to do a raw post, you can skip the \\\&#39;attachment\\\&#39; argument, but you will then be required to provide a suitable Content-Type header. You are encouraged to also provide the \\\&#39;extension\\\&#39; argument.  Examples:   curl -H \\\&#39;Content-Type: text/csv\\\&#39; --data-binary @&lt;filename&gt;.csv \\\\       -H \\\&quot;Authorization: Bearer &lt;token&gt;\\\&quot; \\\\       \\\&#39;https://&lt;canvas&gt;/api/v1/group_categories/&lt;category_id&gt;/import\\\&#39;
     */
    public async importCategoryGroups (groupCategoryId: string, attachment?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Progress;  }> {
        const localVarPath = this.basePath + '/v1/group_categories/{group_category_id}/import'
            .replace('{' + 'group_category_id' + '}', encodeURIComponent(String(groupCategoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupCategoryId' is not null or undefined
        if (groupCategoryId === null || groupCategoryId === undefined) {
            throw new Error('Required parameter groupCategoryId was null or undefined when calling importCategoryGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (attachment !== undefined) {
            localVarFormParams['attachment'] = ObjectSerializer.serialize(attachment, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Progress;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Progress");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns a paginated list of group categories in a context. The list returned depends on the permissions of the current user and the specified collaboration state.
     * @summary List group categories for a context
     * @param accountId ID
     * @param collaborationState Filter group categories by their collaboration state: - \&quot;all\&quot;: Return both collaborative and non-collaborative group categories - \&quot;collaborative\&quot;: Return only collaborative group categories (default) - \&quot;non_collaborative\&quot;: Return only non-collaborative group categories
     */
    public async listGroupCategoriesForContextAccounts (accountId: string, collaborationState?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<GroupCategory>;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/group_categories'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listGroupCategoriesForContextAccounts.');
        }

        if (collaborationState !== undefined) {
            localVarQueryParameters['collaboration_state'] = ObjectSerializer.serialize(collaborationState, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<GroupCategory>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<GroupCategory>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns a paginated list of group categories in a context. The list returned depends on the permissions of the current user and the specified collaboration state.
     * @summary List group categories for a context
     * @param courseId ID
     * @param collaborationState Filter group categories by their collaboration state: - \&quot;all\&quot;: Return both collaborative and non-collaborative group categories - \&quot;collaborative\&quot;: Return only collaborative group categories (default) - \&quot;non_collaborative\&quot;: Return only non-collaborative group categories
     */
    public async listGroupCategoriesForContextCourses (courseId: string, collaborationState?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<GroupCategory>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/group_categories'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listGroupCategoriesForContextCourses.');
        }

        if (collaborationState !== undefined) {
            localVarQueryParameters['collaboration_state'] = ObjectSerializer.serialize(collaborationState, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<GroupCategory>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<GroupCategory>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns a paginated list of users in the group category.
     * @summary List users in group category
     * @param groupCategoryId ID
     * @param searchTerm The partial name or full ID of the users to match and return in the results list. Must be at least 3 characters.
     * @param unassigned Set this value to true if you wish only to search unassigned users in the group category.
     */
    public async listUsersInGroupCategory (groupCategoryId: string, searchTerm?: string, unassigned?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/v1/group_categories/{group_category_id}/users'
            .replace('{' + 'group_category_id' + '}', encodeURIComponent(String(groupCategoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupCategoryId' is not null or undefined
        if (groupCategoryId === null || groupCategoryId === undefined) {
            throw new Error('Required parameter groupCategoryId was null or undefined when calling listUsersInGroupCategory.');
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['search_term'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (unassigned !== undefined) {
            localVarQueryParameters['unassigned'] = ObjectSerializer.serialize(unassigned, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<User>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Modifies an existing group category.
     * @summary Update a Group Category
     * @param groupCategoryId ID
     * @param name Name of the group category
     * @param selfSignup Allow students to sign up for a group themselves (Course Only). Valid values are: \\\&quot;enabled\\\&quot;:: allows students to self sign up for any group in course \\\&quot;restricted\\\&quot;:: allows students to self sign up only for groups in the                same section null disallows self sign up
     * @param autoLeader Assigns group leaders automatically when generating and allocating students to groups Valid values are: \\\&quot;first\\\&quot;:: the first student to be allocated to a group is the leader \\\&quot;random\\\&quot;:: a random student from all members is chosen as the leader
     * @param groupLimit Limit the maximum number of users in each group (Course Only). Requires self signup.
     * @param sisGroupCategoryId The unique SIS identifier.
     * @param createGroupCount Create this number of groups (Course Only).
     * @param splitGroupCount (Deprecated) Create this number of groups, and evenly distribute students among them. not allowed with \\\&quot;enable_self_signup\\\&quot;. because the group assignment happens synchronously, it\\\&#39;s recommended that you instead use the assign_unassigned_members endpoint. (Course Only)
     */
    public async updateGroupCategory (groupCategoryId: string, name?: string, selfSignup?: string, autoLeader?: string, groupLimit?: number, sisGroupCategoryId?: string, createGroupCount?: number, splitGroupCount?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GroupCategory;  }> {
        const localVarPath = this.basePath + '/v1/group_categories/{group_category_id}'
            .replace('{' + 'group_category_id' + '}', encodeURIComponent(String(groupCategoryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupCategoryId' is not null or undefined
        if (groupCategoryId === null || groupCategoryId === undefined) {
            throw new Error('Required parameter groupCategoryId was null or undefined when calling updateGroupCategory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (selfSignup !== undefined) {
            localVarFormParams['self_signup'] = ObjectSerializer.serialize(selfSignup, "string");
        }

        if (autoLeader !== undefined) {
            localVarFormParams['auto_leader'] = ObjectSerializer.serialize(autoLeader, "string");
        }

        if (groupLimit !== undefined) {
            localVarFormParams['group_limit'] = ObjectSerializer.serialize(groupLimit, "number");
        }

        if (sisGroupCategoryId !== undefined) {
            localVarFormParams['sis_group_category_id'] = ObjectSerializer.serialize(sisGroupCategoryId, "string");
        }

        if (createGroupCount !== undefined) {
            localVarFormParams['create_group_count'] = ObjectSerializer.serialize(createGroupCount, "number");
        }

        if (splitGroupCount !== undefined) {
            localVarFormParams['split_group_count'] = ObjectSerializer.serialize(splitGroupCount, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GroupCategory;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GroupCategory");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
