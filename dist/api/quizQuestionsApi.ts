/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { QuizQuestion } from '../model/quizQuestion';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum QuizQuestionsApiApiKeys {
}

export class QuizQuestionsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: QuizQuestionsApiApiKeys, value: string) {
        (this.authentications as any)[QuizQuestionsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create a new quiz question for this quiz
     * @summary Create a single quiz question
     * @param courseId ID
     * @param quizId ID
     * @param questionQuestionName The name of the question.
     * @param questionQuestionText The text of the question.
     * @param questionQuizGroupId The id of the quiz group to assign the question to.
     * @param questionQuestionType The type of question. Multiple optional fields depend upon the type of question to be used.
     * @param questionPosition The order in which the question will be displayed in the quiz in relation to other questions.
     * @param questionPointsPossible The maximum amount of points received for answering this question correctly.
     * @param questionCorrectComments The comment to display if the student answers the question correctly.
     * @param questionIncorrectComments The comment to display if the student answers incorrectly.
     * @param questionNeutralComments The comment to display regardless of how the student answered.
     * @param questionTextAfterAnswers no description
     * @param questionAnswers no description
     */
    public async createSingleQuizQuestion (courseId: string, quizId: string, questionQuestionName?: string, questionQuestionText?: string, questionQuizGroupId?: number, questionQuestionType?: string, questionPosition?: number, questionPointsPossible?: number, questionCorrectComments?: string, questionIncorrectComments?: string, questionNeutralComments?: string, questionTextAfterAnswers?: string, questionAnswers?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: QuizQuestion;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/quizzes/{quiz_id}/questions'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'quiz_id' + '}', encodeURIComponent(String(quizId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createSingleQuizQuestion.');
        }

        // verify required parameter 'quizId' is not null or undefined
        if (quizId === null || quizId === undefined) {
            throw new Error('Required parameter quizId was null or undefined when calling createSingleQuizQuestion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (questionQuestionName !== undefined) {
            localVarFormParams['question[question_name]'] = ObjectSerializer.serialize(questionQuestionName, "string");
        }

        if (questionQuestionText !== undefined) {
            localVarFormParams['question[question_text]'] = ObjectSerializer.serialize(questionQuestionText, "string");
        }

        if (questionQuizGroupId !== undefined) {
            localVarFormParams['question[quiz_group_id]'] = ObjectSerializer.serialize(questionQuizGroupId, "number");
        }

        if (questionQuestionType !== undefined) {
            localVarFormParams['question[question_type]'] = ObjectSerializer.serialize(questionQuestionType, "string");
        }

        if (questionPosition !== undefined) {
            localVarFormParams['question[position]'] = ObjectSerializer.serialize(questionPosition, "number");
        }

        if (questionPointsPossible !== undefined) {
            localVarFormParams['question[points_possible]'] = ObjectSerializer.serialize(questionPointsPossible, "number");
        }

        if (questionCorrectComments !== undefined) {
            localVarFormParams['question[correct_comments]'] = ObjectSerializer.serialize(questionCorrectComments, "string");
        }

        if (questionIncorrectComments !== undefined) {
            localVarFormParams['question[incorrect_comments]'] = ObjectSerializer.serialize(questionIncorrectComments, "string");
        }

        if (questionNeutralComments !== undefined) {
            localVarFormParams['question[neutral_comments]'] = ObjectSerializer.serialize(questionNeutralComments, "string");
        }

        if (questionTextAfterAnswers !== undefined) {
            localVarFormParams['question[text_after_answers]'] = ObjectSerializer.serialize(questionTextAfterAnswers, "string");
        }

        if (questionAnswers !== undefined) {
            localVarFormParams['question[answers]'] = ObjectSerializer.serialize(questionAnswers, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: QuizQuestion;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "QuizQuestion");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <b>204 No Content</b> response code is returned if the deletion was successful.
     * @summary Delete a quiz question
     * @param courseId ID
     * @param quizId The associated quiz\&#39;s unique identifier
     * @param id The quiz question\&#39;s unique identifier
     */
    public async deleteQuizQuestion (courseId: string, quizId: number, id: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/quizzes/{quiz_id}/questions/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'quiz_id' + '}', encodeURIComponent(String(quizId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling deleteQuizQuestion.');
        }

        // verify required parameter 'quizId' is not null or undefined
        if (quizId === null || quizId === undefined) {
            throw new Error('Required parameter quizId was null or undefined when calling deleteQuizQuestion.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteQuizQuestion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the quiz question with the given id
     * @summary Get a single quiz question
     * @param courseId ID
     * @param quizId ID
     * @param id The quiz question unique identifier.
     */
    public async getSingleQuizQuestion (courseId: string, quizId: string, id: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: QuizQuestion;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/quizzes/{quiz_id}/questions/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'quiz_id' + '}', encodeURIComponent(String(quizId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getSingleQuizQuestion.');
        }

        // verify required parameter 'quizId' is not null or undefined
        if (quizId === null || quizId === undefined) {
            throw new Error('Required parameter quizId was null or undefined when calling getSingleQuizQuestion.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSingleQuizQuestion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: QuizQuestion;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "QuizQuestion");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the paginated list of QuizQuestions in this quiz.
     * @summary List questions in a quiz or a submission
     * @param courseId ID
     * @param quizId ID
     * @param quizSubmissionId If specified, the endpoint will return the questions that were presented for that submission. This is useful if the quiz has been modified after the submission was created and the latest quiz version\&#39;s set of questions does not match the submission\&#39;s. NOTE: you must specify quiz_submission_attempt as well if you specify this parameter.
     * @param quizSubmissionAttempt The attempt of the submission you want the questions for.
     */
    public async listQuestionsInQuizOrSubmission (courseId: string, quizId: string, quizSubmissionId?: number, quizSubmissionAttempt?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<QuizQuestion>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/quizzes/{quiz_id}/questions'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'quiz_id' + '}', encodeURIComponent(String(quizId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listQuestionsInQuizOrSubmission.');
        }

        // verify required parameter 'quizId' is not null or undefined
        if (quizId === null || quizId === undefined) {
            throw new Error('Required parameter quizId was null or undefined when calling listQuestionsInQuizOrSubmission.');
        }

        if (quizSubmissionId !== undefined) {
            localVarQueryParameters['quiz_submission_id'] = ObjectSerializer.serialize(quizSubmissionId, "number");
        }

        if (quizSubmissionAttempt !== undefined) {
            localVarQueryParameters['quiz_submission_attempt'] = ObjectSerializer.serialize(quizSubmissionAttempt, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<QuizQuestion>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<QuizQuestion>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates an existing quiz question for this quiz
     * @summary Update an existing quiz question
     * @param courseId ID
     * @param quizId The associated quiz\&#39;s unique identifier.
     * @param id The quiz question\&#39;s unique identifier.
     * @param questionQuestionName The name of the question.
     * @param questionQuestionText The text of the question.
     * @param questionQuizGroupId The id of the quiz group to assign the question to.
     * @param questionQuestionType The type of question. Multiple optional fields depend upon the type of question to be used.
     * @param questionPosition The order in which the question will be displayed in the quiz in relation to other questions.
     * @param questionPointsPossible The maximum amount of points received for answering this question correctly.
     * @param questionCorrectComments The comment to display if the student answers the question correctly.
     * @param questionIncorrectComments The comment to display if the student answers incorrectly.
     * @param questionNeutralComments The comment to display regardless of how the student answered.
     * @param questionTextAfterAnswers no description
     * @param questionAnswers no description
     */
    public async updateExistingQuizQuestion (courseId: string, quizId: number, id: number, questionQuestionName?: string, questionQuestionText?: string, questionQuizGroupId?: number, questionQuestionType?: string, questionPosition?: number, questionPointsPossible?: number, questionCorrectComments?: string, questionIncorrectComments?: string, questionNeutralComments?: string, questionTextAfterAnswers?: string, questionAnswers?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: QuizQuestion;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/quizzes/{quiz_id}/questions/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'quiz_id' + '}', encodeURIComponent(String(quizId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateExistingQuizQuestion.');
        }

        // verify required parameter 'quizId' is not null or undefined
        if (quizId === null || quizId === undefined) {
            throw new Error('Required parameter quizId was null or undefined when calling updateExistingQuizQuestion.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateExistingQuizQuestion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (questionQuestionName !== undefined) {
            localVarFormParams['question[question_name]'] = ObjectSerializer.serialize(questionQuestionName, "string");
        }

        if (questionQuestionText !== undefined) {
            localVarFormParams['question[question_text]'] = ObjectSerializer.serialize(questionQuestionText, "string");
        }

        if (questionQuizGroupId !== undefined) {
            localVarFormParams['question[quiz_group_id]'] = ObjectSerializer.serialize(questionQuizGroupId, "number");
        }

        if (questionQuestionType !== undefined) {
            localVarFormParams['question[question_type]'] = ObjectSerializer.serialize(questionQuestionType, "string");
        }

        if (questionPosition !== undefined) {
            localVarFormParams['question[position]'] = ObjectSerializer.serialize(questionPosition, "number");
        }

        if (questionPointsPossible !== undefined) {
            localVarFormParams['question[points_possible]'] = ObjectSerializer.serialize(questionPointsPossible, "number");
        }

        if (questionCorrectComments !== undefined) {
            localVarFormParams['question[correct_comments]'] = ObjectSerializer.serialize(questionCorrectComments, "string");
        }

        if (questionIncorrectComments !== undefined) {
            localVarFormParams['question[incorrect_comments]'] = ObjectSerializer.serialize(questionIncorrectComments, "string");
        }

        if (questionNeutralComments !== undefined) {
            localVarFormParams['question[neutral_comments]'] = ObjectSerializer.serialize(questionNeutralComments, "string");
        }

        if (questionTextAfterAnswers !== undefined) {
            localVarFormParams['question[text_after_answers]'] = ObjectSerializer.serialize(questionTextAfterAnswers, "string");
        }

        if (questionAnswers !== undefined) {
            localVarFormParams['question[answers]'] = ObjectSerializer.serialize(questionAnswers, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: QuizQuestion;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "QuizQuestion");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
