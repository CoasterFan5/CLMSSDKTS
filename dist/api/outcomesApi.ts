/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Outcome } from '../model/outcome';
import { OutcomeAlignment } from '../model/outcomeAlignment';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum OutcomesApiApiKeys {
}

export class OutcomesApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: OutcomesApiApiKeys, value: string) {
        (this.authentications as any)[OutcomesApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * 
     * @summary Get aligned assignments for an outcome in a course for a particular student
     * @param courseId The id of the course
     * @param studentId The id of the student
     */
    public async getAlignedAssignmentsForOutcomeInCourseForParticularStudent (courseId: number, studentId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<OutcomeAlignment>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/outcome_alignments'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getAlignedAssignmentsForOutcomeInCourseForParticularStudent.');
        }

        if (studentId !== undefined) {
            localVarQueryParameters['student_id'] = ObjectSerializer.serialize(studentId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<OutcomeAlignment>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<OutcomeAlignment>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the details of the outcome with the given id.
     * @summary Show an outcome
     * @param id ID
     * @param addDefaults If defaults are requested, then color and mastery level defaults will be added to outcome ratings in the result. This will only take effect if the Account Level Mastery Scales FF is DISABLED
     */
    public async showOutcome (id: string, addDefaults?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Outcome;  }> {
        const localVarPath = this.basePath + '/v1/outcomes/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling showOutcome.');
        }

        if (addDefaults !== undefined) {
            localVarQueryParameters['add_defaults'] = ObjectSerializer.serialize(addDefaults, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Outcome;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Outcome");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Modify an existing outcome. Fields not provided are left as is; unrecognized fields are ignored.  If any new ratings are provided, the combination of all new ratings provided completely replace any existing embedded rubric criterion; it is not possible to tweak the ratings of the embedded rubric criterion.  A new embedded rubric criterion\'s mastery_points default to the maximum points in the highest rating if not specified in the mastery_points parameter. Any new ratings lacking a description are given a default of \"No description\". Any new ratings lacking a point value are given a default of 0.
     * @summary Update an outcome
     * @param id ID
     * @param title The new outcome title.
     * @param displayName A friendly name shown in reports for outcomes with cryptic titles, such as common core standards names.
     * @param description The new outcome description.
     * @param vendorGuid A custom GUID for the learning standard.
     * @param masteryPoints The new mastery threshold for the embedded rubric criterion.
     * @param ratingsDescription The description of a new rating level for the embedded rubric criterion.
     * @param ratingsPoints The points corresponding to a new rating level for the embedded rubric criterion.
     * @param calculationMethod The new calculation method. If the Outcomes New Decaying Average Calculation Method FF is ENABLED then \\\&quot;weighted_average\\\&quot; can be used and it is same as previous \\\&quot;decaying_average\\\&quot; and new \\\&quot;decaying_average\\\&quot; will have improved version of calculation.
     * @param calculationInt The new calculation int.  Only applies if the calculation_method is \\\&quot;decaying_average\\\&quot; or \\\&quot;n_mastery\\\&quot;
     * @param addDefaults If defaults are requested, then color and mastery level defaults will be added to outcome ratings in the result. This will only take effect if the Account Level Mastery Scales FF is DISABLED
     */
    public async updateOutcome (id: string, title?: string, displayName?: string, description?: string, vendorGuid?: string, masteryPoints?: number, ratingsDescription?: Array<string>, ratingsPoints?: Array<number>, calculationMethod?: string, calculationInt?: number, addDefaults?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Outcome;  }> {
        const localVarPath = this.basePath + '/v1/outcomes/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateOutcome.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (title !== undefined) {
            localVarFormParams['title'] = ObjectSerializer.serialize(title, "string");
        }

        if (displayName !== undefined) {
            localVarFormParams['display_name'] = ObjectSerializer.serialize(displayName, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (vendorGuid !== undefined) {
            localVarFormParams['vendor_guid'] = ObjectSerializer.serialize(vendorGuid, "string");
        }

        if (masteryPoints !== undefined) {
            localVarFormParams['mastery_points'] = ObjectSerializer.serialize(masteryPoints, "number");
        }

        if (ratingsDescription !== undefined) {
            localVarFormParams['ratings[description]'] = ObjectSerializer.serialize(ratingsDescription, "Array<string>");
        }

        if (ratingsPoints !== undefined) {
            localVarFormParams['ratings[points]'] = ObjectSerializer.serialize(ratingsPoints, "Array<number>");
        }

        if (calculationMethod !== undefined) {
            localVarFormParams['calculation_method'] = ObjectSerializer.serialize(calculationMethod, "string");
        }

        if (calculationInt !== undefined) {
            localVarFormParams['calculation_int'] = ObjectSerializer.serialize(calculationInt, "number");
        }

        if (addDefaults !== undefined) {
            localVarFormParams['add_defaults'] = ObjectSerializer.serialize(addDefaults, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Outcome;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Outcome");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
