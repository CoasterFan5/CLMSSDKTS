/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { ACSVfileintheformatthatcanbeimported } from '../model/aCSVfileintheformatthatcanbeimported';
import { Rubric } from '../model/rubric';
import { RubricAssessment } from '../model/rubricAssessment';
import { RubricAssociation } from '../model/rubricAssociation';
import { RubricImport } from '../model/rubricImport';
import { UsedLocations } from '../model/usedLocations';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum RubricsApiApiKeys {
}

export class RubricsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: RubricsApiApiKeys, value: string) {
        (this.authentications as any)[RubricsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Returns the rubric with the given id.
     * @summary Create a RubricAssociation
     * @param courseId ID
     * @param rubricAssociationRubricId The id of the Rubric
     * @param rubricAssociationAssociationId The id of the object with which this rubric is associated
     * @param rubricAssociationAssociationType The type of object this rubric is associated with
     * @param rubricAssociationTitle The name of the object this rubric is associated with
     * @param rubricAssociationUseForGrading Whether or not the associated rubric is used for grade calculation
     * @param rubricAssociationHideScoreTotal Whether or not the score total is displayed within the rubric. This option is only available if the rubric is not used for grading.
     * @param rubricAssociationPurpose Whether or not the association is for grading (and thus linked to an assignment) or if it\\\&#39;s to indicate the rubric should appear in its context
     * @param rubricAssociationBookmarked Whether or not the associated rubric appears in its context
     */
    public async createRubricassociation (courseId: string, rubricAssociationRubricId?: number, rubricAssociationAssociationId?: number, rubricAssociationAssociationType?: string, rubricAssociationTitle?: string, rubricAssociationUseForGrading?: boolean, rubricAssociationHideScoreTotal?: boolean, rubricAssociationPurpose?: string, rubricAssociationBookmarked?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RubricAssociation;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/rubric_associations'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createRubricassociation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (rubricAssociationRubricId !== undefined) {
            localVarFormParams['rubric_association[rubric_id]'] = ObjectSerializer.serialize(rubricAssociationRubricId, "number");
        }

        if (rubricAssociationAssociationId !== undefined) {
            localVarFormParams['rubric_association[association_id]'] = ObjectSerializer.serialize(rubricAssociationAssociationId, "number");
        }

        if (rubricAssociationAssociationType !== undefined) {
            localVarFormParams['rubric_association[association_type]'] = ObjectSerializer.serialize(rubricAssociationAssociationType, "string");
        }

        if (rubricAssociationTitle !== undefined) {
            localVarFormParams['rubric_association[title]'] = ObjectSerializer.serialize(rubricAssociationTitle, "string");
        }

        if (rubricAssociationUseForGrading !== undefined) {
            localVarFormParams['rubric_association[use_for_grading]'] = ObjectSerializer.serialize(rubricAssociationUseForGrading, "boolean");
        }

        if (rubricAssociationHideScoreTotal !== undefined) {
            localVarFormParams['rubric_association[hide_score_total]'] = ObjectSerializer.serialize(rubricAssociationHideScoreTotal, "boolean");
        }

        if (rubricAssociationPurpose !== undefined) {
            localVarFormParams['rubric_association[purpose]'] = ObjectSerializer.serialize(rubricAssociationPurpose, "string");
        }

        if (rubricAssociationBookmarked !== undefined) {
            localVarFormParams['rubric_association[bookmarked]'] = ObjectSerializer.serialize(rubricAssociationBookmarked, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RubricAssociation;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RubricAssociation");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the rubric with the given id.  Unfortuantely this endpoint does not return a standard Rubric object, instead it returns a hash that looks like   { \'rubric\': Rubric, \'rubric_association\': RubricAssociation }  This may eventually be deprecated in favor of a more standardized return value, but that is not currently planned.  TODO: document once feature is public: rubric[criteria_via_llm] [Boolean]   When true, rubric[criteria] will be ignored (does not need to be included   at all). Instead, rubric criteria will be automatically generated from a   large language model (llm).
     * @summary Create a single rubric
     * @param courseId ID
     * @param id The id of the rubric
     * @param rubricAssociationId The id of the rubric association object (not the course/assignment itself, but the join table record id). It can be used in place of rubric_association[association_id] and rubric_association[association_type] if desired.
     * @param rubricTitle The title of the rubric
     * @param rubricFreeFormCriterionComments Whether or not you can write custom comments in the ratings field for a rubric
     * @param rubricAssociationAssociationId The id of the object with which this rubric is associated
     * @param rubricAssociationAssociationType The type of object this rubric is associated with
     * @param rubricAssociationUseForGrading Whether or not the associated rubric is used for grade calculation
     * @param rubricAssociationHideScoreTotal Whether or not the score total is displayed within the rubric. This option is only available if the rubric is not used for grading.
     * @param rubricAssociationPurpose Whether or not the association is for grading (and thus linked to an assignment) or if it\\\&#39;s to indicate the rubric should appear in its context
     * @param rubricCriteria An indexed Hash of RubricCriteria objects where the keys are integer ids and the values are the RubricCriteria objects
     */
    public async createSingleRubric (courseId: string, id?: number, rubricAssociationId?: number, rubricTitle?: string, rubricFreeFormCriterionComments?: boolean, rubricAssociationAssociationId?: number, rubricAssociationAssociationType?: string, rubricAssociationUseForGrading?: boolean, rubricAssociationHideScoreTotal?: boolean, rubricAssociationPurpose?: string, rubricCriteria?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/rubrics'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createSingleRubric.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (id !== undefined) {
            localVarFormParams['id'] = ObjectSerializer.serialize(id, "number");
        }

        if (rubricAssociationId !== undefined) {
            localVarFormParams['rubric_association_id'] = ObjectSerializer.serialize(rubricAssociationId, "number");
        }

        if (rubricTitle !== undefined) {
            localVarFormParams['rubric[title]'] = ObjectSerializer.serialize(rubricTitle, "string");
        }

        if (rubricFreeFormCriterionComments !== undefined) {
            localVarFormParams['rubric[free_form_criterion_comments]'] = ObjectSerializer.serialize(rubricFreeFormCriterionComments, "boolean");
        }

        if (rubricAssociationAssociationId !== undefined) {
            localVarFormParams['rubric_association[association_id]'] = ObjectSerializer.serialize(rubricAssociationAssociationId, "number");
        }

        if (rubricAssociationAssociationType !== undefined) {
            localVarFormParams['rubric_association[association_type]'] = ObjectSerializer.serialize(rubricAssociationAssociationType, "string");
        }

        if (rubricAssociationUseForGrading !== undefined) {
            localVarFormParams['rubric_association[use_for_grading]'] = ObjectSerializer.serialize(rubricAssociationUseForGrading, "boolean");
        }

        if (rubricAssociationHideScoreTotal !== undefined) {
            localVarFormParams['rubric_association[hide_score_total]'] = ObjectSerializer.serialize(rubricAssociationHideScoreTotal, "boolean");
        }

        if (rubricAssociationPurpose !== undefined) {
            localVarFormParams['rubric_association[purpose]'] = ObjectSerializer.serialize(rubricAssociationPurpose, "string");
        }

        if (rubricCriteria !== undefined) {
            localVarFormParams['rubric[criteria]'] = ObjectSerializer.serialize(rubricCriteria, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the rubric assessment with the given id. The returned object also provides the information of   :ratings, :assessor_name, :related_group_submissions_and_assessments, :artifact
     * @summary Create a single rubric assessment
     * @param courseId The id of the course
     * @param rubricAssociationId The id of the object with which this rubric assessment is associated
     * @param provisional (optional) Indicates whether this assessment is provisional, defaults to false.
     * @param _final (optional) Indicates a provisional grade will be marked as final. It only takes effect if the provisional param is passed as true. Defaults to false.
     * @param gradedAnonymously (optional) Defaults to false
     * @param rubricAssessment A Hash of data to complement the rubric assessment: The user id that refers to the person being assessed   rubric_assessment[user_id] Assessment type. There are only three valid types:  \\\&#39;grading\\\&#39;, \\\&#39;peer_review\\\&#39;, or \\\&#39;provisional_grade\\\&#39;   rubric_assessment[assessment_type] The points awarded for this row.   rubric_assessment[criterion_id][points] Comments to add for this row.   rubric_assessment[criterion_id][comments] For each criterion_id, change the id by the criterion number, ex: criterion_123 If the criterion_id is not specified it defaults to false, and nothing is updated.
     */
    public async createSingleRubricAssessment (courseId: number, rubricAssociationId: number, provisional?: string, _final?: string, gradedAnonymously?: boolean, rubricAssessment?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/rubric_associations/{rubric_association_id}/rubric_assessments'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'rubric_association_id' + '}', encodeURIComponent(String(rubricAssociationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createSingleRubricAssessment.');
        }

        // verify required parameter 'rubricAssociationId' is not null or undefined
        if (rubricAssociationId === null || rubricAssociationId === undefined) {
            throw new Error('Required parameter rubricAssociationId was null or undefined when calling createSingleRubricAssessment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (provisional !== undefined) {
            localVarFormParams['provisional'] = ObjectSerializer.serialize(provisional, "string");
        }

        if (_final !== undefined) {
            localVarFormParams['final'] = ObjectSerializer.serialize(_final, "string");
        }

        if (gradedAnonymously !== undefined) {
            localVarFormParams['graded_anonymously'] = ObjectSerializer.serialize(gradedAnonymously, "boolean");
        }

        if (rubricAssessment !== undefined) {
            localVarFormParams['rubric_assessment'] = ObjectSerializer.serialize(rubricAssessment, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the rubric import object that was created
     * @summary Creates a rubric using a CSV file
     * @param accountId ID
     */
    public async createsRubricUsingCsvFileAccounts (accountId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RubricImport;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/rubrics/upload'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createsRubricUsingCsvFileAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RubricImport;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RubricImport");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the rubric import object that was created
     * @summary Creates a rubric using a CSV file
     * @param courseId ID
     */
    public async createsRubricUsingCsvFileCourses (courseId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RubricImport;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/rubrics/upload'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createsRubricUsingCsvFileCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RubricImport;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RubricImport");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete the RubricAssociation with the given ID
     * @summary Delete a RubricAssociation
     * @param courseId ID
     * @param id ID
     */
    public async deleteRubricassociation (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RubricAssociation;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/rubric_associations/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling deleteRubricassociation.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteRubricassociation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RubricAssociation;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RubricAssociation");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes a Rubric and removes all RubricAssociations.
     * @summary Delete a single
     * @param courseId ID
     * @param id ID
     */
    public async deleteSingle (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Rubric;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/rubrics/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling deleteSingle.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSingle.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Rubric;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Rubric");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes a rubric assessment
     * @summary Delete a single rubric assessment
     * @param courseId ID
     * @param rubricAssociationId ID
     * @param id ID
     */
    public async deleteSingleRubricAssessment (courseId: string, rubricAssociationId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RubricAssessment;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/rubric_associations/{rubric_association_id}/rubric_assessments/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'rubric_association_id' + '}', encodeURIComponent(String(rubricAssociationId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling deleteSingleRubricAssessment.');
        }

        // verify required parameter 'rubricAssociationId' is not null or undefined
        if (rubricAssociationId === null || rubricAssociationId === undefined) {
            throw new Error('Required parameter rubricAssociationId was null or undefined when calling deleteSingleRubricAssessment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSingleRubricAssessment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RubricAssessment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RubricAssessment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the rubric with the given id.
     * @summary Get the courses and assignments for
     * @param accountId ID
     * @param id ID
     */
    public async getCoursesAndAssignmentsForAccounts (accountId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UsedLocations;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/rubrics/{id}/used_locations'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getCoursesAndAssignmentsForAccounts.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCoursesAndAssignmentsForAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UsedLocations;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "UsedLocations");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the rubric with the given id.
     * @summary Get the courses and assignments for
     * @param courseId ID
     * @param id ID
     */
    public async getCoursesAndAssignmentsForCourses (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UsedLocations;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/rubrics/{id}/used_locations'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getCoursesAndAssignmentsForCourses.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCoursesAndAssignmentsForCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UsedLocations;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "UsedLocations");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the rubric with the given id.
     * @summary Get a single rubric
     * @param accountId ID
     * @param id ID
     * @param include Related records to include in the response.
     * @param style Applicable only if assessments are being returned. If included, returns either all criteria data associated with the assessment, or just the comments. If not included, both data and comments are omitted.
     */
    public async getSingleRubricAccounts (accountId: string, id: string, include?: Array<string>, style?: 'full' | 'comments_only', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Rubric;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/rubrics/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getSingleRubricAccounts.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSingleRubricAccounts.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (style !== undefined) {
            localVarQueryParameters['style'] = ObjectSerializer.serialize(style, "'full' | 'comments_only'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Rubric;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Rubric");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the rubric with the given id.
     * @summary Get a single rubric
     * @param courseId ID
     * @param id ID
     * @param include Related records to include in the response.
     * @param style Applicable only if assessments are being returned. If included, returns either all criteria data associated with the assessment, or just the comments. If not included, both data and comments are omitted.
     */
    public async getSingleRubricCourses (courseId: string, id: string, include?: Array<string>, style?: 'full' | 'comments_only', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Rubric;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/rubrics/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getSingleRubricCourses.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSingleRubricCourses.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (style !== undefined) {
            localVarQueryParameters['style'] = ObjectSerializer.serialize(style, "'full' | 'comments_only'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Rubric;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Rubric");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Can return the latest rubric import for an account or course, or a specific import by id
     * @summary Get the status of a rubric import
     * @param accountId ID
     * @param id ID
     */
    public async getStatusOfRubricImportAccounts (accountId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RubricImport;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/rubrics/upload/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getStatusOfRubricImportAccounts.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getStatusOfRubricImportAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RubricImport;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RubricImport");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Can return the latest rubric import for an account or course, or a specific import by id
     * @summary Get the status of a rubric import
     * @param courseId ID
     * @param id ID
     */
    public async getStatusOfRubricImportCourses (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RubricImport;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/rubrics/upload/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getStatusOfRubricImportCourses.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getStatusOfRubricImportCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RubricImport;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RubricImport");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the paginated list of active rubrics for the current context.
     * @summary List rubrics
     * @param accountId ID
     */
    public async listRubricsAccounts (accountId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/rubrics'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listRubricsAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the paginated list of active rubrics for the current context.
     * @summary List rubrics
     * @param courseId ID
     */
    public async listRubricsCourses (courseId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/rubrics'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listRubricsCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Templated file for importing a rubric
     */
    public async templatedFileForImportingRubric (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: A CSV file in the format that can be imported;  }> {
        const localVarPath = this.basePath + '/v1/rubrics/upload_template';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: A CSV file in the format that can be imported;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "A CSV file in the format that can be imported");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the rubric with the given id.
     * @summary Update a RubricAssociation
     * @param courseId ID
     * @param id The id of the RubricAssociation to update
     * @param rubricAssociationRubricId The id of the Rubric
     * @param rubricAssociationAssociationId The id of the object with which this rubric is associated
     * @param rubricAssociationAssociationType The type of object this rubric is associated with
     * @param rubricAssociationTitle The name of the object this rubric is associated with
     * @param rubricAssociationUseForGrading Whether or not the associated rubric is used for grade calculation
     * @param rubricAssociationHideScoreTotal Whether or not the score total is displayed within the rubric. This option is only available if the rubric is not used for grading.
     * @param rubricAssociationPurpose Whether or not the association is for grading (and thus linked to an assignment) or if it\\\&#39;s to indicate the rubric should appear in its context
     * @param rubricAssociationBookmarked Whether or not the associated rubric appears in its context
     */
    public async updateRubricassociation (courseId: string, id: number, rubricAssociationRubricId?: number, rubricAssociationAssociationId?: number, rubricAssociationAssociationType?: string, rubricAssociationTitle?: string, rubricAssociationUseForGrading?: boolean, rubricAssociationHideScoreTotal?: boolean, rubricAssociationPurpose?: string, rubricAssociationBookmarked?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RubricAssociation;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/rubric_associations/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateRubricassociation.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateRubricassociation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (rubricAssociationRubricId !== undefined) {
            localVarFormParams['rubric_association[rubric_id]'] = ObjectSerializer.serialize(rubricAssociationRubricId, "number");
        }

        if (rubricAssociationAssociationId !== undefined) {
            localVarFormParams['rubric_association[association_id]'] = ObjectSerializer.serialize(rubricAssociationAssociationId, "number");
        }

        if (rubricAssociationAssociationType !== undefined) {
            localVarFormParams['rubric_association[association_type]'] = ObjectSerializer.serialize(rubricAssociationAssociationType, "string");
        }

        if (rubricAssociationTitle !== undefined) {
            localVarFormParams['rubric_association[title]'] = ObjectSerializer.serialize(rubricAssociationTitle, "string");
        }

        if (rubricAssociationUseForGrading !== undefined) {
            localVarFormParams['rubric_association[use_for_grading]'] = ObjectSerializer.serialize(rubricAssociationUseForGrading, "boolean");
        }

        if (rubricAssociationHideScoreTotal !== undefined) {
            localVarFormParams['rubric_association[hide_score_total]'] = ObjectSerializer.serialize(rubricAssociationHideScoreTotal, "boolean");
        }

        if (rubricAssociationPurpose !== undefined) {
            localVarFormParams['rubric_association[purpose]'] = ObjectSerializer.serialize(rubricAssociationPurpose, "string");
        }

        if (rubricAssociationBookmarked !== undefined) {
            localVarFormParams['rubric_association[bookmarked]'] = ObjectSerializer.serialize(rubricAssociationBookmarked, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RubricAssociation;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RubricAssociation");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the rubric with the given id.  Unfortuantely this endpoint does not return a standard Rubric object, instead it returns a hash that looks like   { \'rubric\': Rubric, \'rubric_association\': RubricAssociation }  This may eventually be deprecated in favor of a more standardized return value, but that is not currently planned.
     * @summary Update a single rubric
     * @param courseId ID
     * @param id The id of the rubric
     * @param rubricAssociationId The id of the rubric association object (not the course/assignment itself, but the join table record id). It can be used in place of rubric_association[association_id] and rubric_association[association_type] if desired.
     * @param rubricTitle The title of the rubric
     * @param rubricFreeFormCriterionComments Whether or not you can write custom comments in the ratings field for a rubric
     * @param rubricSkipUpdatingPointsPossible Whether or not to update the points possible
     * @param rubricAssociationAssociationId The id of the object with which this rubric is associated
     * @param rubricAssociationAssociationType The type of object this rubric is associated with
     * @param rubricAssociationUseForGrading Whether or not the associated rubric is used for grade calculation
     * @param rubricAssociationHideScoreTotal Whether or not the score total is displayed within the rubric. This option is only available if the rubric is not used for grading.
     * @param rubricAssociationPurpose Whether or not the association is for grading (and thus linked to an assignment) or if it\\\&#39;s to indicate the rubric should appear in its context
     * @param rubricCriteria An indexed Hash of RubricCriteria objects where the keys are integer ids and the values are the RubricCriteria objects
     */
    public async updateSingleRubric (courseId: string, id: number, rubricAssociationId?: number, rubricTitle?: string, rubricFreeFormCriterionComments?: boolean, rubricSkipUpdatingPointsPossible?: boolean, rubricAssociationAssociationId?: number, rubricAssociationAssociationType?: string, rubricAssociationUseForGrading?: boolean, rubricAssociationHideScoreTotal?: boolean, rubricAssociationPurpose?: string, rubricCriteria?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/rubrics/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateSingleRubric.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSingleRubric.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (rubricAssociationId !== undefined) {
            localVarFormParams['rubric_association_id'] = ObjectSerializer.serialize(rubricAssociationId, "number");
        }

        if (rubricTitle !== undefined) {
            localVarFormParams['rubric[title]'] = ObjectSerializer.serialize(rubricTitle, "string");
        }

        if (rubricFreeFormCriterionComments !== undefined) {
            localVarFormParams['rubric[free_form_criterion_comments]'] = ObjectSerializer.serialize(rubricFreeFormCriterionComments, "boolean");
        }

        if (rubricSkipUpdatingPointsPossible !== undefined) {
            localVarFormParams['rubric[skip_updating_points_possible]'] = ObjectSerializer.serialize(rubricSkipUpdatingPointsPossible, "boolean");
        }

        if (rubricAssociationAssociationId !== undefined) {
            localVarFormParams['rubric_association[association_id]'] = ObjectSerializer.serialize(rubricAssociationAssociationId, "number");
        }

        if (rubricAssociationAssociationType !== undefined) {
            localVarFormParams['rubric_association[association_type]'] = ObjectSerializer.serialize(rubricAssociationAssociationType, "string");
        }

        if (rubricAssociationUseForGrading !== undefined) {
            localVarFormParams['rubric_association[use_for_grading]'] = ObjectSerializer.serialize(rubricAssociationUseForGrading, "boolean");
        }

        if (rubricAssociationHideScoreTotal !== undefined) {
            localVarFormParams['rubric_association[hide_score_total]'] = ObjectSerializer.serialize(rubricAssociationHideScoreTotal, "boolean");
        }

        if (rubricAssociationPurpose !== undefined) {
            localVarFormParams['rubric_association[purpose]'] = ObjectSerializer.serialize(rubricAssociationPurpose, "string");
        }

        if (rubricCriteria !== undefined) {
            localVarFormParams['rubric[criteria]'] = ObjectSerializer.serialize(rubricCriteria, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the rubric assessment with the given id. The returned object also provides the information of   :ratings, :assessor_name, :related_group_submissions_and_assessments, :artifact
     * @summary Update a single rubric assessment
     * @param id The id of the rubric assessment
     * @param courseId The id of the course
     * @param rubricAssociationId The id of the object with which this rubric assessment is associated
     * @param provisional (optional) Indicates whether this assessment is provisional, defaults to false.
     * @param _final (optional) Indicates a provisional grade will be marked as final. It only takes effect if the provisional param is passed as true. Defaults to false.
     * @param gradedAnonymously (optional) Defaults to false
     * @param rubricAssessment A Hash of data to complement the rubric assessment: The user id that refers to the person being assessed   rubric_assessment[user_id] Assessment type. There are only three valid types:  \\\&#39;grading\\\&#39;, \\\&#39;peer_review\\\&#39;, or \\\&#39;provisional_grade\\\&#39;   rubric_assessment[assessment_type] The points awarded for this row.   rubric_assessment[criterion_id][points] Comments to add for this row.   rubric_assessment[criterion_id][comments] For each criterion_id, change the id by the criterion number, ex: criterion_123 If the criterion_id is not specified it defaults to false, and nothing is updated.
     */
    public async updateSingleRubricAssessment (id: number, courseId: number, rubricAssociationId: number, provisional?: string, _final?: string, gradedAnonymously?: boolean, rubricAssessment?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/rubric_associations/{rubric_association_id}/rubric_assessments/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'rubric_association_id' + '}', encodeURIComponent(String(rubricAssociationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSingleRubricAssessment.');
        }

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateSingleRubricAssessment.');
        }

        // verify required parameter 'rubricAssociationId' is not null or undefined
        if (rubricAssociationId === null || rubricAssociationId === undefined) {
            throw new Error('Required parameter rubricAssociationId was null or undefined when calling updateSingleRubricAssessment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (provisional !== undefined) {
            localVarFormParams['provisional'] = ObjectSerializer.serialize(provisional, "string");
        }

        if (_final !== undefined) {
            localVarFormParams['final'] = ObjectSerializer.serialize(_final, "string");
        }

        if (gradedAnonymously !== undefined) {
            localVarFormParams['graded_anonymously'] = ObjectSerializer.serialize(gradedAnonymously, "boolean");
        }

        if (rubricAssessment !== undefined) {
            localVarFormParams['rubric_assessment'] = ObjectSerializer.serialize(rubricAssessment, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
