/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Role } from '../model/role';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum RolesApiApiKeys {
}

export class RolesApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: RolesApiApiKeys, value: string) {
        (this.authentications as any)[RolesApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Re-activates an inactive role (allowing it to be assigned to new users)
     * @summary Activate a role
     * @param accountId ID
     * @param id ID
     * @param roleId The unique identifier for the role
     * @param role The name for the role
     */
    public async activateRole (accountId: string, id: string, roleId: number, role?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Role;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/roles/{id}/activate'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling activateRole.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling activateRole.');
        }

        // verify required parameter 'roleId' is not null or undefined
        if (roleId === null || roleId === undefined) {
            throw new Error('Required parameter roleId was null or undefined when calling activateRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (roleId !== undefined) {
            localVarFormParams['role_id'] = ObjectSerializer.serialize(roleId, "number");
        }

        if (role !== undefined) {
            localVarFormParams['role'] = ObjectSerializer.serialize(role, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Role;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Role");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a new course-level or account-level role.
     * @summary Create a new role
     * @param accountId ID
     * @param label Label for the role.
     * @param role Deprecated alias for label.
     * @param baseRoleType Specifies the role type that will be used as a base for the permissions granted to this role.  Defaults to \\\&#39;AccountMembership\\\&#39; if absent
     * @param permissionsXExplicit no description
     * @param permissionsXEnabled If explicit is 1 and enabled is 1, permission &lt;X&gt; will be explicitly granted to this role. If explicit is 1 and enabled has any other value (typically 0), permission &lt;X&gt; will be explicitly denied to this role. If explicit is any other value (typically 0) or absent, or if enabled is absent, the value for permission &lt;X&gt; will be inherited from upstream. Ignored if permission &lt;X&gt; is locked upstream (in an ancestor account).  May occur multiple times with unique values for &lt;X&gt;. Recognized permission names for &lt;X&gt; are:    [For Account-Level Roles Only]   become_user                      -- Users - act as   import_sis                       -- SIS Data - import   manage_account_memberships       -- Admins - add / remove   manage_account_settings          -- Account-level settings - manage   manage_alerts                    -- Global announcements - add / edit / delete   manage_catalog                   -- Catalog - manage   Manage Course Templates granular permissions       add_course_template          -- Course Templates - add       delete_course_template       -- Course Templates - delete       edit_course_template         -- Course Templates - edit   manage_courses_add               -- Courses - add   manage_courses_admin             -- Courses - manage / update   manage_developer_keys            -- Developer keys - manage   manage_feature_flags             -- Feature Options - enable / disable   manage_master_courses            -- Blueprint Courses - add / edit / associate / delete   manage_role_overrides            -- Permissions - manage   manage_storage_quotas            -- Storage Quotas - manage   manage_sis                       -- SIS data - manage   Manage Temporary Enrollments granular permissions       temporary_enrollments_add     -- Temporary Enrollments - add       temporary_enrollments_edit    -- Temporary Enrollments - edit       temporary_enrollments_delete  -- Temporary Enrollments - delete   manage_user_logins               -- Users - manage login details   manage_user_observers            -- Users - manage observers   moderate_user_content            -- Users - moderate content   read_course_content              -- Course Content - view   read_course_list                 -- Courses - view list   view_course_changes              -- Courses - view change logs   view_feature_flags               -- Feature Options - view   view_grade_changes               -- Grades - view change logs   view_notifications               -- Notifications - view   view_quiz_answer_audits          -- Quizzes - view submission log   view_statistics                  -- Statistics - view   undelete_courses                 -- Courses - undelete    [For both Account-Level and Course-Level roles]    Note: Applicable enrollment types for course-level roles are given in brackets:          S &#x3D; student, T &#x3D; teacher (instructor), A &#x3D; TA, D &#x3D; designer, O &#x3D; observer.          Lower-case letters indicate permissions that are off by default.          A missing letter indicates the permission cannot be enabled for the role          or any derived custom roles.   allow_course_admin_actions       -- [ Tad ] Users - allow administrative actions in courses   create_collaborations            -- [STADo] Student Collaborations - create   create_conferences               -- [STADo] Web conferences - create   create_forum                     -- [STADo] Discussions - create   generate_observer_pairing_code   -- [ tado] Users - Generate observer pairing codes for students   import_outcomes                  -- [ TaDo] Learning Outcomes - import   manage_account_banks             -- [ td  ] Item Banks - manage account   share_banks_with_subaccounts     -- [ tad ] Item Banks - share with subaccounts   Manage Assignments and Quizzes granular permissions       manage_assignments_add       -- [ TADo] Assignments and Quizzes - add       manage_assignments_edit      -- [ TADo] Assignments and Quizzes - edit / manage       manage_assignments_delete    -- [ TADo] Assignments and Quizzes - delete   manage_calendar                  -- [sTADo] Course Calendar - add / edit / delete   Manage Course Content granular permissions       manage_course_content_add    -- [ TADo] Course Content - add       manage_course_content_edit   -- [ TADo] Course Content - edit       manage_course_content_delete -- [ TADo] Course Content - delete   manage_course_visibility         -- [ TAD ] Course - change visibility   Manage Courses granular permissions       manage_courses_conclude      -- [ TaD ] Courses - conclude       manage_courses_delete        -- [ TaD ] Courses - delete       manage_courses_publish       -- [ TaD ] Courses - publish       manage_courses_reset         -- [ TaD ] Courses - reset   Manage Files granular permissions       manage_files_add             -- [ TADo] Course Files - add       manage_files_edit            -- [ TADo] Course Files - edit       manage_files_delete          -- [ TADo] Course Files - delete   manage_grades                    -- [ TA  ] Grades - edit   Manage Groups granular permissions       manage_groups_add            -- [ TAD ] Groups - add       manage_groups_delete         -- [ TAD ] Groups - delete       manage_groups_manage         -- [ TAD ] Groups - manage   manage_interaction_alerts        -- [ Ta  ] Alerts - add / edit / delete   manage_outcomes                  -- [sTaDo] Learning Outcomes - add / edit / delete   manage_proficiency_calculations  -- [ t d ] Outcome Proficiency Calculations - add / edit / delete   manage_proficiency_scales        -- [ t d ] Outcome Proficiency/Mastery Scales - add / edit / delete   Manage Sections granular permissions       manage_sections_add          -- [ TaD ] Course Sections - add       manage_sections_edit         -- [ TaD ] Course Sections - edit       manage_sections_delete       -- [ TaD ] Course Sections - delete   manage_students                  -- [ TAD ] Users - manage students in courses   manage_rubrics                   -- [ TAD ] Rubrics - add / edit / delete   Manage Pages granular permissions       manage_wiki_create           -- [ TADo] Pages - create       manage_wiki_delete           -- [ TADo] Pages - delete       manage_wiki_update           -- [ TADo] Pages - update   moderate_forum                   -- [sTADo] Discussions - moderate   post_to_forum                    -- [STADo] Discussions - post   read_announcements               -- [STADO] Announcements - view   read_email_addresses             -- [sTAdo] Users - view primary email address   read_forum                       -- [STADO] Discussions - view   read_question_banks              -- [ TADo] Question banks - view and link   read_reports                     -- [ TAD ] Reports - manage   read_roster                      -- [STADo] Users - view list   read_sis                         -- [sTa  ] SIS Data - read   select_final_grade               -- [ TA  ] Grades - select final grade for moderation   send_messages                    -- [STADo] Conversations - send messages to individual course members   send_messages_all                -- [sTADo] Conversations - send messages to entire class   Users - Teacher granular permissions       add_teacher_to_course        -- [ Tad ] Add a teacher enrollment to a course       remove_teacher_from_course   -- [ Tad ] Remove a Teacher enrollment from a course   Users - TA granular permissions       add_ta_to_course             -- [ Tad ] Add a TA enrollment to a course       remove_ta_from_course        -- [ Tad ] Remove a TA enrollment from a course   Users - Designer granular permissions       add_designer_to_course       -- [ Tad ] Add a designer enrollment to a course       remove_designer_from_course  -- [ Tad ] Remove a designer enrollment from a course   Users - Observer granular permissions       add_observer_to_course       -- [ Tad ] Add an observer enrollment to a course       remove_observer_from_course  -- [ Tad ] Remove an observer enrollment from a course   Users - Student granular permissions       add_student_to_course        -- [ Tad ] Add a student enrollment to a course       remove_student_from_course   -- [ Tad ] Remove a student enrollment from a course   view_all_grades                  -- [ TAd ] Grades - view all grades   view_analytics                   -- [sTA  ] Analytics - view pages   view_audit_trail                 -- [ t   ] Grades - view audit trail   view_group_pages                 -- [sTADo] Groups - view all student groups   view_user_logins                 -- [ TA  ] Users - view login IDs  Some of these permissions are applicable only for roles on the site admin account, on a root account, or for course-level roles with a particular base role type; if a specified permission is inapplicable, it will be ignored.  Additional permissions may exist based on installed plugins.  A comprehensive list of all permissions are available:  Course Permissions PDF: http://bit.ly/cnvs-course-permissions  Account Permissions PDF: http://bit.ly/cnvs-acct-permissions
     * @param permissionsXLocked If the value is 1, permission &lt;X&gt; will be locked downstream (new roles in subaccounts cannot override the setting). For any other value, permission &lt;X&gt; is left unlocked. Ignored if permission &lt;X&gt; is already locked upstream. May occur multiple times with unique values for &lt;X&gt;.
     * @param permissionsXAppliesToSelf If the value is 1, permission &lt;X&gt; applies to the account this role is in. The default value is 1. Must be true if applies_to_descendants is false. This value is only returned if enabled is true.
     * @param permissionsXAppliesToDescendants If the value is 1, permission &lt;X&gt; cascades down to sub accounts of the account this role is in. The default value is 1.  Must be true if applies_to_self is false.This value is only returned if enabled is true.
     */
    public async createNewRole (accountId: string, label: string, role?: string, baseRoleType?: string, permissionsXExplicit?: boolean, permissionsXEnabled?: boolean, permissionsXLocked?: boolean, permissionsXAppliesToSelf?: boolean, permissionsXAppliesToDescendants?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Role;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/roles'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createNewRole.');
        }

        // verify required parameter 'label' is not null or undefined
        if (label === null || label === undefined) {
            throw new Error('Required parameter label was null or undefined when calling createNewRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (label !== undefined) {
            localVarFormParams['label'] = ObjectSerializer.serialize(label, "string");
        }

        if (role !== undefined) {
            localVarFormParams['role'] = ObjectSerializer.serialize(role, "string");
        }

        if (baseRoleType !== undefined) {
            localVarFormParams['base_role_type'] = ObjectSerializer.serialize(baseRoleType, "string");
        }

        if (permissionsXExplicit !== undefined) {
            localVarFormParams['permissions[&lt;X&gt;][explicit]'] = ObjectSerializer.serialize(permissionsXExplicit, "boolean");
        }

        if (permissionsXEnabled !== undefined) {
            localVarFormParams['permissions[&lt;X&gt;][enabled]'] = ObjectSerializer.serialize(permissionsXEnabled, "boolean");
        }

        if (permissionsXLocked !== undefined) {
            localVarFormParams['permissions[&lt;X&gt;][locked]'] = ObjectSerializer.serialize(permissionsXLocked, "boolean");
        }

        if (permissionsXAppliesToSelf !== undefined) {
            localVarFormParams['permissions[&lt;X&gt;][applies_to_self]'] = ObjectSerializer.serialize(permissionsXAppliesToSelf, "boolean");
        }

        if (permissionsXAppliesToDescendants !== undefined) {
            localVarFormParams['permissions[&lt;X&gt;][applies_to_descendants]'] = ObjectSerializer.serialize(permissionsXAppliesToDescendants, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Role;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Role");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deactivates a custom role.  This hides it in the user interface and prevents it from being assigned to new users.  Existing users assigned to the role will continue to function with the same permissions they had previously. Built-in roles cannot be deactivated.
     * @summary Deactivate a role
     * @param accountId ID
     * @param id ID
     * @param roleId The unique identifier for the role
     * @param role The name for the role
     */
    public async deactivateRole (accountId: string, id: string, roleId: number, role?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Role;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/roles/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deactivateRole.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deactivateRole.');
        }

        // verify required parameter 'roleId' is not null or undefined
        if (roleId === null || roleId === undefined) {
            throw new Error('Required parameter roleId was null or undefined when calling deactivateRole.');
        }

        if (roleId !== undefined) {
            localVarQueryParameters['role_id'] = ObjectSerializer.serialize(roleId, "number");
        }

        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Role;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Role");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve information about a single role
     * @summary Get a single role
     * @param id ID
     * @param accountId The id of the account containing the role
     * @param roleId The unique identifier for the role
     * @param role The name for the role
     */
    public async getSingleRole (id: string, accountId: string, roleId: number, role?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Role;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/roles/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSingleRole.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getSingleRole.');
        }

        // verify required parameter 'roleId' is not null or undefined
        if (roleId === null || roleId === undefined) {
            throw new Error('Required parameter roleId was null or undefined when calling getSingleRole.');
        }

        if (roleId !== undefined) {
            localVarQueryParameters['role_id'] = ObjectSerializer.serialize(roleId, "number");
        }

        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Role;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Role");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of the roles available to an account.
     * @summary List roles
     * @param accountId The id of the account to retrieve roles for.
     * @param state Filter by role state. If this argument is omitted, only \&#39;active\&#39; roles are returned.
     * @param showInherited If this argument is true, all roles inherited from parent accounts will be included.
     */
    public async listRoles (accountId: string, state?: Array<string>, showInherited?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Role>;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/roles'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listRoles.');
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<string>");
        }

        if (showInherited !== undefined) {
            localVarQueryParameters['show_inherited'] = ObjectSerializer.serialize(showInherited, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Role>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Role>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update permissions for an existing role.  Recognized roles are: * TeacherEnrollment * StudentEnrollment * TaEnrollment * ObserverEnrollment * DesignerEnrollment * AccountAdmin * Any previously created custom role
     * @summary Update a role
     * @param accountId ID
     * @param id ID
     * @param label The label for the role. Can only change the label of a custom role that belongs directly to the account.
     * @param permissionsXExplicit no description
     * @param permissionsXEnabled These arguments are described in the documentation for the {api:RoleOverridesController#add_role add_role method}.
     * @param permissionsXAppliesToSelf If the value is 1, permission &lt;X&gt; applies to the account this role is in. The default value is 1. Must be true if applies_to_descendants is false. This value is only returned if enabled is true.
     * @param permissionsXAppliesToDescendants If the value is 1, permission &lt;X&gt; cascades down to sub accounts of the account this role is in. The default value is 1.  Must be true if applies_to_self is false.This value is only returned if enabled is true.
     */
    public async updateRole (accountId: string, id: string, label?: string, permissionsXExplicit?: boolean, permissionsXEnabled?: boolean, permissionsXAppliesToSelf?: boolean, permissionsXAppliesToDescendants?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Role;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/roles/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateRole.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (label !== undefined) {
            localVarFormParams['label'] = ObjectSerializer.serialize(label, "string");
        }

        if (permissionsXExplicit !== undefined) {
            localVarFormParams['permissions[&lt;X&gt;][explicit]'] = ObjectSerializer.serialize(permissionsXExplicit, "boolean");
        }

        if (permissionsXEnabled !== undefined) {
            localVarFormParams['permissions[&lt;X&gt;][enabled]'] = ObjectSerializer.serialize(permissionsXEnabled, "boolean");
        }

        if (permissionsXAppliesToSelf !== undefined) {
            localVarFormParams['permissions[&lt;X&gt;][applies_to_self]'] = ObjectSerializer.serialize(permissionsXAppliesToSelf, "boolean");
        }

        if (permissionsXAppliesToDescendants !== undefined) {
            localVarFormParams['permissions[&lt;X&gt;][applies_to_descendants]'] = ObjectSerializer.serialize(permissionsXAppliesToDescendants, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Role;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Role");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
