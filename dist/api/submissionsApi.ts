/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Progress } from '../model/progress';
import { Submission } from '../model/submission';
import { UserDisplayifanonymousgradingisnotenabledfortheassignmentoriftheallowNewAnonymousIdparameterisnottrue } from '../model/userDisplayifanonymousgradingisnotenabledfortheassignmentoriftheallowNewAnonymousIdparameterisnottrue';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum SubmissionsApiApiKeys {
}

export class SubmissionsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: SubmissionsApiApiKeys, value: string) {
        (this.authentications as any)[SubmissionsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Site-admin-only endpoint.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Clear unread status for all submissions.
     * @param courseId ID
     * @param userId ID
     */
    public async clearUnreadStatusForAllSubmissionsCourses (courseId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/submissions/{user_id}/clear_unread'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling clearUnreadStatusForAllSubmissionsCourses.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling clearUnreadStatusForAllSubmissionsCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Site-admin-only endpoint.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Clear unread status for all submissions.
     * @param sectionId ID
     * @param userId ID
     */
    public async clearUnreadStatusForAllSubmissionsSections (sectionId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/submissions/{user_id}/clear_unread'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling clearUnreadStatusForAllSubmissionsSections.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling clearUnreadStatusForAllSubmissionsSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Return whether annotations made on a submitted document have been read by the student
     * @summary Get document annotations read state
     * @param courseId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async getDocumentAnnotationsReadStateCourses (courseId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/document_annotations/read'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getDocumentAnnotationsReadStateCourses.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling getDocumentAnnotationsReadStateCourses.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getDocumentAnnotationsReadStateCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Return whether annotations made on a submitted document have been read by the student
     * @summary Get document annotations read state
     * @param sectionId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async getDocumentAnnotationsReadStateSections (sectionId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/document_annotations/read'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling getDocumentAnnotationsReadStateSections.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling getDocumentAnnotationsReadStateSections.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getDocumentAnnotationsReadStateSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Return whether new rubric comments/grading made on a submission have been seen by the student being assessed.
     * @summary Get rubric assessments read state
     * @param courseId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async getRubricAssessmentsReadStateCoursesRubricAssessments (courseId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/rubric_assessments/read'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getRubricAssessmentsReadStateCoursesRubricAssessments.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling getRubricAssessmentsReadStateCoursesRubricAssessments.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getRubricAssessmentsReadStateCoursesRubricAssessments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Return whether new rubric comments/grading made on a submission have been seen by the student being assessed.
     * @summary Get rubric assessments read state
     * @param courseId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async getRubricAssessmentsReadStateCoursesRubricComments (courseId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/rubric_comments/read'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getRubricAssessmentsReadStateCoursesRubricComments.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling getRubricAssessmentsReadStateCoursesRubricComments.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getRubricAssessmentsReadStateCoursesRubricComments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Return whether new rubric comments/grading made on a submission have been seen by the student being assessed.
     * @summary Get rubric assessments read state
     * @param sectionId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async getRubricAssessmentsReadStateSectionsRubricAssessments (sectionId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/rubric_assessments/read'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling getRubricAssessmentsReadStateSectionsRubricAssessments.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling getRubricAssessmentsReadStateSectionsRubricAssessments.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getRubricAssessmentsReadStateSectionsRubricAssessments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Return whether new rubric comments/grading made on a submission have been seen by the student being assessed.
     * @summary Get rubric assessments read state
     * @param sectionId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async getRubricAssessmentsReadStateSectionsRubricComments (sectionId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/rubric_comments/read'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling getRubricAssessmentsReadStateSectionsRubricComments.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling getRubricAssessmentsReadStateSectionsRubricComments.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getRubricAssessmentsReadStateSectionsRubricComments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a single submission, based on the submission\'s anonymous id.
     * @summary Get a single submission by anonymous id
     * @param courseId ID
     * @param assignmentId ID
     * @param anonymousId ID
     * @param include Associations to include with the group.
     */
    public async getSingleSubmissionByAnonymousIdCourses (courseId: string, assignmentId: string, anonymousId: string, include?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/anonymous_submissions/{anonymous_id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'anonymous_id' + '}', encodeURIComponent(String(anonymousId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getSingleSubmissionByAnonymousIdCourses.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling getSingleSubmissionByAnonymousIdCourses.');
        }

        // verify required parameter 'anonymousId' is not null or undefined
        if (anonymousId === null || anonymousId === undefined) {
            throw new Error('Required parameter anonymousId was null or undefined when calling getSingleSubmissionByAnonymousIdCourses.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a single submission, based on the submission\'s anonymous id.
     * @summary Get a single submission by anonymous id
     * @param sectionId ID
     * @param assignmentId ID
     * @param anonymousId ID
     * @param include Associations to include with the group.
     */
    public async getSingleSubmissionByAnonymousIdSections (sectionId: string, assignmentId: string, anonymousId: string, include?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/anonymous_submissions/{anonymous_id}'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'anonymous_id' + '}', encodeURIComponent(String(anonymousId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling getSingleSubmissionByAnonymousIdSections.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling getSingleSubmissionByAnonymousIdSections.');
        }

        // verify required parameter 'anonymousId' is not null or undefined
        if (anonymousId === null || anonymousId === undefined) {
            throw new Error('Required parameter anonymousId was null or undefined when calling getSingleSubmissionByAnonymousIdSections.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a single submission, based on user id.
     * @summary Get a single submission
     * @param courseId ID
     * @param assignmentId ID
     * @param userId ID
     * @param include Associations to include with the group.
     */
    public async getSingleSubmissionCourses (courseId: string, assignmentId: string, userId: string, include?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getSingleSubmissionCourses.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling getSingleSubmissionCourses.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getSingleSubmissionCourses.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a single submission, based on user id.
     * @summary Get a single submission
     * @param sectionId ID
     * @param assignmentId ID
     * @param userId ID
     * @param include Associations to include with the group.
     */
    public async getSingleSubmissionSections (sectionId: string, assignmentId: string, userId: string, include?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling getSingleSubmissionSections.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling getSingleSubmissionSections.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getSingleSubmissionSections.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the grading and comments on multiple student\'s assignment submissions in an asynchronous job.  The user must have permission to manage grades in the appropriate context (course or section).
     * @summary Grade or comment on multiple submissions
     * @param courseId ID
     * @param assignmentId ID
     * @param gradeDataStudentIdPostedGrade See documentation for the posted_grade argument in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataStudentIdExcuse See documentation for the excuse argument in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataStudentIdRubricAssessment See documentation for the rubric_assessment argument in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataStudentIdTextComment no description
     * @param gradeDataStudentIdGroupComment no description
     * @param gradeDataStudentIdMediaCommentId no description
     * @param gradeDataStudentIdMediaCommentType no description
     * @param gradeDataStudentIdFileIds See documentation for the comment[] arguments in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataAssignmentIdStudentId Specifies which assignment to grade.  This argument is not necessary when using the assignment-specific endpoints.
     */
    public async gradeOrCommentOnMultipleSubmissionsCoursesAssignments (courseId: string, assignmentId: string, gradeDataStudentIdPostedGrade?: string, gradeDataStudentIdExcuse?: boolean, gradeDataStudentIdRubricAssessment?: any, gradeDataStudentIdTextComment?: string, gradeDataStudentIdGroupComment?: boolean, gradeDataStudentIdMediaCommentId?: string, gradeDataStudentIdMediaCommentType?: string, gradeDataStudentIdFileIds?: Array<number>, gradeDataAssignmentIdStudentId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Progress;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/update_grades'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling gradeOrCommentOnMultipleSubmissionsCoursesAssignments.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling gradeOrCommentOnMultipleSubmissionsCoursesAssignments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (gradeDataStudentIdPostedGrade !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][posted_grade]'] = ObjectSerializer.serialize(gradeDataStudentIdPostedGrade, "string");
        }

        if (gradeDataStudentIdExcuse !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][excuse]'] = ObjectSerializer.serialize(gradeDataStudentIdExcuse, "boolean");
        }

        if (gradeDataStudentIdRubricAssessment !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][rubric_assessment]'] = ObjectSerializer.serialize(gradeDataStudentIdRubricAssessment, "any");
        }

        if (gradeDataStudentIdTextComment !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][text_comment]'] = ObjectSerializer.serialize(gradeDataStudentIdTextComment, "string");
        }

        if (gradeDataStudentIdGroupComment !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][group_comment]'] = ObjectSerializer.serialize(gradeDataStudentIdGroupComment, "boolean");
        }

        if (gradeDataStudentIdMediaCommentId !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][media_comment_id]'] = ObjectSerializer.serialize(gradeDataStudentIdMediaCommentId, "string");
        }

        if (gradeDataStudentIdMediaCommentType !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][media_comment_type]'] = ObjectSerializer.serialize(gradeDataStudentIdMediaCommentType, "string");
        }

        if (gradeDataStudentIdFileIds !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][file_ids]'] = ObjectSerializer.serialize(gradeDataStudentIdFileIds, "Array<number>");
        }

        if (gradeDataAssignmentIdStudentId !== undefined) {
            localVarFormParams['grade_data[&lt;assignment_id&gt;][&lt;student_id&gt;]'] = ObjectSerializer.serialize(gradeDataAssignmentIdStudentId, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Progress;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Progress");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the grading and comments on multiple student\'s assignment submissions in an asynchronous job.  The user must have permission to manage grades in the appropriate context (course or section).
     * @summary Grade or comment on multiple submissions
     * @param courseId ID
     * @param gradeDataStudentIdPostedGrade See documentation for the posted_grade argument in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataStudentIdExcuse See documentation for the excuse argument in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataStudentIdRubricAssessment See documentation for the rubric_assessment argument in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataStudentIdTextComment no description
     * @param gradeDataStudentIdGroupComment no description
     * @param gradeDataStudentIdMediaCommentId no description
     * @param gradeDataStudentIdMediaCommentType no description
     * @param gradeDataStudentIdFileIds See documentation for the comment[] arguments in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataAssignmentIdStudentId Specifies which assignment to grade.  This argument is not necessary when using the assignment-specific endpoints.
     */
    public async gradeOrCommentOnMultipleSubmissionsCoursesSubmissions (courseId: string, gradeDataStudentIdPostedGrade?: string, gradeDataStudentIdExcuse?: boolean, gradeDataStudentIdRubricAssessment?: any, gradeDataStudentIdTextComment?: string, gradeDataStudentIdGroupComment?: boolean, gradeDataStudentIdMediaCommentId?: string, gradeDataStudentIdMediaCommentType?: string, gradeDataStudentIdFileIds?: Array<number>, gradeDataAssignmentIdStudentId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Progress;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/submissions/update_grades'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling gradeOrCommentOnMultipleSubmissionsCoursesSubmissions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (gradeDataStudentIdPostedGrade !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][posted_grade]'] = ObjectSerializer.serialize(gradeDataStudentIdPostedGrade, "string");
        }

        if (gradeDataStudentIdExcuse !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][excuse]'] = ObjectSerializer.serialize(gradeDataStudentIdExcuse, "boolean");
        }

        if (gradeDataStudentIdRubricAssessment !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][rubric_assessment]'] = ObjectSerializer.serialize(gradeDataStudentIdRubricAssessment, "any");
        }

        if (gradeDataStudentIdTextComment !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][text_comment]'] = ObjectSerializer.serialize(gradeDataStudentIdTextComment, "string");
        }

        if (gradeDataStudentIdGroupComment !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][group_comment]'] = ObjectSerializer.serialize(gradeDataStudentIdGroupComment, "boolean");
        }

        if (gradeDataStudentIdMediaCommentId !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][media_comment_id]'] = ObjectSerializer.serialize(gradeDataStudentIdMediaCommentId, "string");
        }

        if (gradeDataStudentIdMediaCommentType !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][media_comment_type]'] = ObjectSerializer.serialize(gradeDataStudentIdMediaCommentType, "string");
        }

        if (gradeDataStudentIdFileIds !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][file_ids]'] = ObjectSerializer.serialize(gradeDataStudentIdFileIds, "Array<number>");
        }

        if (gradeDataAssignmentIdStudentId !== undefined) {
            localVarFormParams['grade_data[&lt;assignment_id&gt;][&lt;student_id&gt;]'] = ObjectSerializer.serialize(gradeDataAssignmentIdStudentId, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Progress;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Progress");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the grading and comments on multiple student\'s assignment submissions in an asynchronous job.  The user must have permission to manage grades in the appropriate context (course or section).
     * @summary Grade or comment on multiple submissions
     * @param sectionId ID
     * @param assignmentId ID
     * @param gradeDataStudentIdPostedGrade See documentation for the posted_grade argument in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataStudentIdExcuse See documentation for the excuse argument in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataStudentIdRubricAssessment See documentation for the rubric_assessment argument in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataStudentIdTextComment no description
     * @param gradeDataStudentIdGroupComment no description
     * @param gradeDataStudentIdMediaCommentId no description
     * @param gradeDataStudentIdMediaCommentType no description
     * @param gradeDataStudentIdFileIds See documentation for the comment[] arguments in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataAssignmentIdStudentId Specifies which assignment to grade.  This argument is not necessary when using the assignment-specific endpoints.
     */
    public async gradeOrCommentOnMultipleSubmissionsSectionsAssignments (sectionId: string, assignmentId: string, gradeDataStudentIdPostedGrade?: string, gradeDataStudentIdExcuse?: boolean, gradeDataStudentIdRubricAssessment?: any, gradeDataStudentIdTextComment?: string, gradeDataStudentIdGroupComment?: boolean, gradeDataStudentIdMediaCommentId?: string, gradeDataStudentIdMediaCommentType?: string, gradeDataStudentIdFileIds?: Array<number>, gradeDataAssignmentIdStudentId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Progress;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/update_grades'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling gradeOrCommentOnMultipleSubmissionsSectionsAssignments.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling gradeOrCommentOnMultipleSubmissionsSectionsAssignments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (gradeDataStudentIdPostedGrade !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][posted_grade]'] = ObjectSerializer.serialize(gradeDataStudentIdPostedGrade, "string");
        }

        if (gradeDataStudentIdExcuse !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][excuse]'] = ObjectSerializer.serialize(gradeDataStudentIdExcuse, "boolean");
        }

        if (gradeDataStudentIdRubricAssessment !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][rubric_assessment]'] = ObjectSerializer.serialize(gradeDataStudentIdRubricAssessment, "any");
        }

        if (gradeDataStudentIdTextComment !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][text_comment]'] = ObjectSerializer.serialize(gradeDataStudentIdTextComment, "string");
        }

        if (gradeDataStudentIdGroupComment !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][group_comment]'] = ObjectSerializer.serialize(gradeDataStudentIdGroupComment, "boolean");
        }

        if (gradeDataStudentIdMediaCommentId !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][media_comment_id]'] = ObjectSerializer.serialize(gradeDataStudentIdMediaCommentId, "string");
        }

        if (gradeDataStudentIdMediaCommentType !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][media_comment_type]'] = ObjectSerializer.serialize(gradeDataStudentIdMediaCommentType, "string");
        }

        if (gradeDataStudentIdFileIds !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][file_ids]'] = ObjectSerializer.serialize(gradeDataStudentIdFileIds, "Array<number>");
        }

        if (gradeDataAssignmentIdStudentId !== undefined) {
            localVarFormParams['grade_data[&lt;assignment_id&gt;][&lt;student_id&gt;]'] = ObjectSerializer.serialize(gradeDataAssignmentIdStudentId, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Progress;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Progress");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the grading and comments on multiple student\'s assignment submissions in an asynchronous job.  The user must have permission to manage grades in the appropriate context (course or section).
     * @summary Grade or comment on multiple submissions
     * @param sectionId ID
     * @param gradeDataStudentIdPostedGrade See documentation for the posted_grade argument in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataStudentIdExcuse See documentation for the excuse argument in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataStudentIdRubricAssessment See documentation for the rubric_assessment argument in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataStudentIdTextComment no description
     * @param gradeDataStudentIdGroupComment no description
     * @param gradeDataStudentIdMediaCommentId no description
     * @param gradeDataStudentIdMediaCommentType no description
     * @param gradeDataStudentIdFileIds See documentation for the comment[] arguments in the {api:SubmissionsApiController#update Submissions Update} documentation
     * @param gradeDataAssignmentIdStudentId Specifies which assignment to grade.  This argument is not necessary when using the assignment-specific endpoints.
     */
    public async gradeOrCommentOnMultipleSubmissionsSectionsSubmissions (sectionId: string, gradeDataStudentIdPostedGrade?: string, gradeDataStudentIdExcuse?: boolean, gradeDataStudentIdRubricAssessment?: any, gradeDataStudentIdTextComment?: string, gradeDataStudentIdGroupComment?: boolean, gradeDataStudentIdMediaCommentId?: string, gradeDataStudentIdMediaCommentType?: string, gradeDataStudentIdFileIds?: Array<number>, gradeDataAssignmentIdStudentId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Progress;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/submissions/update_grades'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling gradeOrCommentOnMultipleSubmissionsSectionsSubmissions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (gradeDataStudentIdPostedGrade !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][posted_grade]'] = ObjectSerializer.serialize(gradeDataStudentIdPostedGrade, "string");
        }

        if (gradeDataStudentIdExcuse !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][excuse]'] = ObjectSerializer.serialize(gradeDataStudentIdExcuse, "boolean");
        }

        if (gradeDataStudentIdRubricAssessment !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][rubric_assessment]'] = ObjectSerializer.serialize(gradeDataStudentIdRubricAssessment, "any");
        }

        if (gradeDataStudentIdTextComment !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][text_comment]'] = ObjectSerializer.serialize(gradeDataStudentIdTextComment, "string");
        }

        if (gradeDataStudentIdGroupComment !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][group_comment]'] = ObjectSerializer.serialize(gradeDataStudentIdGroupComment, "boolean");
        }

        if (gradeDataStudentIdMediaCommentId !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][media_comment_id]'] = ObjectSerializer.serialize(gradeDataStudentIdMediaCommentId, "string");
        }

        if (gradeDataStudentIdMediaCommentType !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][media_comment_type]'] = ObjectSerializer.serialize(gradeDataStudentIdMediaCommentType, "string");
        }

        if (gradeDataStudentIdFileIds !== undefined) {
            localVarFormParams['grade_data[&lt;student_id&gt;][file_ids]'] = ObjectSerializer.serialize(gradeDataStudentIdFileIds, "Array<number>");
        }

        if (gradeDataAssignmentIdStudentId !== undefined) {
            localVarFormParams['grade_data[&lt;assignment_id&gt;][&lt;student_id&gt;]'] = ObjectSerializer.serialize(gradeDataAssignmentIdStudentId, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Progress;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Progress");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Comment on and/or update the grading for a student\'s assignment submission, fetching the submission by anonymous id (instead of user id). If any submission or rubric_assessment arguments are provided, the user must have permission to manage grades in the appropriate context (course or section).
     * @summary Grade or comment on a submission by anonymous id
     * @param courseId ID
     * @param assignmentId ID
     * @param anonymousId ID
     * @param commentTextComment Add a textual comment to the submission.
     * @param commentGroupComment Whether or not this comment should be sent to the entire group (defaults to false). Ignored if this is not a group assignment or if no text_comment is provided.
     * @param commentMediaCommentId Add an audio/video comment to the submission. Media comments can be added via this API, however, note that there is not yet an API to generate or list existing media comments, so this functionality is currently of limited use.
     * @param commentMediaCommentType The type of media comment being added.
     * @param commentFileIds Attach files to this comment that were previously uploaded using the Submission Comment API\\\&#39;s files action
     * @param includeVisibility Whether this assignment is visible to the owner of the submission
     * @param submissionPostedGrade Assign a score to the submission, updating both the \\\&quot;score\\\&quot; and \\\&quot;grade\\\&quot; fields on the submission record. This parameter can be passed in a few different formats:  points:: A floating point or integral value, such as \\\&quot;13.5\\\&quot;. The grade   will be interpreted directly as the score of the assignment.   Values above assignment.points_possible are allowed, for awarding   extra credit. percentage:: A floating point value appended with a percent sign, such as    \\\&quot;40%\\\&quot;. The grade will be interpreted as a percentage score on the    assignment, where 100% &#x3D;&#x3D; assignment.points_possible. Values above 100%    are allowed, for awarding extra credit. letter grade:: A letter grade, following the assignment\\\&#39;s defined letter    grading scheme. For example, \\\&quot;A-\\\&quot;. The resulting score will be the high    end of the defined range for the letter grade. For instance, if \\\&quot;B\\\&quot; is    defined as 86% to 84%, a letter grade of \\\&quot;B\\\&quot; will be worth 86%. The    letter grade will be rejected if the assignment does not have a defined    letter grading scheme. For more fine-grained control of scores, pass in    points or percentage rather than the letter grade. \\\&quot;pass/complete/fail/incomplete\\\&quot;:: A string value of \\\&quot;pass\\\&quot; or \\\&quot;complete\\\&quot;    will give a score of 100%. \\\&quot;fail\\\&quot; or \\\&quot;incomplete\\\&quot; will give a score of    0.  Note that assignments with grading_type of \\\&quot;pass_fail\\\&quot; can only be assigned a score of 0 or assignment.points_possible, nothing inbetween. If a posted_grade in the \\\&quot;points\\\&quot; or \\\&quot;percentage\\\&quot; format is sent, the grade will only be accepted if the grade equals one of those two values.
     * @param submissionExcuse Sets the \\\&quot;excused\\\&quot; status of an assignment.
     * @param submissionLatePolicyStatus Sets the late policy status to either \\\&quot;late\\\&quot;, \\\&quot;missing\\\&quot;, \\\&quot;extended\\\&quot;, \\\&quot;none\\\&quot;, or null.   NB: \\\&quot;extended\\\&quot; values can only be set in the UI when the \\\&quot;UI features for \\\&#39;extended\\\&#39; Submissions\\\&quot; Account Feature is on
     * @param submissionSecondsLateOverride Sets the seconds late if late policy status is \\\&quot;late\\\&quot;
     * @param rubricAssessment Assign a rubric assessment to this assignment submission. The sub-parameters here depend on the rubric for the assignment. The general format is, for each row in the rubric:  The points awarded for this row.   rubric_assessment[criterion_id][points]  The rating id for the row.   rubric_assessment[criterion_id][rating_id]  Comments to add for this row.   rubric_assessment[criterion_id][comments]  For example, if the assignment rubric is (in JSON format):   !!!javascript   [     {       \\\&#39;id\\\&#39;: \\\&#39;crit1\\\&#39;,       \\\&#39;points\\\&#39;: 10,       \\\&#39;description\\\&#39;: \\\&#39;Criterion 1\\\&#39;,       \\\&#39;ratings\\\&#39;:       [         { \\\&#39;id\\\&#39;: \\\&#39;rat1\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Good\\\&#39;, \\\&#39;points\\\&#39;: 10 },         { \\\&#39;id\\\&#39;: \\\&#39;rat2\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Poor\\\&#39;, \\\&#39;points\\\&#39;: 3 }       ]     },     {       \\\&#39;id\\\&#39;: \\\&#39;crit2\\\&#39;,       \\\&#39;points\\\&#39;: 5,       \\\&#39;description\\\&#39;: \\\&#39;Criterion 2\\\&#39;,       \\\&#39;ratings\\\&#39;:       [         { \\\&#39;id\\\&#39;: \\\&#39;rat1\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Exemplary\\\&#39;, \\\&#39;points\\\&#39;: 5 },         { \\\&#39;id\\\&#39;: \\\&#39;rat2\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Complete\\\&#39;, \\\&#39;points\\\&#39;: 5 },         { \\\&#39;id\\\&#39;: \\\&#39;rat3\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Incomplete\\\&#39;, \\\&#39;points\\\&#39;: 0 }       ]     }   ]  Then a possible set of values for rubric_assessment would be:     rubric_assessment[crit1][points]&#x3D;3&amp;rubric_assessment[crit1][rating_id]&#x3D;rat1&amp;rubric_assessment[crit2][points]&#x3D;5&amp;rubric_assessment[crit2][rating_id]&#x3D;rat2&amp;rubric_assessment[crit2][comments]&#x3D;Well%20Done.
     */
    public async gradeOrCommentOnSubmissionByAnonymousIdCourses (courseId: string, assignmentId: string, anonymousId: string, commentTextComment?: string, commentGroupComment?: boolean, commentMediaCommentId?: string, commentMediaCommentType?: string, commentFileIds?: Array<number>, includeVisibility?: string, submissionPostedGrade?: string, submissionExcuse?: boolean, submissionLatePolicyStatus?: string, submissionSecondsLateOverride?: number, rubricAssessment?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/anonymous_submissions/{anonymous_id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'anonymous_id' + '}', encodeURIComponent(String(anonymousId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling gradeOrCommentOnSubmissionByAnonymousIdCourses.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling gradeOrCommentOnSubmissionByAnonymousIdCourses.');
        }

        // verify required parameter 'anonymousId' is not null or undefined
        if (anonymousId === null || anonymousId === undefined) {
            throw new Error('Required parameter anonymousId was null or undefined when calling gradeOrCommentOnSubmissionByAnonymousIdCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (commentTextComment !== undefined) {
            localVarFormParams['comment[text_comment]'] = ObjectSerializer.serialize(commentTextComment, "string");
        }

        if (commentGroupComment !== undefined) {
            localVarFormParams['comment[group_comment]'] = ObjectSerializer.serialize(commentGroupComment, "boolean");
        }

        if (commentMediaCommentId !== undefined) {
            localVarFormParams['comment[media_comment_id]'] = ObjectSerializer.serialize(commentMediaCommentId, "string");
        }

        if (commentMediaCommentType !== undefined) {
            localVarFormParams['comment[media_comment_type]'] = ObjectSerializer.serialize(commentMediaCommentType, "string");
        }

        if (commentFileIds !== undefined) {
            localVarFormParams['comment[file_ids]'] = ObjectSerializer.serialize(commentFileIds, "Array<number>");
        }

        if (includeVisibility !== undefined) {
            localVarFormParams['include[visibility]'] = ObjectSerializer.serialize(includeVisibility, "string");
        }

        if (submissionPostedGrade !== undefined) {
            localVarFormParams['submission[posted_grade]'] = ObjectSerializer.serialize(submissionPostedGrade, "string");
        }

        if (submissionExcuse !== undefined) {
            localVarFormParams['submission[excuse]'] = ObjectSerializer.serialize(submissionExcuse, "boolean");
        }

        if (submissionLatePolicyStatus !== undefined) {
            localVarFormParams['submission[late_policy_status]'] = ObjectSerializer.serialize(submissionLatePolicyStatus, "string");
        }

        if (submissionSecondsLateOverride !== undefined) {
            localVarFormParams['submission[seconds_late_override]'] = ObjectSerializer.serialize(submissionSecondsLateOverride, "number");
        }

        if (rubricAssessment !== undefined) {
            localVarFormParams['rubric_assessment'] = ObjectSerializer.serialize(rubricAssessment, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Comment on and/or update the grading for a student\'s assignment submission, fetching the submission by anonymous id (instead of user id). If any submission or rubric_assessment arguments are provided, the user must have permission to manage grades in the appropriate context (course or section).
     * @summary Grade or comment on a submission by anonymous id
     * @param sectionId ID
     * @param assignmentId ID
     * @param anonymousId ID
     * @param commentTextComment Add a textual comment to the submission.
     * @param commentGroupComment Whether or not this comment should be sent to the entire group (defaults to false). Ignored if this is not a group assignment or if no text_comment is provided.
     * @param commentMediaCommentId Add an audio/video comment to the submission. Media comments can be added via this API, however, note that there is not yet an API to generate or list existing media comments, so this functionality is currently of limited use.
     * @param commentMediaCommentType The type of media comment being added.
     * @param commentFileIds Attach files to this comment that were previously uploaded using the Submission Comment API\\\&#39;s files action
     * @param includeVisibility Whether this assignment is visible to the owner of the submission
     * @param submissionPostedGrade Assign a score to the submission, updating both the \\\&quot;score\\\&quot; and \\\&quot;grade\\\&quot; fields on the submission record. This parameter can be passed in a few different formats:  points:: A floating point or integral value, such as \\\&quot;13.5\\\&quot;. The grade   will be interpreted directly as the score of the assignment.   Values above assignment.points_possible are allowed, for awarding   extra credit. percentage:: A floating point value appended with a percent sign, such as    \\\&quot;40%\\\&quot;. The grade will be interpreted as a percentage score on the    assignment, where 100% &#x3D;&#x3D; assignment.points_possible. Values above 100%    are allowed, for awarding extra credit. letter grade:: A letter grade, following the assignment\\\&#39;s defined letter    grading scheme. For example, \\\&quot;A-\\\&quot;. The resulting score will be the high    end of the defined range for the letter grade. For instance, if \\\&quot;B\\\&quot; is    defined as 86% to 84%, a letter grade of \\\&quot;B\\\&quot; will be worth 86%. The    letter grade will be rejected if the assignment does not have a defined    letter grading scheme. For more fine-grained control of scores, pass in    points or percentage rather than the letter grade. \\\&quot;pass/complete/fail/incomplete\\\&quot;:: A string value of \\\&quot;pass\\\&quot; or \\\&quot;complete\\\&quot;    will give a score of 100%. \\\&quot;fail\\\&quot; or \\\&quot;incomplete\\\&quot; will give a score of    0.  Note that assignments with grading_type of \\\&quot;pass_fail\\\&quot; can only be assigned a score of 0 or assignment.points_possible, nothing inbetween. If a posted_grade in the \\\&quot;points\\\&quot; or \\\&quot;percentage\\\&quot; format is sent, the grade will only be accepted if the grade equals one of those two values.
     * @param submissionExcuse Sets the \\\&quot;excused\\\&quot; status of an assignment.
     * @param submissionLatePolicyStatus Sets the late policy status to either \\\&quot;late\\\&quot;, \\\&quot;missing\\\&quot;, \\\&quot;extended\\\&quot;, \\\&quot;none\\\&quot;, or null.   NB: \\\&quot;extended\\\&quot; values can only be set in the UI when the \\\&quot;UI features for \\\&#39;extended\\\&#39; Submissions\\\&quot; Account Feature is on
     * @param submissionSecondsLateOverride Sets the seconds late if late policy status is \\\&quot;late\\\&quot;
     * @param rubricAssessment Assign a rubric assessment to this assignment submission. The sub-parameters here depend on the rubric for the assignment. The general format is, for each row in the rubric:  The points awarded for this row.   rubric_assessment[criterion_id][points]  The rating id for the row.   rubric_assessment[criterion_id][rating_id]  Comments to add for this row.   rubric_assessment[criterion_id][comments]  For example, if the assignment rubric is (in JSON format):   !!!javascript   [     {       \\\&#39;id\\\&#39;: \\\&#39;crit1\\\&#39;,       \\\&#39;points\\\&#39;: 10,       \\\&#39;description\\\&#39;: \\\&#39;Criterion 1\\\&#39;,       \\\&#39;ratings\\\&#39;:       [         { \\\&#39;id\\\&#39;: \\\&#39;rat1\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Good\\\&#39;, \\\&#39;points\\\&#39;: 10 },         { \\\&#39;id\\\&#39;: \\\&#39;rat2\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Poor\\\&#39;, \\\&#39;points\\\&#39;: 3 }       ]     },     {       \\\&#39;id\\\&#39;: \\\&#39;crit2\\\&#39;,       \\\&#39;points\\\&#39;: 5,       \\\&#39;description\\\&#39;: \\\&#39;Criterion 2\\\&#39;,       \\\&#39;ratings\\\&#39;:       [         { \\\&#39;id\\\&#39;: \\\&#39;rat1\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Exemplary\\\&#39;, \\\&#39;points\\\&#39;: 5 },         { \\\&#39;id\\\&#39;: \\\&#39;rat2\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Complete\\\&#39;, \\\&#39;points\\\&#39;: 5 },         { \\\&#39;id\\\&#39;: \\\&#39;rat3\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Incomplete\\\&#39;, \\\&#39;points\\\&#39;: 0 }       ]     }   ]  Then a possible set of values for rubric_assessment would be:     rubric_assessment[crit1][points]&#x3D;3&amp;rubric_assessment[crit1][rating_id]&#x3D;rat1&amp;rubric_assessment[crit2][points]&#x3D;5&amp;rubric_assessment[crit2][rating_id]&#x3D;rat2&amp;rubric_assessment[crit2][comments]&#x3D;Well%20Done.
     */
    public async gradeOrCommentOnSubmissionByAnonymousIdSections (sectionId: string, assignmentId: string, anonymousId: string, commentTextComment?: string, commentGroupComment?: boolean, commentMediaCommentId?: string, commentMediaCommentType?: string, commentFileIds?: Array<number>, includeVisibility?: string, submissionPostedGrade?: string, submissionExcuse?: boolean, submissionLatePolicyStatus?: string, submissionSecondsLateOverride?: number, rubricAssessment?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/anonymous_submissions/{anonymous_id}'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'anonymous_id' + '}', encodeURIComponent(String(anonymousId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling gradeOrCommentOnSubmissionByAnonymousIdSections.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling gradeOrCommentOnSubmissionByAnonymousIdSections.');
        }

        // verify required parameter 'anonymousId' is not null or undefined
        if (anonymousId === null || anonymousId === undefined) {
            throw new Error('Required parameter anonymousId was null or undefined when calling gradeOrCommentOnSubmissionByAnonymousIdSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (commentTextComment !== undefined) {
            localVarFormParams['comment[text_comment]'] = ObjectSerializer.serialize(commentTextComment, "string");
        }

        if (commentGroupComment !== undefined) {
            localVarFormParams['comment[group_comment]'] = ObjectSerializer.serialize(commentGroupComment, "boolean");
        }

        if (commentMediaCommentId !== undefined) {
            localVarFormParams['comment[media_comment_id]'] = ObjectSerializer.serialize(commentMediaCommentId, "string");
        }

        if (commentMediaCommentType !== undefined) {
            localVarFormParams['comment[media_comment_type]'] = ObjectSerializer.serialize(commentMediaCommentType, "string");
        }

        if (commentFileIds !== undefined) {
            localVarFormParams['comment[file_ids]'] = ObjectSerializer.serialize(commentFileIds, "Array<number>");
        }

        if (includeVisibility !== undefined) {
            localVarFormParams['include[visibility]'] = ObjectSerializer.serialize(includeVisibility, "string");
        }

        if (submissionPostedGrade !== undefined) {
            localVarFormParams['submission[posted_grade]'] = ObjectSerializer.serialize(submissionPostedGrade, "string");
        }

        if (submissionExcuse !== undefined) {
            localVarFormParams['submission[excuse]'] = ObjectSerializer.serialize(submissionExcuse, "boolean");
        }

        if (submissionLatePolicyStatus !== undefined) {
            localVarFormParams['submission[late_policy_status]'] = ObjectSerializer.serialize(submissionLatePolicyStatus, "string");
        }

        if (submissionSecondsLateOverride !== undefined) {
            localVarFormParams['submission[seconds_late_override]'] = ObjectSerializer.serialize(submissionSecondsLateOverride, "number");
        }

        if (rubricAssessment !== undefined) {
            localVarFormParams['rubric_assessment'] = ObjectSerializer.serialize(rubricAssessment, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Comment on and/or update the grading for a student\'s assignment submission. If any submission or rubric_assessment arguments are provided, the user must have permission to manage grades in the appropriate context (course or section).
     * @summary Grade or comment on a submission
     * @param courseId ID
     * @param assignmentId ID
     * @param userId ID
     * @param commentTextComment Add a textual comment to the submission.
     * @param commentAttempt The attempt number (starts at 1) to associate the comment with.
     * @param commentGroupComment Whether or not this comment should be sent to the entire group (defaults to false). Ignored if this is not a group assignment or if no text_comment is provided.
     * @param commentMediaCommentId Add an audio/video comment to the submission. Media comments can be added via this API, however, note that there is not yet an API to generate or list existing media comments, so this functionality is currently of limited use.
     * @param commentMediaCommentType The type of media comment being added.
     * @param commentFileIds Attach files to this comment that were previously uploaded using the Submission Comment API\\\&#39;s files action
     * @param includeVisibility Whether this assignment is visible to the owner of the submission
     * @param preferPointsOverScheme Treat posted_grade as points if the value matches a grading scheme value
     * @param submissionPostedGrade Assign a score to the submission, updating both the \\\&quot;score\\\&quot; and \\\&quot;grade\\\&quot; fields on the submission record. This parameter can be passed in a few different formats:  points:: A floating point or integral value, such as \\\&quot;13.5\\\&quot;. The grade   will be interpreted directly as the score of the assignment.   Values above assignment.points_possible are allowed, for awarding   extra credit. percentage:: A floating point value appended with a percent sign, such as    \\\&quot;40%\\\&quot;. The grade will be interpreted as a percentage score on the    assignment, where 100% &#x3D;&#x3D; assignment.points_possible. Values above 100%    are allowed, for awarding extra credit. letter grade:: A letter grade, following the assignment\\\&#39;s defined letter    grading scheme. For example, \\\&quot;A-\\\&quot;. The resulting score will be the high    end of the defined range for the letter grade. For instance, if \\\&quot;B\\\&quot; is    defined as 86% to 84%, a letter grade of \\\&quot;B\\\&quot; will be worth 86%. The    letter grade will be rejected if the assignment does not have a defined    letter grading scheme. For more fine-grained control of scores, pass in    points or percentage rather than the letter grade. \\\&quot;pass/complete/fail/incomplete\\\&quot;:: A string value of \\\&quot;pass\\\&quot; or \\\&quot;complete\\\&quot;    will give a score of 100%. \\\&quot;fail\\\&quot; or \\\&quot;incomplete\\\&quot; will give a score of    0.  Note that assignments with grading_type of \\\&quot;pass_fail\\\&quot; can only be assigned a score of 0 or assignment.points_possible, nothing inbetween. If a posted_grade in the \\\&quot;points\\\&quot; or \\\&quot;percentage\\\&quot; format is sent, the grade will only be accepted if the grade equals one of those two values.
     * @param submissionExcuse Sets the \\\&quot;excused\\\&quot; status of an assignment.
     * @param submissionLatePolicyStatus Sets the late policy status to either \\\&quot;late\\\&quot;, \\\&quot;missing\\\&quot;, \\\&quot;extended\\\&quot;, \\\&quot;none\\\&quot;, or null.   NB: \\\&quot;extended\\\&quot; values can only be set in the UI when the \\\&quot;UI features for \\\&#39;extended\\\&#39; Submissions\\\&quot; Account Feature is on
     * @param submissionSticker Sets the sticker for the submission.
     * @param submissionSecondsLateOverride Sets the seconds late if late policy status is \\\&quot;late\\\&quot;
     * @param rubricAssessment Assign a rubric assessment to this assignment submission. The sub-parameters here depend on the rubric for the assignment. The general format is, for each row in the rubric:  The points awarded for this row.   rubric_assessment[criterion_id][points]  The rating id for the row.   rubric_assessment[criterion_id][rating_id]  Comments to add for this row.   rubric_assessment[criterion_id][comments]  For example, if the assignment rubric is (in JSON format):   !!!javascript   [     {       \\\&#39;id\\\&#39;: \\\&#39;crit1\\\&#39;,       \\\&#39;points\\\&#39;: 10,       \\\&#39;description\\\&#39;: \\\&#39;Criterion 1\\\&#39;,       \\\&#39;ratings\\\&#39;:       [         { \\\&#39;id\\\&#39;: \\\&#39;rat1\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Good\\\&#39;, \\\&#39;points\\\&#39;: 10 },         { \\\&#39;id\\\&#39;: \\\&#39;rat2\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Poor\\\&#39;, \\\&#39;points\\\&#39;: 3 }       ]     },     {       \\\&#39;id\\\&#39;: \\\&#39;crit2\\\&#39;,       \\\&#39;points\\\&#39;: 5,       \\\&#39;description\\\&#39;: \\\&#39;Criterion 2\\\&#39;,       \\\&#39;ratings\\\&#39;:       [         { \\\&#39;id\\\&#39;: \\\&#39;rat1\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Exemplary\\\&#39;, \\\&#39;points\\\&#39;: 5 },         { \\\&#39;id\\\&#39;: \\\&#39;rat2\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Complete\\\&#39;, \\\&#39;points\\\&#39;: 5 },         { \\\&#39;id\\\&#39;: \\\&#39;rat3\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Incomplete\\\&#39;, \\\&#39;points\\\&#39;: 0 }       ]     }   ]  Then a possible set of values for rubric_assessment would be:     rubric_assessment[crit1][points]&#x3D;3&amp;rubric_assessment[crit1][rating_id]&#x3D;rat1&amp;rubric_assessment[crit2][points]&#x3D;5&amp;rubric_assessment[crit2][rating_id]&#x3D;rat2&amp;rubric_assessment[crit2][comments]&#x3D;Well%20Done.
     */
    public async gradeOrCommentOnSubmissionCourses (courseId: string, assignmentId: string, userId: string, commentTextComment?: string, commentAttempt?: number, commentGroupComment?: boolean, commentMediaCommentId?: string, commentMediaCommentType?: string, commentFileIds?: Array<number>, includeVisibility?: string, preferPointsOverScheme?: boolean, submissionPostedGrade?: string, submissionExcuse?: boolean, submissionLatePolicyStatus?: string, submissionSticker?: string, submissionSecondsLateOverride?: number, rubricAssessment?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling gradeOrCommentOnSubmissionCourses.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling gradeOrCommentOnSubmissionCourses.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling gradeOrCommentOnSubmissionCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (commentTextComment !== undefined) {
            localVarFormParams['comment[text_comment]'] = ObjectSerializer.serialize(commentTextComment, "string");
        }

        if (commentAttempt !== undefined) {
            localVarFormParams['comment[attempt]'] = ObjectSerializer.serialize(commentAttempt, "number");
        }

        if (commentGroupComment !== undefined) {
            localVarFormParams['comment[group_comment]'] = ObjectSerializer.serialize(commentGroupComment, "boolean");
        }

        if (commentMediaCommentId !== undefined) {
            localVarFormParams['comment[media_comment_id]'] = ObjectSerializer.serialize(commentMediaCommentId, "string");
        }

        if (commentMediaCommentType !== undefined) {
            localVarFormParams['comment[media_comment_type]'] = ObjectSerializer.serialize(commentMediaCommentType, "string");
        }

        if (commentFileIds !== undefined) {
            localVarFormParams['comment[file_ids]'] = ObjectSerializer.serialize(commentFileIds, "Array<number>");
        }

        if (includeVisibility !== undefined) {
            localVarFormParams['include[visibility]'] = ObjectSerializer.serialize(includeVisibility, "string");
        }

        if (preferPointsOverScheme !== undefined) {
            localVarFormParams['prefer_points_over_scheme'] = ObjectSerializer.serialize(preferPointsOverScheme, "boolean");
        }

        if (submissionPostedGrade !== undefined) {
            localVarFormParams['submission[posted_grade]'] = ObjectSerializer.serialize(submissionPostedGrade, "string");
        }

        if (submissionExcuse !== undefined) {
            localVarFormParams['submission[excuse]'] = ObjectSerializer.serialize(submissionExcuse, "boolean");
        }

        if (submissionLatePolicyStatus !== undefined) {
            localVarFormParams['submission[late_policy_status]'] = ObjectSerializer.serialize(submissionLatePolicyStatus, "string");
        }

        if (submissionSticker !== undefined) {
            localVarFormParams['submission[sticker]'] = ObjectSerializer.serialize(submissionSticker, "string");
        }

        if (submissionSecondsLateOverride !== undefined) {
            localVarFormParams['submission[seconds_late_override]'] = ObjectSerializer.serialize(submissionSecondsLateOverride, "number");
        }

        if (rubricAssessment !== undefined) {
            localVarFormParams['rubric_assessment'] = ObjectSerializer.serialize(rubricAssessment, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Comment on and/or update the grading for a student\'s assignment submission. If any submission or rubric_assessment arguments are provided, the user must have permission to manage grades in the appropriate context (course or section).
     * @summary Grade or comment on a submission
     * @param sectionId ID
     * @param assignmentId ID
     * @param userId ID
     * @param commentTextComment Add a textual comment to the submission.
     * @param commentAttempt The attempt number (starts at 1) to associate the comment with.
     * @param commentGroupComment Whether or not this comment should be sent to the entire group (defaults to false). Ignored if this is not a group assignment or if no text_comment is provided.
     * @param commentMediaCommentId Add an audio/video comment to the submission. Media comments can be added via this API, however, note that there is not yet an API to generate or list existing media comments, so this functionality is currently of limited use.
     * @param commentMediaCommentType The type of media comment being added.
     * @param commentFileIds Attach files to this comment that were previously uploaded using the Submission Comment API\\\&#39;s files action
     * @param includeVisibility Whether this assignment is visible to the owner of the submission
     * @param preferPointsOverScheme Treat posted_grade as points if the value matches a grading scheme value
     * @param submissionPostedGrade Assign a score to the submission, updating both the \\\&quot;score\\\&quot; and \\\&quot;grade\\\&quot; fields on the submission record. This parameter can be passed in a few different formats:  points:: A floating point or integral value, such as \\\&quot;13.5\\\&quot;. The grade   will be interpreted directly as the score of the assignment.   Values above assignment.points_possible are allowed, for awarding   extra credit. percentage:: A floating point value appended with a percent sign, such as    \\\&quot;40%\\\&quot;. The grade will be interpreted as a percentage score on the    assignment, where 100% &#x3D;&#x3D; assignment.points_possible. Values above 100%    are allowed, for awarding extra credit. letter grade:: A letter grade, following the assignment\\\&#39;s defined letter    grading scheme. For example, \\\&quot;A-\\\&quot;. The resulting score will be the high    end of the defined range for the letter grade. For instance, if \\\&quot;B\\\&quot; is    defined as 86% to 84%, a letter grade of \\\&quot;B\\\&quot; will be worth 86%. The    letter grade will be rejected if the assignment does not have a defined    letter grading scheme. For more fine-grained control of scores, pass in    points or percentage rather than the letter grade. \\\&quot;pass/complete/fail/incomplete\\\&quot;:: A string value of \\\&quot;pass\\\&quot; or \\\&quot;complete\\\&quot;    will give a score of 100%. \\\&quot;fail\\\&quot; or \\\&quot;incomplete\\\&quot; will give a score of    0.  Note that assignments with grading_type of \\\&quot;pass_fail\\\&quot; can only be assigned a score of 0 or assignment.points_possible, nothing inbetween. If a posted_grade in the \\\&quot;points\\\&quot; or \\\&quot;percentage\\\&quot; format is sent, the grade will only be accepted if the grade equals one of those two values.
     * @param submissionExcuse Sets the \\\&quot;excused\\\&quot; status of an assignment.
     * @param submissionLatePolicyStatus Sets the late policy status to either \\\&quot;late\\\&quot;, \\\&quot;missing\\\&quot;, \\\&quot;extended\\\&quot;, \\\&quot;none\\\&quot;, or null.   NB: \\\&quot;extended\\\&quot; values can only be set in the UI when the \\\&quot;UI features for \\\&#39;extended\\\&#39; Submissions\\\&quot; Account Feature is on
     * @param submissionSticker Sets the sticker for the submission.
     * @param submissionSecondsLateOverride Sets the seconds late if late policy status is \\\&quot;late\\\&quot;
     * @param rubricAssessment Assign a rubric assessment to this assignment submission. The sub-parameters here depend on the rubric for the assignment. The general format is, for each row in the rubric:  The points awarded for this row.   rubric_assessment[criterion_id][points]  The rating id for the row.   rubric_assessment[criterion_id][rating_id]  Comments to add for this row.   rubric_assessment[criterion_id][comments]  For example, if the assignment rubric is (in JSON format):   !!!javascript   [     {       \\\&#39;id\\\&#39;: \\\&#39;crit1\\\&#39;,       \\\&#39;points\\\&#39;: 10,       \\\&#39;description\\\&#39;: \\\&#39;Criterion 1\\\&#39;,       \\\&#39;ratings\\\&#39;:       [         { \\\&#39;id\\\&#39;: \\\&#39;rat1\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Good\\\&#39;, \\\&#39;points\\\&#39;: 10 },         { \\\&#39;id\\\&#39;: \\\&#39;rat2\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Poor\\\&#39;, \\\&#39;points\\\&#39;: 3 }       ]     },     {       \\\&#39;id\\\&#39;: \\\&#39;crit2\\\&#39;,       \\\&#39;points\\\&#39;: 5,       \\\&#39;description\\\&#39;: \\\&#39;Criterion 2\\\&#39;,       \\\&#39;ratings\\\&#39;:       [         { \\\&#39;id\\\&#39;: \\\&#39;rat1\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Exemplary\\\&#39;, \\\&#39;points\\\&#39;: 5 },         { \\\&#39;id\\\&#39;: \\\&#39;rat2\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Complete\\\&#39;, \\\&#39;points\\\&#39;: 5 },         { \\\&#39;id\\\&#39;: \\\&#39;rat3\\\&#39;, \\\&#39;description\\\&#39;: \\\&#39;Incomplete\\\&#39;, \\\&#39;points\\\&#39;: 0 }       ]     }   ]  Then a possible set of values for rubric_assessment would be:     rubric_assessment[crit1][points]&#x3D;3&amp;rubric_assessment[crit1][rating_id]&#x3D;rat1&amp;rubric_assessment[crit2][points]&#x3D;5&amp;rubric_assessment[crit2][rating_id]&#x3D;rat2&amp;rubric_assessment[crit2][comments]&#x3D;Well%20Done.
     */
    public async gradeOrCommentOnSubmissionSections (sectionId: string, assignmentId: string, userId: string, commentTextComment?: string, commentAttempt?: number, commentGroupComment?: boolean, commentMediaCommentId?: string, commentMediaCommentType?: string, commentFileIds?: Array<number>, includeVisibility?: string, preferPointsOverScheme?: boolean, submissionPostedGrade?: string, submissionExcuse?: boolean, submissionLatePolicyStatus?: string, submissionSticker?: string, submissionSecondsLateOverride?: number, rubricAssessment?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling gradeOrCommentOnSubmissionSections.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling gradeOrCommentOnSubmissionSections.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling gradeOrCommentOnSubmissionSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (commentTextComment !== undefined) {
            localVarFormParams['comment[text_comment]'] = ObjectSerializer.serialize(commentTextComment, "string");
        }

        if (commentAttempt !== undefined) {
            localVarFormParams['comment[attempt]'] = ObjectSerializer.serialize(commentAttempt, "number");
        }

        if (commentGroupComment !== undefined) {
            localVarFormParams['comment[group_comment]'] = ObjectSerializer.serialize(commentGroupComment, "boolean");
        }

        if (commentMediaCommentId !== undefined) {
            localVarFormParams['comment[media_comment_id]'] = ObjectSerializer.serialize(commentMediaCommentId, "string");
        }

        if (commentMediaCommentType !== undefined) {
            localVarFormParams['comment[media_comment_type]'] = ObjectSerializer.serialize(commentMediaCommentType, "string");
        }

        if (commentFileIds !== undefined) {
            localVarFormParams['comment[file_ids]'] = ObjectSerializer.serialize(commentFileIds, "Array<number>");
        }

        if (includeVisibility !== undefined) {
            localVarFormParams['include[visibility]'] = ObjectSerializer.serialize(includeVisibility, "string");
        }

        if (preferPointsOverScheme !== undefined) {
            localVarFormParams['prefer_points_over_scheme'] = ObjectSerializer.serialize(preferPointsOverScheme, "boolean");
        }

        if (submissionPostedGrade !== undefined) {
            localVarFormParams['submission[posted_grade]'] = ObjectSerializer.serialize(submissionPostedGrade, "string");
        }

        if (submissionExcuse !== undefined) {
            localVarFormParams['submission[excuse]'] = ObjectSerializer.serialize(submissionExcuse, "boolean");
        }

        if (submissionLatePolicyStatus !== undefined) {
            localVarFormParams['submission[late_policy_status]'] = ObjectSerializer.serialize(submissionLatePolicyStatus, "string");
        }

        if (submissionSticker !== undefined) {
            localVarFormParams['submission[sticker]'] = ObjectSerializer.serialize(submissionSticker, "string");
        }

        if (submissionSecondsLateOverride !== undefined) {
            localVarFormParams['submission[seconds_late_override]'] = ObjectSerializer.serialize(submissionSecondsLateOverride, "number");
        }

        if (rubricAssessment !== undefined) {
            localVarFormParams['rubric_assessment'] = ObjectSerializer.serialize(rubricAssessment, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of all existing submissions for an assignment.
     * @summary List assignment submissions
     * @param courseId ID
     * @param assignmentId ID
     * @param include Associations to include with the group.  \&quot;group\&quot; will add group_id and group_name.
     * @param grouped If this argument is true, the response will be grouped by student groups.
     */
    public async listAssignmentSubmissionsCourses (courseId: string, assignmentId: string, include?: Array<string>, grouped?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Submission>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listAssignmentSubmissionsCourses.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling listAssignmentSubmissionsCourses.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (grouped !== undefined) {
            localVarQueryParameters['grouped'] = ObjectSerializer.serialize(grouped, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Submission>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Submission>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of all existing submissions for an assignment.
     * @summary List assignment submissions
     * @param sectionId ID
     * @param assignmentId ID
     * @param include Associations to include with the group.  \&quot;group\&quot; will add group_id and group_name.
     * @param grouped If this argument is true, the response will be grouped by student groups.
     */
    public async listAssignmentSubmissionsSections (sectionId: string, assignmentId: string, include?: Array<string>, grouped?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Submission>;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling listAssignmentSubmissionsSections.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling listAssignmentSubmissionsSections.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (grouped !== undefined) {
            localVarQueryParameters['grouped'] = ObjectSerializer.serialize(grouped, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Submission>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Submission>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of students eligible to submit the assignment. The caller must have permission to view grades.  If anonymous grading is enabled for the current assignment and the allow_new_anonymous_id parameter is passed, the returned data will not include any values identifying the student, but will instead include an assignment-specific anonymous ID for each student.  Section-limited instructors will only see students in their own sections.
     * @summary List gradeable students
     * @param courseId ID
     * @param assignmentId ID
     */
    public async listGradeableStudents (courseId: string, assignmentId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<UserDisplay if anonymous grading is not enabled for the assignment or if the allowNewAnonymousId parameter is not true>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/gradeable_students'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listGradeableStudents.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling listGradeableStudents.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<UserDisplay if anonymous grading is not enabled for the assignment or if the allowNewAnonymousId parameter is not true>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<UserDisplay if anonymous grading is not enabled for the assignment or if the allowNewAnonymousId parameter is not true>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of students eligible to submit a list of assignments. The caller must have permission to view grades for the requested course.  Section-limited instructors will only see students in their own sections.
     * @summary List multiple assignments gradeable students
     * @param courseId ID
     * @param assignmentIds Assignments being requested
     */
    public async listMultipleAssignmentsGradeableStudents (courseId: string, assignmentIds?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/gradeable_students'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listMultipleAssignmentsGradeableStudents.');
        }

        if (assignmentIds !== undefined) {
            localVarQueryParameters['assignment_ids'] = ObjectSerializer.serialize(assignmentIds, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of all existing submissions for a given set of students and assignments.
     * @summary List submissions for multiple assignments
     * @param courseId ID
     * @param studentIds List of student ids to return submissions for. If this argument is omitted, return submissions for the calling user. Students may only list their own submissions. Observers may only list those of associated students. The special id \&quot;all\&quot; will return submissions for all students in the course/section as appropriate.
     * @param assignmentIds List of assignments to return submissions for. If none are given, submissions for all assignments are returned.
     * @param grouped If this argument is present, the response will be grouped by student, rather than a flat array of submissions.
     * @param postToSis If this argument is set to true, the response will only include submissions for assignments that have the post_to_sis flag set to true and user enrollments that were added through sis.
     * @param submittedSince If this argument is set, the response will only include submissions that were submitted after the specified date_time. This will exclude submissions that do not have a submitted_at which will exclude unsubmitted submissions. The value must be formatted as ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
     * @param gradedSince If this argument is set, the response will only include submissions that were graded after the specified date_time. This will exclude submissions that have not been graded. The value must be formatted as ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
     * @param gradingPeriodId The id of the grading period in which submissions are being requested (Requires grading periods to exist on the account)
     * @param workflowState The current status of the submission
     * @param enrollmentState The current state of the enrollments. If omitted will include all enrollments that are not deleted.
     * @param stateBasedOnDate If omitted it is set to true. When set to false it will ignore the effective state of the student enrollments and use the workflow_state for the enrollments. The argument is ignored unless enrollment_state argument is also passed.
     * @param order The order submissions will be returned in.  Defaults to \&quot;id\&quot;.  Doesn\&#39;t affect results for \&quot;grouped\&quot; mode.
     * @param orderDirection Determines whether ordered results are returned in ascending or descending order.  Defaults to \&quot;ascending\&quot;.  Doesn\&#39;t affect results for \&quot;grouped\&quot; mode.
     * @param include Associations to include with the group. &#x60;total_scores&#x60; requires the &#x60;grouped&#x60; argument.
     */
    public async listSubmissionsForMultipleAssignmentsCourses (courseId: string, studentIds?: Array<string>, assignmentIds?: Array<string>, grouped?: boolean, postToSis?: boolean, submittedSince?: Date, gradedSince?: Date, gradingPeriodId?: number, workflowState?: 'submitted' | 'unsubmitted' | 'graded' | 'pending_review', enrollmentState?: 'active' | 'concluded', stateBasedOnDate?: boolean, order?: 'id' | 'graded_at', orderDirection?: 'ascending' | 'descending', include?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/students/submissions'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listSubmissionsForMultipleAssignmentsCourses.');
        }

        if (studentIds !== undefined) {
            localVarQueryParameters['student_ids'] = ObjectSerializer.serialize(studentIds, "Array<string>");
        }

        if (assignmentIds !== undefined) {
            localVarQueryParameters['assignment_ids'] = ObjectSerializer.serialize(assignmentIds, "Array<string>");
        }

        if (grouped !== undefined) {
            localVarQueryParameters['grouped'] = ObjectSerializer.serialize(grouped, "boolean");
        }

        if (postToSis !== undefined) {
            localVarQueryParameters['post_to_sis'] = ObjectSerializer.serialize(postToSis, "boolean");
        }

        if (submittedSince !== undefined) {
            localVarQueryParameters['submitted_since'] = ObjectSerializer.serialize(submittedSince, "Date");
        }

        if (gradedSince !== undefined) {
            localVarQueryParameters['graded_since'] = ObjectSerializer.serialize(gradedSince, "Date");
        }

        if (gradingPeriodId !== undefined) {
            localVarQueryParameters['grading_period_id'] = ObjectSerializer.serialize(gradingPeriodId, "number");
        }

        if (workflowState !== undefined) {
            localVarQueryParameters['workflow_state'] = ObjectSerializer.serialize(workflowState, "'submitted' | 'unsubmitted' | 'graded' | 'pending_review'");
        }

        if (enrollmentState !== undefined) {
            localVarQueryParameters['enrollment_state'] = ObjectSerializer.serialize(enrollmentState, "'active' | 'concluded'");
        }

        if (stateBasedOnDate !== undefined) {
            localVarQueryParameters['state_based_on_date'] = ObjectSerializer.serialize(stateBasedOnDate, "boolean");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "'id' | 'graded_at'");
        }

        if (orderDirection !== undefined) {
            localVarQueryParameters['order_direction'] = ObjectSerializer.serialize(orderDirection, "'ascending' | 'descending'");
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of all existing submissions for a given set of students and assignments.
     * @summary List submissions for multiple assignments
     * @param sectionId ID
     * @param studentIds List of student ids to return submissions for. If this argument is omitted, return submissions for the calling user. Students may only list their own submissions. Observers may only list those of associated students. The special id \&quot;all\&quot; will return submissions for all students in the course/section as appropriate.
     * @param assignmentIds List of assignments to return submissions for. If none are given, submissions for all assignments are returned.
     * @param grouped If this argument is present, the response will be grouped by student, rather than a flat array of submissions.
     * @param postToSis If this argument is set to true, the response will only include submissions for assignments that have the post_to_sis flag set to true and user enrollments that were added through sis.
     * @param submittedSince If this argument is set, the response will only include submissions that were submitted after the specified date_time. This will exclude submissions that do not have a submitted_at which will exclude unsubmitted submissions. The value must be formatted as ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
     * @param gradedSince If this argument is set, the response will only include submissions that were graded after the specified date_time. This will exclude submissions that have not been graded. The value must be formatted as ISO 8601 YYYY-MM-DDTHH:MM:SSZ.
     * @param gradingPeriodId The id of the grading period in which submissions are being requested (Requires grading periods to exist on the account)
     * @param workflowState The current status of the submission
     * @param enrollmentState The current state of the enrollments. If omitted will include all enrollments that are not deleted.
     * @param stateBasedOnDate If omitted it is set to true. When set to false it will ignore the effective state of the student enrollments and use the workflow_state for the enrollments. The argument is ignored unless enrollment_state argument is also passed.
     * @param order The order submissions will be returned in.  Defaults to \&quot;id\&quot;.  Doesn\&#39;t affect results for \&quot;grouped\&quot; mode.
     * @param orderDirection Determines whether ordered results are returned in ascending or descending order.  Defaults to \&quot;ascending\&quot;.  Doesn\&#39;t affect results for \&quot;grouped\&quot; mode.
     * @param include Associations to include with the group. &#x60;total_scores&#x60; requires the &#x60;grouped&#x60; argument.
     */
    public async listSubmissionsForMultipleAssignmentsSections (sectionId: string, studentIds?: Array<string>, assignmentIds?: Array<string>, grouped?: boolean, postToSis?: boolean, submittedSince?: Date, gradedSince?: Date, gradingPeriodId?: number, workflowState?: 'submitted' | 'unsubmitted' | 'graded' | 'pending_review', enrollmentState?: 'active' | 'concluded', stateBasedOnDate?: boolean, order?: 'id' | 'graded_at', orderDirection?: 'ascending' | 'descending', include?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/students/submissions'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling listSubmissionsForMultipleAssignmentsSections.');
        }

        if (studentIds !== undefined) {
            localVarQueryParameters['student_ids'] = ObjectSerializer.serialize(studentIds, "Array<string>");
        }

        if (assignmentIds !== undefined) {
            localVarQueryParameters['assignment_ids'] = ObjectSerializer.serialize(assignmentIds, "Array<string>");
        }

        if (grouped !== undefined) {
            localVarQueryParameters['grouped'] = ObjectSerializer.serialize(grouped, "boolean");
        }

        if (postToSis !== undefined) {
            localVarQueryParameters['post_to_sis'] = ObjectSerializer.serialize(postToSis, "boolean");
        }

        if (submittedSince !== undefined) {
            localVarQueryParameters['submitted_since'] = ObjectSerializer.serialize(submittedSince, "Date");
        }

        if (gradedSince !== undefined) {
            localVarQueryParameters['graded_since'] = ObjectSerializer.serialize(gradedSince, "Date");
        }

        if (gradingPeriodId !== undefined) {
            localVarQueryParameters['grading_period_id'] = ObjectSerializer.serialize(gradingPeriodId, "number");
        }

        if (workflowState !== undefined) {
            localVarQueryParameters['workflow_state'] = ObjectSerializer.serialize(workflowState, "'submitted' | 'unsubmitted' | 'graded' | 'pending_review'");
        }

        if (enrollmentState !== undefined) {
            localVarQueryParameters['enrollment_state'] = ObjectSerializer.serialize(enrollmentState, "'active' | 'concluded'");
        }

        if (stateBasedOnDate !== undefined) {
            localVarQueryParameters['state_based_on_date'] = ObjectSerializer.serialize(stateBasedOnDate, "boolean");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "'id' | 'graded_at'");
        }

        if (orderDirection !== undefined) {
            localVarQueryParameters['order_direction'] = ObjectSerializer.serialize(orderDirection, "'ascending' | 'descending'");
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Accepts a string array of submission ids. Loops through and marks each submission as read  On success, the response will be 204 No Content with an empty body.
     * @summary Mark bulk submissions as read
     * @param courseId ID
     * @param submissionIds no description
     */
    public async markBulkSubmissionsAsReadCourses (courseId: string, submissionIds?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/submissions/bulk_mark_read'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markBulkSubmissionsAsReadCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (submissionIds !== undefined) {
            localVarFormParams['submissionIds'] = ObjectSerializer.serialize(submissionIds, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Accepts a string array of submission ids. Loops through and marks each submission as read  On success, the response will be 204 No Content with an empty body.
     * @summary Mark bulk submissions as read
     * @param sectionId ID
     * @param submissionIds no description
     */
    public async markBulkSubmissionsAsReadSections (sectionId: string, submissionIds?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/submissions/bulk_mark_read'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling markBulkSubmissionsAsReadSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (submissionIds !== undefined) {
            localVarFormParams['submissionIds'] = ObjectSerializer.serialize(submissionIds, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Indicate that annotations made on a submitted document have been read by the student. Only the student who owns the submission can use this endpoint.  NOTE: Document annotations will be marked as read automatically when they are viewed in Canvas web.
     * @summary Mark document annotations as read
     * @param courseId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async markDocumentAnnotationsAsReadCourses (courseId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/document_annotations/read'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markDocumentAnnotationsAsReadCourses.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling markDocumentAnnotationsAsReadCourses.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling markDocumentAnnotationsAsReadCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Indicate that annotations made on a submitted document have been read by the student. Only the student who owns the submission can use this endpoint.  NOTE: Document annotations will be marked as read automatically when they are viewed in Canvas web.
     * @summary Mark document annotations as read
     * @param sectionId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async markDocumentAnnotationsAsReadSections (sectionId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/document_annotations/read'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling markDocumentAnnotationsAsReadSections.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling markDocumentAnnotationsAsReadSections.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling markDocumentAnnotationsAsReadSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Indicate that rubric comments/grading made on a submission have been read by the student being assessed. Only the student who owns the submission can use this endpoint.  NOTE: Rubric assessments will be marked as read automatically when they are viewed in Canvas web.
     * @summary Mark rubric assessments as read
     * @param courseId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async markRubricAssessmentsAsReadCoursesRubricAssessments (courseId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/rubric_assessments/read'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markRubricAssessmentsAsReadCoursesRubricAssessments.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling markRubricAssessmentsAsReadCoursesRubricAssessments.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling markRubricAssessmentsAsReadCoursesRubricAssessments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Indicate that rubric comments/grading made on a submission have been read by the student being assessed. Only the student who owns the submission can use this endpoint.  NOTE: Rubric assessments will be marked as read automatically when they are viewed in Canvas web.
     * @summary Mark rubric assessments as read
     * @param courseId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async markRubricAssessmentsAsReadCoursesRubricComments (courseId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/rubric_comments/read'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markRubricAssessmentsAsReadCoursesRubricComments.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling markRubricAssessmentsAsReadCoursesRubricComments.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling markRubricAssessmentsAsReadCoursesRubricComments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Indicate that rubric comments/grading made on a submission have been read by the student being assessed. Only the student who owns the submission can use this endpoint.  NOTE: Rubric assessments will be marked as read automatically when they are viewed in Canvas web.
     * @summary Mark rubric assessments as read
     * @param sectionId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async markRubricAssessmentsAsReadSectionsRubricAssessments (sectionId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/rubric_assessments/read'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling markRubricAssessmentsAsReadSectionsRubricAssessments.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling markRubricAssessmentsAsReadSectionsRubricAssessments.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling markRubricAssessmentsAsReadSectionsRubricAssessments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Indicate that rubric comments/grading made on a submission have been read by the student being assessed. Only the student who owns the submission can use this endpoint.  NOTE: Rubric assessments will be marked as read automatically when they are viewed in Canvas web.
     * @summary Mark rubric assessments as read
     * @param sectionId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async markRubricAssessmentsAsReadSectionsRubricComments (sectionId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/rubric_comments/read'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling markRubricAssessmentsAsReadSectionsRubricComments.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling markRubricAssessmentsAsReadSectionsRubricComments.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling markRubricAssessmentsAsReadSectionsRubricComments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark submission as read
     * @param courseId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async markSubmissionAsReadCourses (courseId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/read'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markSubmissionAsReadCourses.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling markSubmissionAsReadCourses.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling markSubmissionAsReadCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark submission as read
     * @param sectionId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async markSubmissionAsReadSections (sectionId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/read'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling markSubmissionAsReadSections.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling markSubmissionAsReadSections.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling markSubmissionAsReadSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark submission as unread
     * @param courseId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async markSubmissionAsUnreadCourses (courseId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/read'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markSubmissionAsUnreadCourses.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling markSubmissionAsUnreadCourses.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling markSubmissionAsUnreadCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark submission as unread
     * @param sectionId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async markSubmissionAsUnreadSections (sectionId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/read'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling markSubmissionAsUnreadSections.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling markSubmissionAsUnreadSections.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling markSubmissionAsUnreadSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * No request fields are necessary.  A submission item can be \"grade\", \"comment\" or \"rubric\"  On success, the response will be 204 No Content with an empty body.
     * @summary Mark submission item as read
     * @param courseId ID
     * @param assignmentId ID
     * @param userId ID
     * @param item ID
     */
    public async markSubmissionItemAsReadCourses (courseId: string, assignmentId: string, userId: string, item: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/read/{item}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)))
            .replace('{' + 'item' + '}', encodeURIComponent(String(item)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markSubmissionItemAsReadCourses.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling markSubmissionItemAsReadCourses.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling markSubmissionItemAsReadCourses.');
        }

        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling markSubmissionItemAsReadCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * No request fields are necessary.  A submission item can be \"grade\", \"comment\" or \"rubric\"  On success, the response will be 204 No Content with an empty body.
     * @summary Mark submission item as read
     * @param sectionId ID
     * @param assignmentId ID
     * @param userId ID
     * @param item ID
     */
    public async markSubmissionItemAsReadSections (sectionId: string, assignmentId: string, userId: string, item: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/read/{item}'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)))
            .replace('{' + 'item' + '}', encodeURIComponent(String(item)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling markSubmissionItemAsReadSections.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling markSubmissionItemAsReadSections.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling markSubmissionItemAsReadSections.');
        }

        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling markSubmissionItemAsReadSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the number of submissions for the given assignment based on gradeable students that fall into three categories: graded, ungraded, not submitted.
     * @summary Submission Summary
     * @param courseId ID
     * @param assignmentId ID
     * @param grouped If this argument is true, the response will take into account student groups.
     */
    public async submissionSummaryCourses (courseId: string, assignmentId: string, grouped?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submission_summary'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling submissionSummaryCourses.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling submissionSummaryCourses.');
        }

        if (grouped !== undefined) {
            localVarQueryParameters['grouped'] = ObjectSerializer.serialize(grouped, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the number of submissions for the given assignment based on gradeable students that fall into three categories: graded, ungraded, not submitted.
     * @summary Submission Summary
     * @param sectionId ID
     * @param assignmentId ID
     * @param grouped If this argument is true, the response will take into account student groups.
     */
    public async submissionSummarySections (sectionId: string, assignmentId: string, grouped?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submission_summary'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling submissionSummarySections.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling submissionSummarySections.');
        }

        if (grouped !== undefined) {
            localVarQueryParameters['grouped'] = ObjectSerializer.serialize(grouped, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Make a submission for an assignment. You must be actively enrolled as a student in the course/section to do this. Concluded and pending enrollments are not permitted.  All online turn-in submission types are supported in this API. However, there are a few things that are not yet supported:  * Files can be submitted based on a file ID of a user or group file or through the {api:SubmissionsApiController#create_file file upload API}. However, there is no API yet for listing the user and group files. * Media comments can be submitted, however, there is no API yet for creating a media comment to submit. * Integration with Google Docs is not yet supported.
     * @summary Submit an assignment
     * @param courseId ID
     * @param assignmentId ID
     * @param submissionSubmissionType The type of submission being made. The assignment submission_types must include this submission type as an allowed option, or the submission will be rejected with a 400 error.  The submission_type given determines which of the following parameters is used. For instance, to submit a URL, submission [submission_type] must be set to \\\&quot;online_url\\\&quot;, otherwise the submission [url] parameter will be ignored.  \\\&quot;basic_lti_launch\\\&quot; requires the assignment submission_type \\\&quot;online\\\&quot; or \\\&quot;external_tool\\\&quot;
     * @param commentTextComment Include a textual comment with the submission.
     * @param submissionGroupComment Whether or not this comment should be sent to the entire group (defaults to false). Ignored if this is not a group assignment or if no text_comment is provided.
     * @param submissionBody Submit the assignment as an HTML document snippet. Note this HTML snippet will be sanitized using the same ruleset as a submission made from the Canvas web UI. The sanitized HTML will be returned in the response as the submission body. Requires a submission_type of \\\&quot;online_text_entry\\\&quot;.
     * @param submissionUrl Submit the assignment as a URL. The URL scheme must be \\\&quot;http\\\&quot; or \\\&quot;https\\\&quot;, no \\\&quot;ftp\\\&quot; or other URL schemes are allowed. If no scheme is given (e.g. \\\&quot;www.example.com\\\&quot;) then \\\&quot;http\\\&quot; will be assumed. Requires a submission_type of \\\&quot;online_url\\\&quot; or \\\&quot;basic_lti_launch\\\&quot;.
     * @param submissionFileIds Submit the assignment as a set of one or more previously uploaded files residing in the submitting user\\\&#39;s files section (or the group\\\&#39;s files section, for group assignments).  To upload a new file to submit, see the submissions {api:SubmissionsApiController#create_file Upload a file API}.  Requires a submission_type of \\\&quot;online_upload\\\&quot;.
     * @param submissionMediaCommentId The media comment id to submit. Media comment ids can be submitted via this API, however, note that there is not yet an API to generate or list existing media comments, so this functionality is currently of limited use.  Requires a submission_type of \\\&quot;media_recording\\\&quot;.
     * @param submissionMediaCommentType The type of media comment being submitted.
     * @param submissionUserId Submit on behalf of the given user. Requires grading permission.
     * @param submissionAnnotatableAttachmentId The Attachment ID of the document being annotated. This should match the annotatable_attachment_id on the assignment.  Requires a submission_type of \\\&quot;student_annotation\\\&quot;.
     * @param submissionSubmittedAt Choose the time the submission is listed as submitted at.  Requires grading permission.
     */
    public async submitAssignmentCourses (courseId: string, assignmentId: string, submissionSubmissionType: string, commentTextComment?: string, submissionGroupComment?: boolean, submissionBody?: string, submissionUrl?: string, submissionFileIds?: Array<number>, submissionMediaCommentId?: string, submissionMediaCommentType?: string, submissionUserId?: number, submissionAnnotatableAttachmentId?: number, submissionSubmittedAt?: Date, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling submitAssignmentCourses.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling submitAssignmentCourses.');
        }

        // verify required parameter 'submissionSubmissionType' is not null or undefined
        if (submissionSubmissionType === null || submissionSubmissionType === undefined) {
            throw new Error('Required parameter submissionSubmissionType was null or undefined when calling submitAssignmentCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (commentTextComment !== undefined) {
            localVarFormParams['comment[text_comment]'] = ObjectSerializer.serialize(commentTextComment, "string");
        }

        if (submissionGroupComment !== undefined) {
            localVarFormParams['submission[group_comment]'] = ObjectSerializer.serialize(submissionGroupComment, "boolean");
        }

        if (submissionSubmissionType !== undefined) {
            localVarFormParams['submission[submission_type]'] = ObjectSerializer.serialize(submissionSubmissionType, "string");
        }

        if (submissionBody !== undefined) {
            localVarFormParams['submission[body]'] = ObjectSerializer.serialize(submissionBody, "string");
        }

        if (submissionUrl !== undefined) {
            localVarFormParams['submission[url]'] = ObjectSerializer.serialize(submissionUrl, "string");
        }

        if (submissionFileIds !== undefined) {
            localVarFormParams['submission[file_ids]'] = ObjectSerializer.serialize(submissionFileIds, "Array<number>");
        }

        if (submissionMediaCommentId !== undefined) {
            localVarFormParams['submission[media_comment_id]'] = ObjectSerializer.serialize(submissionMediaCommentId, "string");
        }

        if (submissionMediaCommentType !== undefined) {
            localVarFormParams['submission[media_comment_type]'] = ObjectSerializer.serialize(submissionMediaCommentType, "string");
        }

        if (submissionUserId !== undefined) {
            localVarFormParams['submission[user_id]'] = ObjectSerializer.serialize(submissionUserId, "number");
        }

        if (submissionAnnotatableAttachmentId !== undefined) {
            localVarFormParams['submission[annotatable_attachment_id]'] = ObjectSerializer.serialize(submissionAnnotatableAttachmentId, "number");
        }

        if (submissionSubmittedAt !== undefined) {
            localVarFormParams['submission[submitted_at]'] = ObjectSerializer.serialize(submissionSubmittedAt, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Make a submission for an assignment. You must be actively enrolled as a student in the course/section to do this. Concluded and pending enrollments are not permitted.  All online turn-in submission types are supported in this API. However, there are a few things that are not yet supported:  * Files can be submitted based on a file ID of a user or group file or through the {api:SubmissionsApiController#create_file file upload API}. However, there is no API yet for listing the user and group files. * Media comments can be submitted, however, there is no API yet for creating a media comment to submit. * Integration with Google Docs is not yet supported.
     * @summary Submit an assignment
     * @param sectionId ID
     * @param assignmentId ID
     * @param submissionSubmissionType The type of submission being made. The assignment submission_types must include this submission type as an allowed option, or the submission will be rejected with a 400 error.  The submission_type given determines which of the following parameters is used. For instance, to submit a URL, submission [submission_type] must be set to \\\&quot;online_url\\\&quot;, otherwise the submission [url] parameter will be ignored.  \\\&quot;basic_lti_launch\\\&quot; requires the assignment submission_type \\\&quot;online\\\&quot; or \\\&quot;external_tool\\\&quot;
     * @param commentTextComment Include a textual comment with the submission.
     * @param submissionGroupComment Whether or not this comment should be sent to the entire group (defaults to false). Ignored if this is not a group assignment or if no text_comment is provided.
     * @param submissionBody Submit the assignment as an HTML document snippet. Note this HTML snippet will be sanitized using the same ruleset as a submission made from the Canvas web UI. The sanitized HTML will be returned in the response as the submission body. Requires a submission_type of \\\&quot;online_text_entry\\\&quot;.
     * @param submissionUrl Submit the assignment as a URL. The URL scheme must be \\\&quot;http\\\&quot; or \\\&quot;https\\\&quot;, no \\\&quot;ftp\\\&quot; or other URL schemes are allowed. If no scheme is given (e.g. \\\&quot;www.example.com\\\&quot;) then \\\&quot;http\\\&quot; will be assumed. Requires a submission_type of \\\&quot;online_url\\\&quot; or \\\&quot;basic_lti_launch\\\&quot;.
     * @param submissionFileIds Submit the assignment as a set of one or more previously uploaded files residing in the submitting user\\\&#39;s files section (or the group\\\&#39;s files section, for group assignments).  To upload a new file to submit, see the submissions {api:SubmissionsApiController#create_file Upload a file API}.  Requires a submission_type of \\\&quot;online_upload\\\&quot;.
     * @param submissionMediaCommentId The media comment id to submit. Media comment ids can be submitted via this API, however, note that there is not yet an API to generate or list existing media comments, so this functionality is currently of limited use.  Requires a submission_type of \\\&quot;media_recording\\\&quot;.
     * @param submissionMediaCommentType The type of media comment being submitted.
     * @param submissionUserId Submit on behalf of the given user. Requires grading permission.
     * @param submissionAnnotatableAttachmentId The Attachment ID of the document being annotated. This should match the annotatable_attachment_id on the assignment.  Requires a submission_type of \\\&quot;student_annotation\\\&quot;.
     * @param submissionSubmittedAt Choose the time the submission is listed as submitted at.  Requires grading permission.
     */
    public async submitAssignmentSections (sectionId: string, assignmentId: string, submissionSubmissionType: string, commentTextComment?: string, submissionGroupComment?: boolean, submissionBody?: string, submissionUrl?: string, submissionFileIds?: Array<number>, submissionMediaCommentId?: string, submissionMediaCommentType?: string, submissionUserId?: number, submissionAnnotatableAttachmentId?: number, submissionSubmittedAt?: Date, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling submitAssignmentSections.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling submitAssignmentSections.');
        }

        // verify required parameter 'submissionSubmissionType' is not null or undefined
        if (submissionSubmissionType === null || submissionSubmissionType === undefined) {
            throw new Error('Required parameter submissionSubmissionType was null or undefined when calling submitAssignmentSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (commentTextComment !== undefined) {
            localVarFormParams['comment[text_comment]'] = ObjectSerializer.serialize(commentTextComment, "string");
        }

        if (submissionGroupComment !== undefined) {
            localVarFormParams['submission[group_comment]'] = ObjectSerializer.serialize(submissionGroupComment, "boolean");
        }

        if (submissionSubmissionType !== undefined) {
            localVarFormParams['submission[submission_type]'] = ObjectSerializer.serialize(submissionSubmissionType, "string");
        }

        if (submissionBody !== undefined) {
            localVarFormParams['submission[body]'] = ObjectSerializer.serialize(submissionBody, "string");
        }

        if (submissionUrl !== undefined) {
            localVarFormParams['submission[url]'] = ObjectSerializer.serialize(submissionUrl, "string");
        }

        if (submissionFileIds !== undefined) {
            localVarFormParams['submission[file_ids]'] = ObjectSerializer.serialize(submissionFileIds, "Array<number>");
        }

        if (submissionMediaCommentId !== undefined) {
            localVarFormParams['submission[media_comment_id]'] = ObjectSerializer.serialize(submissionMediaCommentId, "string");
        }

        if (submissionMediaCommentType !== undefined) {
            localVarFormParams['submission[media_comment_type]'] = ObjectSerializer.serialize(submissionMediaCommentType, "string");
        }

        if (submissionUserId !== undefined) {
            localVarFormParams['submission[user_id]'] = ObjectSerializer.serialize(submissionUserId, "number");
        }

        if (submissionAnnotatableAttachmentId !== undefined) {
            localVarFormParams['submission[annotatable_attachment_id]'] = ObjectSerializer.serialize(submissionAnnotatableAttachmentId, "number");
        }

        if (submissionSubmittedAt !== undefined) {
            localVarFormParams['submission[submitted_at]'] = ObjectSerializer.serialize(submissionSubmittedAt, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Upload a file to a submission.  This API endpoint is the first step in uploading a file to a submission as a student. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.  The final step of the file upload workflow will return the attachment data, including the new file id. The caller can then POST to submit the +online_upload+ assignment with these file ids.
     * @summary Upload a file
     * @param courseId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async uploadFileCourses (courseId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/files'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling uploadFileCourses.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling uploadFileCourses.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling uploadFileCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Upload a file to a submission.  This API endpoint is the first step in uploading a file to a submission as a student. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.  The final step of the file upload workflow will return the attachment data, including the new file id. The caller can then POST to submit the +online_upload+ assignment with these file ids.
     * @summary Upload a file
     * @param sectionId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async uploadFileSections (sectionId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/files'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling uploadFileSections.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling uploadFileSections.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling uploadFileSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
