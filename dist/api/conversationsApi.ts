/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Conversation } from '../model/conversation';
import { Progress } from '../model/progress';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ConversationsApiApiKeys {
}

export class ConversationsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ConversationsApiApiKeys, value: string) {
        (this.authentications as any)[ConversationsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Add a message to an existing conversation. Response is similar to the GET/show action, except that only includes the latest message (i.e. what we just sent)  An array of user ids. Defaults to all of the current conversation recipients. To explicitly send a message to no other recipients, this array should consist of the logged-in user id.  An array of message ids from this conversation to send to recipients of the new message. Recipients who already had a copy of included messages will not be affected.
     * @summary Add a message
     * @param id ID
     * @param body The message to be sent.
     * @param attachmentIds An array of attachments ids. These must be files that have been previously uploaded to the sender\\\&#39;s \\\&quot;conversation attachments\\\&quot; folder.
     * @param mediaCommentId Media comment id of an audio of video file to be associated with this message.
     * @param mediaCommentType Type of the associated media file.
     * @param recipients no description
     * @param includedMessages no description
     */
    public async addMessage (id: string, body: string, attachmentIds?: Array<string>, mediaCommentId?: string, mediaCommentType?: string, recipients?: Array<string>, includedMessages?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/conversations/{id}/add_message'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addMessage.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (body !== undefined) {
            localVarFormParams['body'] = ObjectSerializer.serialize(body, "string");
        }

        if (attachmentIds !== undefined) {
            localVarFormParams['attachment_ids'] = ObjectSerializer.serialize(attachmentIds, "Array<string>");
        }

        if (mediaCommentId !== undefined) {
            localVarFormParams['media_comment_id'] = ObjectSerializer.serialize(mediaCommentId, "string");
        }

        if (mediaCommentType !== undefined) {
            localVarFormParams['media_comment_type'] = ObjectSerializer.serialize(mediaCommentType, "string");
        }

        if (recipients !== undefined) {
            localVarFormParams['recipients'] = ObjectSerializer.serialize(recipients, "Array<string>");
        }

        if (includedMessages !== undefined) {
            localVarFormParams['included_messages'] = ObjectSerializer.serialize(includedMessages, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Add recipients to an existing group conversation. Response is similar to the GET/show action, except that only includes the latest message (e.g. \"joe was added to the conversation by bob\")
     * @summary Add recipients
     * @param id ID
     * @param recipients An array of recipient ids. These may be user ids or course/group ids prefixed with \\\&quot;course_\\\&quot; or \\\&quot;group_\\\&quot; respectively, e.g. recipients[]&#x3D;1&amp;recipients[]&#x3D;2&amp;recipients[]&#x3D;course_3
     */
    public async addRecipients (id: string, recipients: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/conversations/{id}/add_recipients'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addRecipients.');
        }

        // verify required parameter 'recipients' is not null or undefined
        if (recipients === null || recipients === undefined) {
            throw new Error('Required parameter recipients was null or undefined when calling addRecipients.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (recipients !== undefined) {
            localVarFormParams['recipients'] = ObjectSerializer.serialize(recipients, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Perform a change on a set of conversations. Operates asynchronously; use the {api:ProgressController#show progress endpoint} to query the status of an operation.
     * @summary Batch update conversations
     * @param conversationIds List of conversations to update. Limited to 500 conversations.
     * @param event The action to take on each conversation.
     */
    public async batchUpdateConversations (conversationIds: Array<string>, event: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Progress;  }> {
        const localVarPath = this.basePath + '/v1/conversations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'conversationIds' is not null or undefined
        if (conversationIds === null || conversationIds === undefined) {
            throw new Error('Required parameter conversationIds was null or undefined when calling batchUpdateConversations.');
        }

        // verify required parameter 'event' is not null or undefined
        if (event === null || event === undefined) {
            throw new Error('Required parameter event was null or undefined when calling batchUpdateConversations.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (conversationIds !== undefined) {
            localVarFormParams['conversation_ids'] = ObjectSerializer.serialize(conversationIds, "Array<string>");
        }

        if (event !== undefined) {
            localVarFormParams['event'] = ObjectSerializer.serialize(event, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Progress;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Progress");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a new conversation with one or more recipients. If there is already an existing private conversation with the given recipients, it will be reused.
     * @summary Create a conversation
     * @param recipients An array of recipient ids. These may be user ids or course/group ids prefixed with \\\&quot;course_\\\&quot; or \\\&quot;group_\\\&quot; respectively, e.g. recipients[]&#x3D;1&amp;recipients[]&#x3D;2&amp;recipients[]&#x3D;course_3. If the course/group has over 100 enrollments, \\\&#39;bulk_message\\\&#39; and \\\&#39;group_conversation\\\&#39; must be set to true.
     * @param body The message to be sent
     * @param subject The subject of the conversation. This is ignored when reusing a conversation. Maximum length is 255 characters.
     * @param forceNew Forces a new message to be created, even if there is an existing private conversation.
     * @param groupConversation Defaults to false.  When false, individual private conversations will be created with each recipient. If true, this will be a group conversation (i.e. all recipients may see all messages and replies). Must be set true if the number of recipients is over the set maximum (default is 100).
     * @param attachmentIds An array of attachments ids. These must be files that have been previously uploaded to the sender\\\&#39;s \\\&quot;conversation attachments\\\&quot; folder.
     * @param mediaCommentId Media comment id of an audio or video file to be associated with this message.
     * @param mediaCommentType Type of the associated media file
     * @param mode Determines whether the messages will be created/sent synchronously or asynchronously. Defaults to sync, and this option is ignored if this is a group conversation or there is just one recipient (i.e. it must be a bulk private message). When sent async, the response will be an empty array (batch status can be queried via the {api:ConversationsController#batches batches API})
     * @param scope Used when generating \\\&quot;visible\\\&quot; in the API response. See the explanation under the {api:ConversationsController#index index API action}
     * @param filter Used when generating \\\&quot;visible\\\&quot; in the API response. See the explanation under the {api:ConversationsController#index index API action}
     * @param filterMode Used when generating \\\&quot;visible\\\&quot; in the API response. See the explanation under the {api:ConversationsController#index index API action}
     * @param contextCode The course or group that is the context for this conversation. Same format as courses or groups in the recipients argument.
     */
    public async createConversation (recipients: Array<string>, body: string, subject?: string, forceNew?: boolean, groupConversation?: boolean, attachmentIds?: Array<string>, mediaCommentId?: string, mediaCommentType?: string, mode?: string, scope?: string, filter?: Array<string>, filterMode?: string, contextCode?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/conversations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'recipients' is not null or undefined
        if (recipients === null || recipients === undefined) {
            throw new Error('Required parameter recipients was null or undefined when calling createConversation.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createConversation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (recipients !== undefined) {
            localVarFormParams['recipients'] = ObjectSerializer.serialize(recipients, "Array<string>");
        }

        if (subject !== undefined) {
            localVarFormParams['subject'] = ObjectSerializer.serialize(subject, "string");
        }

        if (body !== undefined) {
            localVarFormParams['body'] = ObjectSerializer.serialize(body, "string");
        }

        if (forceNew !== undefined) {
            localVarFormParams['force_new'] = ObjectSerializer.serialize(forceNew, "boolean");
        }

        if (groupConversation !== undefined) {
            localVarFormParams['group_conversation'] = ObjectSerializer.serialize(groupConversation, "boolean");
        }

        if (attachmentIds !== undefined) {
            localVarFormParams['attachment_ids'] = ObjectSerializer.serialize(attachmentIds, "Array<string>");
        }

        if (mediaCommentId !== undefined) {
            localVarFormParams['media_comment_id'] = ObjectSerializer.serialize(mediaCommentId, "string");
        }

        if (mediaCommentType !== undefined) {
            localVarFormParams['media_comment_type'] = ObjectSerializer.serialize(mediaCommentType, "string");
        }

        if (mode !== undefined) {
            localVarFormParams['mode'] = ObjectSerializer.serialize(mode, "string");
        }

        if (scope !== undefined) {
            localVarFormParams['scope'] = ObjectSerializer.serialize(scope, "string");
        }

        if (filter !== undefined) {
            localVarFormParams['filter'] = ObjectSerializer.serialize(filter, "Array<string>");
        }

        if (filterMode !== undefined) {
            localVarFormParams['filter_mode'] = ObjectSerializer.serialize(filterMode, "string");
        }

        if (contextCode !== undefined) {
            localVarFormParams['context_code'] = ObjectSerializer.serialize(contextCode, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete this conversation and its messages. Note that this only deletes this user\'s view of the conversation.  Response includes same fields as UPDATE action
     * @summary Delete a conversation
     * @param id ID
     */
    public async deleteConversation (id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/conversations/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteConversation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete messages from this conversation. Note that this only affects this user\'s view of the conversation. If all messages are deleted, the conversation will be as well (equivalent to DELETE)
     * @summary Delete a message
     * @param id ID
     * @param remove Array of message ids to be deleted
     */
    public async deleteMessage (id: string, remove: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/conversations/{id}/remove_messages'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteMessage.');
        }

        // verify required parameter 'remove' is not null or undefined
        if (remove === null || remove === undefined) {
            throw new Error('Required parameter remove was null or undefined when calling deleteMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (remove !== undefined) {
            localVarFormParams['remove'] = ObjectSerializer.serialize(remove, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates attributes for a single conversation.
     * @summary Edit a conversation
     * @param id ID
     * @param conversationWorkflowState Change the state of this conversation
     * @param conversationSubscribed Toggle the current user\\\&#39;s subscription to the conversation (only valid for group conversations). If unsubscribed, the user will still have access to the latest messages, but the conversation won\\\&#39;t be automatically flagged as unread, nor will it jump to the top of the inbox.
     * @param conversationStarred Toggle the starred state of the current user\\\&#39;s view of the conversation.
     * @param scope Used when generating \\\&quot;visible\\\&quot; in the API response. See the explanation under the {api:ConversationsController#index index API action}
     * @param filter Used when generating \\\&quot;visible\\\&quot; in the API response. See the explanation under the {api:ConversationsController#index index API action}
     * @param filterMode Used when generating \\\&quot;visible\\\&quot; in the API response. See the explanation under the {api:ConversationsController#index index API action}
     */
    public async editConversation (id: string, conversationWorkflowState?: string, conversationSubscribed?: boolean, conversationStarred?: boolean, scope?: string, filter?: Array<string>, filterMode?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/conversations/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling editConversation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (conversationWorkflowState !== undefined) {
            localVarFormParams['conversation[workflow_state]'] = ObjectSerializer.serialize(conversationWorkflowState, "string");
        }

        if (conversationSubscribed !== undefined) {
            localVarFormParams['conversation[subscribed]'] = ObjectSerializer.serialize(conversationSubscribed, "boolean");
        }

        if (conversationStarred !== undefined) {
            localVarFormParams['conversation[starred]'] = ObjectSerializer.serialize(conversationStarred, "boolean");
        }

        if (scope !== undefined) {
            localVarFormParams['scope'] = ObjectSerializer.serialize(scope, "string");
        }

        if (filter !== undefined) {
            localVarFormParams['filter'] = ObjectSerializer.serialize(filter, "Array<string>");
        }

        if (filterMode !== undefined) {
            localVarFormParams['filter_mode'] = ObjectSerializer.serialize(filterMode, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns any currently running conversation batches for the current user. Conversation batches are created when a bulk private message is sent asynchronously (see the mode argument to the {api:ConversationsController#create create API action}).
     * @summary Get running batches
     */
    public async getRunningBatches (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/conversations/batches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns information for a single conversation for the current user. Response includes all fields that are present in the list/index action as well as messages and extended participant information.
     * @summary Get a single conversation
     * @param id ID
     * @param interleaveSubmissions (Obsolete) Submissions are no longer linked to conversations. This parameter is ignored.
     * @param scope Used when generating \&quot;visible\&quot; in the API response. See the explanation under the {api:ConversationsController#index index API action}
     * @param filter Used when generating \&quot;visible\&quot; in the API response. See the explanation under the {api:ConversationsController#index index API action}
     * @param filterMode Used when generating \&quot;visible\&quot; in the API response. See the explanation under the {api:ConversationsController#index index API action}
     * @param autoMarkAsRead Default true. If true, unread conversations will be automatically marked as read. This will default to false in a future API release, so clients should explicitly send true if that is the desired behavior.
     */
    public async getSingleConversation (id: string, interleaveSubmissions?: boolean, scope?: 'unread' | 'starred' | 'archived', filter?: Array<string>, filterMode?: 'and' | 'or' | 'default or', autoMarkAsRead?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/conversations/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSingleConversation.');
        }

        if (interleaveSubmissions !== undefined) {
            localVarQueryParameters['interleave_submissions'] = ObjectSerializer.serialize(interleaveSubmissions, "boolean");
        }

        if (scope !== undefined) {
            localVarQueryParameters['scope'] = ObjectSerializer.serialize(scope, "'unread' | 'starred' | 'archived'");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "Array<string>");
        }

        if (filterMode !== undefined) {
            localVarQueryParameters['filter_mode'] = ObjectSerializer.serialize(filterMode, "'and' | 'or' | 'default or'");
        }

        if (autoMarkAsRead !== undefined) {
            localVarQueryParameters['auto_mark_as_read'] = ObjectSerializer.serialize(autoMarkAsRead, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the paginated list of conversations for the current user, most recent ones first.
     * @summary List conversations
     * @param scope When set, only return conversations of the specified type. For example, set to \&quot;unread\&quot; to return only conversations that haven\&#39;t been read. The default behavior is to return all non-archived conversations (i.e. read and unread).
     * @param filter When set, only return conversations for the specified courses, groups or users. The id should be prefixed with its type, e.g. \&quot;user_123\&quot; or \&quot;course_456\&quot;. Can be an array (by setting \&quot;filter[]\&quot;) or single value (by setting \&quot;filter\&quot;)
     * @param filterMode When filter[] contains multiple filters, combine them with this mode, filtering conversations that at have at least all of the contexts (\&quot;and\&quot;) or at least one of the contexts (\&quot;or\&quot;)
     * @param interleaveSubmissions (Obsolete) Submissions are no longer linked to conversations. This parameter is ignored.
     * @param includeAllConversationIds Default is false. If true, the top-level element of the response will be an object rather than an array, and will have the keys \&quot;conversations\&quot; which will contain the paged conversation data, and \&quot;conversation_ids\&quot; which will contain the ids of all conversations under this scope/filter in the same order.
     * @param include \&quot;participant_avatars\&quot;:: Optionally include an \&quot;avatar_url\&quot; key for each user participanting in the conversation
     */
    public async listConversations (scope?: 'unread' | 'starred' | 'archived' | 'sent', filter?: Array<string>, filterMode?: 'and' | 'or' | 'default or', interleaveSubmissions?: boolean, includeAllConversationIds?: boolean, include?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Conversation>;  }> {
        const localVarPath = this.basePath + '/v1/conversations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (scope !== undefined) {
            localVarQueryParameters['scope'] = ObjectSerializer.serialize(scope, "'unread' | 'starred' | 'archived' | 'sent'");
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "Array<string>");
        }

        if (filterMode !== undefined) {
            localVarQueryParameters['filter_mode'] = ObjectSerializer.serialize(filterMode, "'and' | 'or' | 'default or'");
        }

        if (interleaveSubmissions !== undefined) {
            localVarQueryParameters['interleave_submissions'] = ObjectSerializer.serialize(interleaveSubmissions, "boolean");
        }

        if (includeAllConversationIds !== undefined) {
            localVarQueryParameters['include_all_conversation_ids'] = ObjectSerializer.serialize(includeAllConversationIds, "boolean");
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Conversation>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Conversation>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark all conversations as read.
     * @summary Mark all as read
     */
    public async markAllAsRead (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/conversations/mark_all_as_read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get the number of unread conversations for the current user
     * @summary Unread count
     */
    public async unreadCount (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/conversations/unread_count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
