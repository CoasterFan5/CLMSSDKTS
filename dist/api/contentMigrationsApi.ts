/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { ContentMigration } from '../model/contentMigration';
import { Listofcontentitems } from '../model/listofcontentitems';
import { MigrationIssue } from '../model/migrationIssue';
import { Migrator } from '../model/migrator';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ContentMigrationsApiApiKeys {
}

export class ContentMigrationsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ContentMigrationsApiApiKeys, value: string) {
        (this.authentications as any)[ContentMigrationsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create a content migration. If the migration requires a file to be uploaded the actual processing of the file will start once the file upload process is completed. File uploading works as described in the {file:file_uploads.html File Upload Documentation} except that the values are set on a *pre_attachment* sub-hash.  For migrations that don\'t require a file to be uploaded, like course copy, the processing will begin as soon as the migration is created.  You can use the {api:ProgressController#show Progress API} to track the progress of the migration. The migration\'s progress is linked to with the _progress_url_ value.  The two general workflows are:  If no file upload is needed:  1. POST to create 2. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress  For file uploading:  1. POST to create with file info in *pre_attachment* 2. Do {file:file_uploads.html file upload processing} using the data in the *pre_attachment* data 3. {api:ContentMigrationsController#show GET} the ContentMigration 4. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress   (required if doing .zip file upload)
     * @summary Create a content migration
     * @param accountId ID
     * @param migrationType The type of the migration. Use the {api:ContentMigrationsController#available_migrators Migrator} endpoint to see all available migrators. Default allowed values: canvas_cartridge_importer, common_cartridge_importer, course_copy_importer, zip_file_importer, qti_converter, moodle_converter
     * @param preAttachmentName Required if uploading a file. This is the first step in uploading a file to the content migration. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.
     * @param preAttachment Other file upload properties, See {file:file_uploads.html File Upload Documentation}
     * @param settingsFileUrl A URL to download the file from. Must not require authentication.
     * @param settingsContentExportId The id of a ContentExport to import. This allows you to import content previously exported from Canvas without needing to download and re-upload it.
     * @param settingsSourceCourseId The course to copy from for a course copy migration. (required if doing course copy)
     * @param settingsFolderId The folder to unzip the .zip file into for a zip_file_import.
     * @param settingsOverwriteQuizzes Whether to overwrite quizzes with the same identifiers between content packages.
     * @param settingsQuestionBankId The existing question bank ID to import questions into if not specified in the content package.
     * @param settingsQuestionBankName The question bank to import questions into if not specified in the content package, if both bank id and name are set, id will take precedence.
     * @param settingsInsertIntoModuleId The id of a module in the target course. This will add all imported items (that can be added to a module) to the given module.
     * @param settingsInsertIntoModuleType If provided (and +insert_into_module_id+ is supplied), only add objects of the specified type to the module.
     * @param settingsInsertIntoModulePosition The (1-based) position to insert the imported items into the course (if +insert_into_module_id+ is supplied). If this parameter is omitted, items will be added to the end of the module.
     * @param settingsMoveToAssignmentGroupId The id of an assignment group in the target course. If provided, all imported assignments will be moved to the given assignment group.
     * @param settingsImporterSkips Set of importers to skip, even if otherwise selected by migration settings.
     * @param settingsImportBlueprintSettings Import the \\\&quot;use as blueprint course\\\&quot; setting as well as the list of locked items from the source course or package. The destination course must not be associated with an existing blueprint course and cannot have any student or observer enrollments.
     * @param dateShiftOptionsShiftDates Whether to shift dates in the copied course
     * @param dateShiftOptionsOldStartDate The original start date of the source content/course
     * @param dateShiftOptionsOldEndDate The original end date of the source content/course
     * @param dateShiftOptionsNewStartDate The new start date for the content/course
     * @param dateShiftOptionsNewEndDate The new end date for the source content/course
     * @param dateShiftOptionsDaySubstitutionsX Move anything scheduled for day \\\&#39;X\\\&#39; to the specified day. (0-Sunday, 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
     * @param dateShiftOptionsRemoveDates Whether to remove dates in the copied course. Cannot be used in conjunction with *shift_dates*.
     * @param selectiveImport If set, perform a selective import instead of importing all content. The migration will identify the contents of the package and then stop in the +waiting_for_select+ workflow state. At this point, use the {api:ContentMigrationsController#content_list List items endpoint} to enumerate the contents of the package, identifying the copy parameters for the desired content. Then call the {api:ContentMigrationsController#update Update endpoint} and provide these copy parameters to start the import.
     * @param select For +course_copy_importer+ migrations, this parameter allows you to select the objects to copy without using the +selective_import+ argument and +waiting_for_select+ state as is required for uploaded imports (though that workflow is also supported for course copy migrations). The keys are object types like \\\&#39;files\\\&#39;, \\\&#39;folders\\\&#39;, \\\&#39;pages\\\&#39;, etc. The value for each key is a list of object ids. An id can be an integer or a string. Multiple object types can be selected in the same call.
     */
    public async createContentMigrationAccounts (accountId: string, migrationType: string, preAttachmentName?: string, preAttachment?: string, settingsFileUrl?: string, settingsContentExportId?: string, settingsSourceCourseId?: string, settingsFolderId?: string, settingsOverwriteQuizzes?: boolean, settingsQuestionBankId?: number, settingsQuestionBankName?: string, settingsInsertIntoModuleId?: number, settingsInsertIntoModuleType?: string, settingsInsertIntoModulePosition?: number, settingsMoveToAssignmentGroupId?: number, settingsImporterSkips?: Array<string>, settingsImportBlueprintSettings?: boolean, dateShiftOptionsShiftDates?: boolean, dateShiftOptionsOldStartDate?: string, dateShiftOptionsOldEndDate?: string, dateShiftOptionsNewStartDate?: string, dateShiftOptionsNewEndDate?: string, dateShiftOptionsDaySubstitutionsX?: number, dateShiftOptionsRemoveDates?: boolean, selectiveImport?: boolean, select?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ContentMigration;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/content_migrations'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createContentMigrationAccounts.');
        }

        // verify required parameter 'migrationType' is not null or undefined
        if (migrationType === null || migrationType === undefined) {
            throw new Error('Required parameter migrationType was null or undefined when calling createContentMigrationAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (migrationType !== undefined) {
            localVarFormParams['migration_type'] = ObjectSerializer.serialize(migrationType, "string");
        }

        if (preAttachmentName !== undefined) {
            localVarFormParams['pre_attachment[name]'] = ObjectSerializer.serialize(preAttachmentName, "string");
        }

        if (preAttachment !== undefined) {
            localVarFormParams['pre_attachment[*]'] = ObjectSerializer.serialize(preAttachment, "string");
        }

        if (settingsFileUrl !== undefined) {
            localVarFormParams['settings[file_url]'] = ObjectSerializer.serialize(settingsFileUrl, "string");
        }

        if (settingsContentExportId !== undefined) {
            localVarFormParams['settings[content_export_id]'] = ObjectSerializer.serialize(settingsContentExportId, "string");
        }

        if (settingsSourceCourseId !== undefined) {
            localVarFormParams['settings[source_course_id]'] = ObjectSerializer.serialize(settingsSourceCourseId, "string");
        }

        if (settingsFolderId !== undefined) {
            localVarFormParams['settings[folder_id]'] = ObjectSerializer.serialize(settingsFolderId, "string");
        }

        if (settingsOverwriteQuizzes !== undefined) {
            localVarFormParams['settings[overwrite_quizzes]'] = ObjectSerializer.serialize(settingsOverwriteQuizzes, "boolean");
        }

        if (settingsQuestionBankId !== undefined) {
            localVarFormParams['settings[question_bank_id]'] = ObjectSerializer.serialize(settingsQuestionBankId, "number");
        }

        if (settingsQuestionBankName !== undefined) {
            localVarFormParams['settings[question_bank_name]'] = ObjectSerializer.serialize(settingsQuestionBankName, "string");
        }

        if (settingsInsertIntoModuleId !== undefined) {
            localVarFormParams['settings[insert_into_module_id]'] = ObjectSerializer.serialize(settingsInsertIntoModuleId, "number");
        }

        if (settingsInsertIntoModuleType !== undefined) {
            localVarFormParams['settings[insert_into_module_type]'] = ObjectSerializer.serialize(settingsInsertIntoModuleType, "string");
        }

        if (settingsInsertIntoModulePosition !== undefined) {
            localVarFormParams['settings[insert_into_module_position]'] = ObjectSerializer.serialize(settingsInsertIntoModulePosition, "number");
        }

        if (settingsMoveToAssignmentGroupId !== undefined) {
            localVarFormParams['settings[move_to_assignment_group_id]'] = ObjectSerializer.serialize(settingsMoveToAssignmentGroupId, "number");
        }

        if (settingsImporterSkips !== undefined) {
            localVarFormParams['settings[importer_skips]'] = ObjectSerializer.serialize(settingsImporterSkips, "Array<string>");
        }

        if (settingsImportBlueprintSettings !== undefined) {
            localVarFormParams['settings[import_blueprint_settings]'] = ObjectSerializer.serialize(settingsImportBlueprintSettings, "boolean");
        }

        if (dateShiftOptionsShiftDates !== undefined) {
            localVarFormParams['date_shift_options[shift_dates]'] = ObjectSerializer.serialize(dateShiftOptionsShiftDates, "boolean");
        }

        if (dateShiftOptionsOldStartDate !== undefined) {
            localVarFormParams['date_shift_options[old_start_date]'] = ObjectSerializer.serialize(dateShiftOptionsOldStartDate, "string");
        }

        if (dateShiftOptionsOldEndDate !== undefined) {
            localVarFormParams['date_shift_options[old_end_date]'] = ObjectSerializer.serialize(dateShiftOptionsOldEndDate, "string");
        }

        if (dateShiftOptionsNewStartDate !== undefined) {
            localVarFormParams['date_shift_options[new_start_date]'] = ObjectSerializer.serialize(dateShiftOptionsNewStartDate, "string");
        }

        if (dateShiftOptionsNewEndDate !== undefined) {
            localVarFormParams['date_shift_options[new_end_date]'] = ObjectSerializer.serialize(dateShiftOptionsNewEndDate, "string");
        }

        if (dateShiftOptionsDaySubstitutionsX !== undefined) {
            localVarFormParams['date_shift_options[day_substitutions][X]'] = ObjectSerializer.serialize(dateShiftOptionsDaySubstitutionsX, "number");
        }

        if (dateShiftOptionsRemoveDates !== undefined) {
            localVarFormParams['date_shift_options[remove_dates]'] = ObjectSerializer.serialize(dateShiftOptionsRemoveDates, "boolean");
        }

        if (selectiveImport !== undefined) {
            localVarFormParams['selective_import'] = ObjectSerializer.serialize(selectiveImport, "boolean");
        }

        if (select !== undefined) {
            localVarFormParams['select'] = ObjectSerializer.serialize(select, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ContentMigration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ContentMigration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a content migration. If the migration requires a file to be uploaded the actual processing of the file will start once the file upload process is completed. File uploading works as described in the {file:file_uploads.html File Upload Documentation} except that the values are set on a *pre_attachment* sub-hash.  For migrations that don\'t require a file to be uploaded, like course copy, the processing will begin as soon as the migration is created.  You can use the {api:ProgressController#show Progress API} to track the progress of the migration. The migration\'s progress is linked to with the _progress_url_ value.  The two general workflows are:  If no file upload is needed:  1. POST to create 2. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress  For file uploading:  1. POST to create with file info in *pre_attachment* 2. Do {file:file_uploads.html file upload processing} using the data in the *pre_attachment* data 3. {api:ContentMigrationsController#show GET} the ContentMigration 4. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress   (required if doing .zip file upload)
     * @summary Create a content migration
     * @param courseId ID
     * @param migrationType The type of the migration. Use the {api:ContentMigrationsController#available_migrators Migrator} endpoint to see all available migrators. Default allowed values: canvas_cartridge_importer, common_cartridge_importer, course_copy_importer, zip_file_importer, qti_converter, moodle_converter
     * @param preAttachmentName Required if uploading a file. This is the first step in uploading a file to the content migration. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.
     * @param preAttachment Other file upload properties, See {file:file_uploads.html File Upload Documentation}
     * @param settingsFileUrl A URL to download the file from. Must not require authentication.
     * @param settingsContentExportId The id of a ContentExport to import. This allows you to import content previously exported from Canvas without needing to download and re-upload it.
     * @param settingsSourceCourseId The course to copy from for a course copy migration. (required if doing course copy)
     * @param settingsFolderId The folder to unzip the .zip file into for a zip_file_import.
     * @param settingsOverwriteQuizzes Whether to overwrite quizzes with the same identifiers between content packages.
     * @param settingsQuestionBankId The existing question bank ID to import questions into if not specified in the content package.
     * @param settingsQuestionBankName The question bank to import questions into if not specified in the content package, if both bank id and name are set, id will take precedence.
     * @param settingsInsertIntoModuleId The id of a module in the target course. This will add all imported items (that can be added to a module) to the given module.
     * @param settingsInsertIntoModuleType If provided (and +insert_into_module_id+ is supplied), only add objects of the specified type to the module.
     * @param settingsInsertIntoModulePosition The (1-based) position to insert the imported items into the course (if +insert_into_module_id+ is supplied). If this parameter is omitted, items will be added to the end of the module.
     * @param settingsMoveToAssignmentGroupId The id of an assignment group in the target course. If provided, all imported assignments will be moved to the given assignment group.
     * @param settingsImporterSkips Set of importers to skip, even if otherwise selected by migration settings.
     * @param settingsImportBlueprintSettings Import the \\\&quot;use as blueprint course\\\&quot; setting as well as the list of locked items from the source course or package. The destination course must not be associated with an existing blueprint course and cannot have any student or observer enrollments.
     * @param dateShiftOptionsShiftDates Whether to shift dates in the copied course
     * @param dateShiftOptionsOldStartDate The original start date of the source content/course
     * @param dateShiftOptionsOldEndDate The original end date of the source content/course
     * @param dateShiftOptionsNewStartDate The new start date for the content/course
     * @param dateShiftOptionsNewEndDate The new end date for the source content/course
     * @param dateShiftOptionsDaySubstitutionsX Move anything scheduled for day \\\&#39;X\\\&#39; to the specified day. (0-Sunday, 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
     * @param dateShiftOptionsRemoveDates Whether to remove dates in the copied course. Cannot be used in conjunction with *shift_dates*.
     * @param selectiveImport If set, perform a selective import instead of importing all content. The migration will identify the contents of the package and then stop in the +waiting_for_select+ workflow state. At this point, use the {api:ContentMigrationsController#content_list List items endpoint} to enumerate the contents of the package, identifying the copy parameters for the desired content. Then call the {api:ContentMigrationsController#update Update endpoint} and provide these copy parameters to start the import.
     * @param select For +course_copy_importer+ migrations, this parameter allows you to select the objects to copy without using the +selective_import+ argument and +waiting_for_select+ state as is required for uploaded imports (though that workflow is also supported for course copy migrations). The keys are object types like \\\&#39;files\\\&#39;, \\\&#39;folders\\\&#39;, \\\&#39;pages\\\&#39;, etc. The value for each key is a list of object ids. An id can be an integer or a string. Multiple object types can be selected in the same call.
     */
    public async createContentMigrationCourses (courseId: string, migrationType: string, preAttachmentName?: string, preAttachment?: string, settingsFileUrl?: string, settingsContentExportId?: string, settingsSourceCourseId?: string, settingsFolderId?: string, settingsOverwriteQuizzes?: boolean, settingsQuestionBankId?: number, settingsQuestionBankName?: string, settingsInsertIntoModuleId?: number, settingsInsertIntoModuleType?: string, settingsInsertIntoModulePosition?: number, settingsMoveToAssignmentGroupId?: number, settingsImporterSkips?: Array<string>, settingsImportBlueprintSettings?: boolean, dateShiftOptionsShiftDates?: boolean, dateShiftOptionsOldStartDate?: string, dateShiftOptionsOldEndDate?: string, dateShiftOptionsNewStartDate?: string, dateShiftOptionsNewEndDate?: string, dateShiftOptionsDaySubstitutionsX?: number, dateShiftOptionsRemoveDates?: boolean, selectiveImport?: boolean, select?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ContentMigration;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/content_migrations'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createContentMigrationCourses.');
        }

        // verify required parameter 'migrationType' is not null or undefined
        if (migrationType === null || migrationType === undefined) {
            throw new Error('Required parameter migrationType was null or undefined when calling createContentMigrationCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (migrationType !== undefined) {
            localVarFormParams['migration_type'] = ObjectSerializer.serialize(migrationType, "string");
        }

        if (preAttachmentName !== undefined) {
            localVarFormParams['pre_attachment[name]'] = ObjectSerializer.serialize(preAttachmentName, "string");
        }

        if (preAttachment !== undefined) {
            localVarFormParams['pre_attachment[*]'] = ObjectSerializer.serialize(preAttachment, "string");
        }

        if (settingsFileUrl !== undefined) {
            localVarFormParams['settings[file_url]'] = ObjectSerializer.serialize(settingsFileUrl, "string");
        }

        if (settingsContentExportId !== undefined) {
            localVarFormParams['settings[content_export_id]'] = ObjectSerializer.serialize(settingsContentExportId, "string");
        }

        if (settingsSourceCourseId !== undefined) {
            localVarFormParams['settings[source_course_id]'] = ObjectSerializer.serialize(settingsSourceCourseId, "string");
        }

        if (settingsFolderId !== undefined) {
            localVarFormParams['settings[folder_id]'] = ObjectSerializer.serialize(settingsFolderId, "string");
        }

        if (settingsOverwriteQuizzes !== undefined) {
            localVarFormParams['settings[overwrite_quizzes]'] = ObjectSerializer.serialize(settingsOverwriteQuizzes, "boolean");
        }

        if (settingsQuestionBankId !== undefined) {
            localVarFormParams['settings[question_bank_id]'] = ObjectSerializer.serialize(settingsQuestionBankId, "number");
        }

        if (settingsQuestionBankName !== undefined) {
            localVarFormParams['settings[question_bank_name]'] = ObjectSerializer.serialize(settingsQuestionBankName, "string");
        }

        if (settingsInsertIntoModuleId !== undefined) {
            localVarFormParams['settings[insert_into_module_id]'] = ObjectSerializer.serialize(settingsInsertIntoModuleId, "number");
        }

        if (settingsInsertIntoModuleType !== undefined) {
            localVarFormParams['settings[insert_into_module_type]'] = ObjectSerializer.serialize(settingsInsertIntoModuleType, "string");
        }

        if (settingsInsertIntoModulePosition !== undefined) {
            localVarFormParams['settings[insert_into_module_position]'] = ObjectSerializer.serialize(settingsInsertIntoModulePosition, "number");
        }

        if (settingsMoveToAssignmentGroupId !== undefined) {
            localVarFormParams['settings[move_to_assignment_group_id]'] = ObjectSerializer.serialize(settingsMoveToAssignmentGroupId, "number");
        }

        if (settingsImporterSkips !== undefined) {
            localVarFormParams['settings[importer_skips]'] = ObjectSerializer.serialize(settingsImporterSkips, "Array<string>");
        }

        if (settingsImportBlueprintSettings !== undefined) {
            localVarFormParams['settings[import_blueprint_settings]'] = ObjectSerializer.serialize(settingsImportBlueprintSettings, "boolean");
        }

        if (dateShiftOptionsShiftDates !== undefined) {
            localVarFormParams['date_shift_options[shift_dates]'] = ObjectSerializer.serialize(dateShiftOptionsShiftDates, "boolean");
        }

        if (dateShiftOptionsOldStartDate !== undefined) {
            localVarFormParams['date_shift_options[old_start_date]'] = ObjectSerializer.serialize(dateShiftOptionsOldStartDate, "string");
        }

        if (dateShiftOptionsOldEndDate !== undefined) {
            localVarFormParams['date_shift_options[old_end_date]'] = ObjectSerializer.serialize(dateShiftOptionsOldEndDate, "string");
        }

        if (dateShiftOptionsNewStartDate !== undefined) {
            localVarFormParams['date_shift_options[new_start_date]'] = ObjectSerializer.serialize(dateShiftOptionsNewStartDate, "string");
        }

        if (dateShiftOptionsNewEndDate !== undefined) {
            localVarFormParams['date_shift_options[new_end_date]'] = ObjectSerializer.serialize(dateShiftOptionsNewEndDate, "string");
        }

        if (dateShiftOptionsDaySubstitutionsX !== undefined) {
            localVarFormParams['date_shift_options[day_substitutions][X]'] = ObjectSerializer.serialize(dateShiftOptionsDaySubstitutionsX, "number");
        }

        if (dateShiftOptionsRemoveDates !== undefined) {
            localVarFormParams['date_shift_options[remove_dates]'] = ObjectSerializer.serialize(dateShiftOptionsRemoveDates, "boolean");
        }

        if (selectiveImport !== undefined) {
            localVarFormParams['selective_import'] = ObjectSerializer.serialize(selectiveImport, "boolean");
        }

        if (select !== undefined) {
            localVarFormParams['select'] = ObjectSerializer.serialize(select, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ContentMigration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ContentMigration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a content migration. If the migration requires a file to be uploaded the actual processing of the file will start once the file upload process is completed. File uploading works as described in the {file:file_uploads.html File Upload Documentation} except that the values are set on a *pre_attachment* sub-hash.  For migrations that don\'t require a file to be uploaded, like course copy, the processing will begin as soon as the migration is created.  You can use the {api:ProgressController#show Progress API} to track the progress of the migration. The migration\'s progress is linked to with the _progress_url_ value.  The two general workflows are:  If no file upload is needed:  1. POST to create 2. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress  For file uploading:  1. POST to create with file info in *pre_attachment* 2. Do {file:file_uploads.html file upload processing} using the data in the *pre_attachment* data 3. {api:ContentMigrationsController#show GET} the ContentMigration 4. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress   (required if doing .zip file upload)
     * @summary Create a content migration
     * @param groupId ID
     * @param migrationType The type of the migration. Use the {api:ContentMigrationsController#available_migrators Migrator} endpoint to see all available migrators. Default allowed values: canvas_cartridge_importer, common_cartridge_importer, course_copy_importer, zip_file_importer, qti_converter, moodle_converter
     * @param preAttachmentName Required if uploading a file. This is the first step in uploading a file to the content migration. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.
     * @param preAttachment Other file upload properties, See {file:file_uploads.html File Upload Documentation}
     * @param settingsFileUrl A URL to download the file from. Must not require authentication.
     * @param settingsContentExportId The id of a ContentExport to import. This allows you to import content previously exported from Canvas without needing to download and re-upload it.
     * @param settingsSourceCourseId The course to copy from for a course copy migration. (required if doing course copy)
     * @param settingsFolderId The folder to unzip the .zip file into for a zip_file_import.
     * @param settingsOverwriteQuizzes Whether to overwrite quizzes with the same identifiers between content packages.
     * @param settingsQuestionBankId The existing question bank ID to import questions into if not specified in the content package.
     * @param settingsQuestionBankName The question bank to import questions into if not specified in the content package, if both bank id and name are set, id will take precedence.
     * @param settingsInsertIntoModuleId The id of a module in the target course. This will add all imported items (that can be added to a module) to the given module.
     * @param settingsInsertIntoModuleType If provided (and +insert_into_module_id+ is supplied), only add objects of the specified type to the module.
     * @param settingsInsertIntoModulePosition The (1-based) position to insert the imported items into the course (if +insert_into_module_id+ is supplied). If this parameter is omitted, items will be added to the end of the module.
     * @param settingsMoveToAssignmentGroupId The id of an assignment group in the target course. If provided, all imported assignments will be moved to the given assignment group.
     * @param settingsImporterSkips Set of importers to skip, even if otherwise selected by migration settings.
     * @param settingsImportBlueprintSettings Import the \\\&quot;use as blueprint course\\\&quot; setting as well as the list of locked items from the source course or package. The destination course must not be associated with an existing blueprint course and cannot have any student or observer enrollments.
     * @param dateShiftOptionsShiftDates Whether to shift dates in the copied course
     * @param dateShiftOptionsOldStartDate The original start date of the source content/course
     * @param dateShiftOptionsOldEndDate The original end date of the source content/course
     * @param dateShiftOptionsNewStartDate The new start date for the content/course
     * @param dateShiftOptionsNewEndDate The new end date for the source content/course
     * @param dateShiftOptionsDaySubstitutionsX Move anything scheduled for day \\\&#39;X\\\&#39; to the specified day. (0-Sunday, 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
     * @param dateShiftOptionsRemoveDates Whether to remove dates in the copied course. Cannot be used in conjunction with *shift_dates*.
     * @param selectiveImport If set, perform a selective import instead of importing all content. The migration will identify the contents of the package and then stop in the +waiting_for_select+ workflow state. At this point, use the {api:ContentMigrationsController#content_list List items endpoint} to enumerate the contents of the package, identifying the copy parameters for the desired content. Then call the {api:ContentMigrationsController#update Update endpoint} and provide these copy parameters to start the import.
     * @param select For +course_copy_importer+ migrations, this parameter allows you to select the objects to copy without using the +selective_import+ argument and +waiting_for_select+ state as is required for uploaded imports (though that workflow is also supported for course copy migrations). The keys are object types like \\\&#39;files\\\&#39;, \\\&#39;folders\\\&#39;, \\\&#39;pages\\\&#39;, etc. The value for each key is a list of object ids. An id can be an integer or a string. Multiple object types can be selected in the same call.
     */
    public async createContentMigrationGroups (groupId: string, migrationType: string, preAttachmentName?: string, preAttachment?: string, settingsFileUrl?: string, settingsContentExportId?: string, settingsSourceCourseId?: string, settingsFolderId?: string, settingsOverwriteQuizzes?: boolean, settingsQuestionBankId?: number, settingsQuestionBankName?: string, settingsInsertIntoModuleId?: number, settingsInsertIntoModuleType?: string, settingsInsertIntoModulePosition?: number, settingsMoveToAssignmentGroupId?: number, settingsImporterSkips?: Array<string>, settingsImportBlueprintSettings?: boolean, dateShiftOptionsShiftDates?: boolean, dateShiftOptionsOldStartDate?: string, dateShiftOptionsOldEndDate?: string, dateShiftOptionsNewStartDate?: string, dateShiftOptionsNewEndDate?: string, dateShiftOptionsDaySubstitutionsX?: number, dateShiftOptionsRemoveDates?: boolean, selectiveImport?: boolean, select?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ContentMigration;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/content_migrations'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling createContentMigrationGroups.');
        }

        // verify required parameter 'migrationType' is not null or undefined
        if (migrationType === null || migrationType === undefined) {
            throw new Error('Required parameter migrationType was null or undefined when calling createContentMigrationGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (migrationType !== undefined) {
            localVarFormParams['migration_type'] = ObjectSerializer.serialize(migrationType, "string");
        }

        if (preAttachmentName !== undefined) {
            localVarFormParams['pre_attachment[name]'] = ObjectSerializer.serialize(preAttachmentName, "string");
        }

        if (preAttachment !== undefined) {
            localVarFormParams['pre_attachment[*]'] = ObjectSerializer.serialize(preAttachment, "string");
        }

        if (settingsFileUrl !== undefined) {
            localVarFormParams['settings[file_url]'] = ObjectSerializer.serialize(settingsFileUrl, "string");
        }

        if (settingsContentExportId !== undefined) {
            localVarFormParams['settings[content_export_id]'] = ObjectSerializer.serialize(settingsContentExportId, "string");
        }

        if (settingsSourceCourseId !== undefined) {
            localVarFormParams['settings[source_course_id]'] = ObjectSerializer.serialize(settingsSourceCourseId, "string");
        }

        if (settingsFolderId !== undefined) {
            localVarFormParams['settings[folder_id]'] = ObjectSerializer.serialize(settingsFolderId, "string");
        }

        if (settingsOverwriteQuizzes !== undefined) {
            localVarFormParams['settings[overwrite_quizzes]'] = ObjectSerializer.serialize(settingsOverwriteQuizzes, "boolean");
        }

        if (settingsQuestionBankId !== undefined) {
            localVarFormParams['settings[question_bank_id]'] = ObjectSerializer.serialize(settingsQuestionBankId, "number");
        }

        if (settingsQuestionBankName !== undefined) {
            localVarFormParams['settings[question_bank_name]'] = ObjectSerializer.serialize(settingsQuestionBankName, "string");
        }

        if (settingsInsertIntoModuleId !== undefined) {
            localVarFormParams['settings[insert_into_module_id]'] = ObjectSerializer.serialize(settingsInsertIntoModuleId, "number");
        }

        if (settingsInsertIntoModuleType !== undefined) {
            localVarFormParams['settings[insert_into_module_type]'] = ObjectSerializer.serialize(settingsInsertIntoModuleType, "string");
        }

        if (settingsInsertIntoModulePosition !== undefined) {
            localVarFormParams['settings[insert_into_module_position]'] = ObjectSerializer.serialize(settingsInsertIntoModulePosition, "number");
        }

        if (settingsMoveToAssignmentGroupId !== undefined) {
            localVarFormParams['settings[move_to_assignment_group_id]'] = ObjectSerializer.serialize(settingsMoveToAssignmentGroupId, "number");
        }

        if (settingsImporterSkips !== undefined) {
            localVarFormParams['settings[importer_skips]'] = ObjectSerializer.serialize(settingsImporterSkips, "Array<string>");
        }

        if (settingsImportBlueprintSettings !== undefined) {
            localVarFormParams['settings[import_blueprint_settings]'] = ObjectSerializer.serialize(settingsImportBlueprintSettings, "boolean");
        }

        if (dateShiftOptionsShiftDates !== undefined) {
            localVarFormParams['date_shift_options[shift_dates]'] = ObjectSerializer.serialize(dateShiftOptionsShiftDates, "boolean");
        }

        if (dateShiftOptionsOldStartDate !== undefined) {
            localVarFormParams['date_shift_options[old_start_date]'] = ObjectSerializer.serialize(dateShiftOptionsOldStartDate, "string");
        }

        if (dateShiftOptionsOldEndDate !== undefined) {
            localVarFormParams['date_shift_options[old_end_date]'] = ObjectSerializer.serialize(dateShiftOptionsOldEndDate, "string");
        }

        if (dateShiftOptionsNewStartDate !== undefined) {
            localVarFormParams['date_shift_options[new_start_date]'] = ObjectSerializer.serialize(dateShiftOptionsNewStartDate, "string");
        }

        if (dateShiftOptionsNewEndDate !== undefined) {
            localVarFormParams['date_shift_options[new_end_date]'] = ObjectSerializer.serialize(dateShiftOptionsNewEndDate, "string");
        }

        if (dateShiftOptionsDaySubstitutionsX !== undefined) {
            localVarFormParams['date_shift_options[day_substitutions][X]'] = ObjectSerializer.serialize(dateShiftOptionsDaySubstitutionsX, "number");
        }

        if (dateShiftOptionsRemoveDates !== undefined) {
            localVarFormParams['date_shift_options[remove_dates]'] = ObjectSerializer.serialize(dateShiftOptionsRemoveDates, "boolean");
        }

        if (selectiveImport !== undefined) {
            localVarFormParams['selective_import'] = ObjectSerializer.serialize(selectiveImport, "boolean");
        }

        if (select !== undefined) {
            localVarFormParams['select'] = ObjectSerializer.serialize(select, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ContentMigration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ContentMigration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a content migration. If the migration requires a file to be uploaded the actual processing of the file will start once the file upload process is completed. File uploading works as described in the {file:file_uploads.html File Upload Documentation} except that the values are set on a *pre_attachment* sub-hash.  For migrations that don\'t require a file to be uploaded, like course copy, the processing will begin as soon as the migration is created.  You can use the {api:ProgressController#show Progress API} to track the progress of the migration. The migration\'s progress is linked to with the _progress_url_ value.  The two general workflows are:  If no file upload is needed:  1. POST to create 2. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress  For file uploading:  1. POST to create with file info in *pre_attachment* 2. Do {file:file_uploads.html file upload processing} using the data in the *pre_attachment* data 3. {api:ContentMigrationsController#show GET} the ContentMigration 4. Use the {api:ProgressController#show Progress} specified in _progress_url_ to monitor progress   (required if doing .zip file upload)
     * @summary Create a content migration
     * @param userId ID
     * @param migrationType The type of the migration. Use the {api:ContentMigrationsController#available_migrators Migrator} endpoint to see all available migrators. Default allowed values: canvas_cartridge_importer, common_cartridge_importer, course_copy_importer, zip_file_importer, qti_converter, moodle_converter
     * @param preAttachmentName Required if uploading a file. This is the first step in uploading a file to the content migration. See the {file:file_uploads.html File Upload Documentation} for details on the file upload workflow.
     * @param preAttachment Other file upload properties, See {file:file_uploads.html File Upload Documentation}
     * @param settingsFileUrl A URL to download the file from. Must not require authentication.
     * @param settingsContentExportId The id of a ContentExport to import. This allows you to import content previously exported from Canvas without needing to download and re-upload it.
     * @param settingsSourceCourseId The course to copy from for a course copy migration. (required if doing course copy)
     * @param settingsFolderId The folder to unzip the .zip file into for a zip_file_import.
     * @param settingsOverwriteQuizzes Whether to overwrite quizzes with the same identifiers between content packages.
     * @param settingsQuestionBankId The existing question bank ID to import questions into if not specified in the content package.
     * @param settingsQuestionBankName The question bank to import questions into if not specified in the content package, if both bank id and name are set, id will take precedence.
     * @param settingsInsertIntoModuleId The id of a module in the target course. This will add all imported items (that can be added to a module) to the given module.
     * @param settingsInsertIntoModuleType If provided (and +insert_into_module_id+ is supplied), only add objects of the specified type to the module.
     * @param settingsInsertIntoModulePosition The (1-based) position to insert the imported items into the course (if +insert_into_module_id+ is supplied). If this parameter is omitted, items will be added to the end of the module.
     * @param settingsMoveToAssignmentGroupId The id of an assignment group in the target course. If provided, all imported assignments will be moved to the given assignment group.
     * @param settingsImporterSkips Set of importers to skip, even if otherwise selected by migration settings.
     * @param settingsImportBlueprintSettings Import the \\\&quot;use as blueprint course\\\&quot; setting as well as the list of locked items from the source course or package. The destination course must not be associated with an existing blueprint course and cannot have any student or observer enrollments.
     * @param dateShiftOptionsShiftDates Whether to shift dates in the copied course
     * @param dateShiftOptionsOldStartDate The original start date of the source content/course
     * @param dateShiftOptionsOldEndDate The original end date of the source content/course
     * @param dateShiftOptionsNewStartDate The new start date for the content/course
     * @param dateShiftOptionsNewEndDate The new end date for the source content/course
     * @param dateShiftOptionsDaySubstitutionsX Move anything scheduled for day \\\&#39;X\\\&#39; to the specified day. (0-Sunday, 1-Monday, 2-Tuesday, 3-Wednesday, 4-Thursday, 5-Friday, 6-Saturday)
     * @param dateShiftOptionsRemoveDates Whether to remove dates in the copied course. Cannot be used in conjunction with *shift_dates*.
     * @param selectiveImport If set, perform a selective import instead of importing all content. The migration will identify the contents of the package and then stop in the +waiting_for_select+ workflow state. At this point, use the {api:ContentMigrationsController#content_list List items endpoint} to enumerate the contents of the package, identifying the copy parameters for the desired content. Then call the {api:ContentMigrationsController#update Update endpoint} and provide these copy parameters to start the import.
     * @param select For +course_copy_importer+ migrations, this parameter allows you to select the objects to copy without using the +selective_import+ argument and +waiting_for_select+ state as is required for uploaded imports (though that workflow is also supported for course copy migrations). The keys are object types like \\\&#39;files\\\&#39;, \\\&#39;folders\\\&#39;, \\\&#39;pages\\\&#39;, etc. The value for each key is a list of object ids. An id can be an integer or a string. Multiple object types can be selected in the same call.
     */
    public async createContentMigrationUsers (userId: string, migrationType: string, preAttachmentName?: string, preAttachment?: string, settingsFileUrl?: string, settingsContentExportId?: string, settingsSourceCourseId?: string, settingsFolderId?: string, settingsOverwriteQuizzes?: boolean, settingsQuestionBankId?: number, settingsQuestionBankName?: string, settingsInsertIntoModuleId?: number, settingsInsertIntoModuleType?: string, settingsInsertIntoModulePosition?: number, settingsMoveToAssignmentGroupId?: number, settingsImporterSkips?: Array<string>, settingsImportBlueprintSettings?: boolean, dateShiftOptionsShiftDates?: boolean, dateShiftOptionsOldStartDate?: string, dateShiftOptionsOldEndDate?: string, dateShiftOptionsNewStartDate?: string, dateShiftOptionsNewEndDate?: string, dateShiftOptionsDaySubstitutionsX?: number, dateShiftOptionsRemoveDates?: boolean, selectiveImport?: boolean, select?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ContentMigration;  }> {
        const localVarPath = this.basePath + '/v1/users/{user_id}/content_migrations'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling createContentMigrationUsers.');
        }

        // verify required parameter 'migrationType' is not null or undefined
        if (migrationType === null || migrationType === undefined) {
            throw new Error('Required parameter migrationType was null or undefined when calling createContentMigrationUsers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (migrationType !== undefined) {
            localVarFormParams['migration_type'] = ObjectSerializer.serialize(migrationType, "string");
        }

        if (preAttachmentName !== undefined) {
            localVarFormParams['pre_attachment[name]'] = ObjectSerializer.serialize(preAttachmentName, "string");
        }

        if (preAttachment !== undefined) {
            localVarFormParams['pre_attachment[*]'] = ObjectSerializer.serialize(preAttachment, "string");
        }

        if (settingsFileUrl !== undefined) {
            localVarFormParams['settings[file_url]'] = ObjectSerializer.serialize(settingsFileUrl, "string");
        }

        if (settingsContentExportId !== undefined) {
            localVarFormParams['settings[content_export_id]'] = ObjectSerializer.serialize(settingsContentExportId, "string");
        }

        if (settingsSourceCourseId !== undefined) {
            localVarFormParams['settings[source_course_id]'] = ObjectSerializer.serialize(settingsSourceCourseId, "string");
        }

        if (settingsFolderId !== undefined) {
            localVarFormParams['settings[folder_id]'] = ObjectSerializer.serialize(settingsFolderId, "string");
        }

        if (settingsOverwriteQuizzes !== undefined) {
            localVarFormParams['settings[overwrite_quizzes]'] = ObjectSerializer.serialize(settingsOverwriteQuizzes, "boolean");
        }

        if (settingsQuestionBankId !== undefined) {
            localVarFormParams['settings[question_bank_id]'] = ObjectSerializer.serialize(settingsQuestionBankId, "number");
        }

        if (settingsQuestionBankName !== undefined) {
            localVarFormParams['settings[question_bank_name]'] = ObjectSerializer.serialize(settingsQuestionBankName, "string");
        }

        if (settingsInsertIntoModuleId !== undefined) {
            localVarFormParams['settings[insert_into_module_id]'] = ObjectSerializer.serialize(settingsInsertIntoModuleId, "number");
        }

        if (settingsInsertIntoModuleType !== undefined) {
            localVarFormParams['settings[insert_into_module_type]'] = ObjectSerializer.serialize(settingsInsertIntoModuleType, "string");
        }

        if (settingsInsertIntoModulePosition !== undefined) {
            localVarFormParams['settings[insert_into_module_position]'] = ObjectSerializer.serialize(settingsInsertIntoModulePosition, "number");
        }

        if (settingsMoveToAssignmentGroupId !== undefined) {
            localVarFormParams['settings[move_to_assignment_group_id]'] = ObjectSerializer.serialize(settingsMoveToAssignmentGroupId, "number");
        }

        if (settingsImporterSkips !== undefined) {
            localVarFormParams['settings[importer_skips]'] = ObjectSerializer.serialize(settingsImporterSkips, "Array<string>");
        }

        if (settingsImportBlueprintSettings !== undefined) {
            localVarFormParams['settings[import_blueprint_settings]'] = ObjectSerializer.serialize(settingsImportBlueprintSettings, "boolean");
        }

        if (dateShiftOptionsShiftDates !== undefined) {
            localVarFormParams['date_shift_options[shift_dates]'] = ObjectSerializer.serialize(dateShiftOptionsShiftDates, "boolean");
        }

        if (dateShiftOptionsOldStartDate !== undefined) {
            localVarFormParams['date_shift_options[old_start_date]'] = ObjectSerializer.serialize(dateShiftOptionsOldStartDate, "string");
        }

        if (dateShiftOptionsOldEndDate !== undefined) {
            localVarFormParams['date_shift_options[old_end_date]'] = ObjectSerializer.serialize(dateShiftOptionsOldEndDate, "string");
        }

        if (dateShiftOptionsNewStartDate !== undefined) {
            localVarFormParams['date_shift_options[new_start_date]'] = ObjectSerializer.serialize(dateShiftOptionsNewStartDate, "string");
        }

        if (dateShiftOptionsNewEndDate !== undefined) {
            localVarFormParams['date_shift_options[new_end_date]'] = ObjectSerializer.serialize(dateShiftOptionsNewEndDate, "string");
        }

        if (dateShiftOptionsDaySubstitutionsX !== undefined) {
            localVarFormParams['date_shift_options[day_substitutions][X]'] = ObjectSerializer.serialize(dateShiftOptionsDaySubstitutionsX, "number");
        }

        if (dateShiftOptionsRemoveDates !== undefined) {
            localVarFormParams['date_shift_options[remove_dates]'] = ObjectSerializer.serialize(dateShiftOptionsRemoveDates, "boolean");
        }

        if (selectiveImport !== undefined) {
            localVarFormParams['selective_import'] = ObjectSerializer.serialize(selectiveImport, "boolean");
        }

        if (select !== undefined) {
            localVarFormParams['select'] = ObjectSerializer.serialize(select, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ContentMigration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ContentMigration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Given a complete course copy or blueprint import content migration, return a mapping of asset ids from the source course to the destination course that were copied in this migration or an earlier one with the same course pair and migration_type (course copy or blueprint).  The returned object\'s keys are asset types as they appear in API URLs (+announcements+, +assignments+, +discussion_topics+, +files+, +module_items+, +modules+, +pages+, and +quizzes+). The values are a mapping from id in source course to id in destination course for objects of this type.
     * @summary Get asset id mapping
     * @param courseId ID
     * @param id ID
     */
    public async getAssetIdMapping (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/content_migrations/{id}/asset_id_mapping'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getAssetIdMapping.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAssetIdMapping.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns data on an individual content migration
     * @summary Get a content migration
     * @param accountId ID
     * @param id ID
     */
    public async getContentMigrationAccounts (accountId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ContentMigration;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/content_migrations/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getContentMigrationAccounts.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getContentMigrationAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ContentMigration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ContentMigration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns data on an individual content migration
     * @summary Get a content migration
     * @param courseId ID
     * @param id ID
     */
    public async getContentMigrationCourses (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ContentMigration;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/content_migrations/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getContentMigrationCourses.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getContentMigrationCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ContentMigration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ContentMigration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns data on an individual content migration
     * @summary Get a content migration
     * @param groupId ID
     * @param id ID
     */
    public async getContentMigrationGroups (groupId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ContentMigration;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/content_migrations/{id}'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getContentMigrationGroups.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getContentMigrationGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ContentMigration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ContentMigration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns data on an individual content migration
     * @summary Get a content migration
     * @param userId ID
     * @param id ID
     */
    public async getContentMigrationUsers (userId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ContentMigration;  }> {
        const localVarPath = this.basePath + '/v1/users/{user_id}/content_migrations/{id}'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getContentMigrationUsers.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getContentMigrationUsers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ContentMigration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ContentMigration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns data on an individual migration issue
     * @summary Get a migration issue
     * @param accountId ID
     * @param contentMigrationId ID
     * @param id ID
     */
    public async getMigrationIssueAccounts (accountId: string, contentMigrationId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/content_migrations/{content_migration_id}/migration_issues/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'content_migration_id' + '}', encodeURIComponent(String(contentMigrationId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getMigrationIssueAccounts.');
        }

        // verify required parameter 'contentMigrationId' is not null or undefined
        if (contentMigrationId === null || contentMigrationId === undefined) {
            throw new Error('Required parameter contentMigrationId was null or undefined when calling getMigrationIssueAccounts.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getMigrationIssueAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "MigrationIssue");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns data on an individual migration issue
     * @summary Get a migration issue
     * @param courseId ID
     * @param contentMigrationId ID
     * @param id ID
     */
    public async getMigrationIssueCourses (courseId: string, contentMigrationId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'content_migration_id' + '}', encodeURIComponent(String(contentMigrationId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getMigrationIssueCourses.');
        }

        // verify required parameter 'contentMigrationId' is not null or undefined
        if (contentMigrationId === null || contentMigrationId === undefined) {
            throw new Error('Required parameter contentMigrationId was null or undefined when calling getMigrationIssueCourses.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getMigrationIssueCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "MigrationIssue");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns data on an individual migration issue
     * @summary Get a migration issue
     * @param groupId ID
     * @param contentMigrationId ID
     * @param id ID
     */
    public async getMigrationIssueGroups (groupId: string, contentMigrationId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/content_migrations/{content_migration_id}/migration_issues/{id}'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'content_migration_id' + '}', encodeURIComponent(String(contentMigrationId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getMigrationIssueGroups.');
        }

        // verify required parameter 'contentMigrationId' is not null or undefined
        if (contentMigrationId === null || contentMigrationId === undefined) {
            throw new Error('Required parameter contentMigrationId was null or undefined when calling getMigrationIssueGroups.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getMigrationIssueGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "MigrationIssue");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns data on an individual migration issue
     * @summary Get a migration issue
     * @param userId ID
     * @param contentMigrationId ID
     * @param id ID
     */
    public async getMigrationIssueUsers (userId: string, contentMigrationId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }> {
        const localVarPath = this.basePath + '/v1/users/{user_id}/content_migrations/{content_migration_id}/migration_issues/{id}'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)))
            .replace('{' + 'content_migration_id' + '}', encodeURIComponent(String(contentMigrationId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getMigrationIssueUsers.');
        }

        // verify required parameter 'contentMigrationId' is not null or undefined
        if (contentMigrationId === null || contentMigrationId === undefined) {
            throw new Error('Required parameter contentMigrationId was null or undefined when calling getMigrationIssueUsers.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getMigrationIssueUsers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "MigrationIssue");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns paginated content migrations
     * @summary List content migrations
     * @param accountId ID
     */
    public async listContentMigrationsAccounts (accountId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<ContentMigration>;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/content_migrations'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listContentMigrationsAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<ContentMigration>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<ContentMigration>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns paginated content migrations
     * @summary List content migrations
     * @param courseId ID
     */
    public async listContentMigrationsCourses (courseId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<ContentMigration>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/content_migrations'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listContentMigrationsCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<ContentMigration>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<ContentMigration>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns paginated content migrations
     * @summary List content migrations
     * @param groupId ID
     */
    public async listContentMigrationsGroups (groupId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<ContentMigration>;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/content_migrations'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling listContentMigrationsGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<ContentMigration>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<ContentMigration>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns paginated content migrations
     * @summary List content migrations
     * @param userId ID
     */
    public async listContentMigrationsUsers (userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<ContentMigration>;  }> {
        const localVarPath = this.basePath + '/v1/users/{user_id}/content_migrations'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling listContentMigrationsUsers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<ContentMigration>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<ContentMigration>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Enumerates the content available for selective import in a tree structure. Each node provides a +property+ copy argument that can be supplied to the {api:ContentMigrationsController#update Update endpoint} to selectively copy the content associated with that tree node and its children. Each node may also provide a +sub_items_url+ or an array of +sub_items+ which you can use to obtain copy parameters for a subset of the resources in a given node.  If no +type+ is sent you will get a list of the top-level sections in the content. It will look something like this:    [{     \"type\": \"course_settings\",     \"property\": \"copy[all_course_settings]\",     \"title\": \"Course Settings\"   },   {     \"type\": \"context_modules\",     \"property\": \"copy[all_context_modules]\",     \"title\": \"Modules\",     \"count\": 5,     \"sub_items_url\": \"http://example.com/api/v1/courses/22/content_migrations/77/selective_data?type=context_modules\"   },   {     \"type\": \"assignments\",     \"property\": \"copy[all_assignments]\",     \"title\": \"Assignments\",     \"count\": 2,     \"sub_items_url\": \"http://localhost:3000/api/v1/courses/22/content_migrations/77/selective_data?type=assignments\"   }]  When a +type+ is provided, nodes may be further divided via +sub_items+. For example, using +type=assignments+ results in a node for each assignment group and a sub_item for each assignment, like this:    [{     \"type\": \"assignment_groups\",     \"title\": \"An Assignment Group\",     \"property\": \"copy[assignment_groups][id_i855cf145e5acc7435e1bf1c6e2126e5f]\",     \"sub_items\": [{         \"type\": \"assignments\",         \"title\": \"Assignment 1\",         \"property\": \"copy[assignments][id_i2102a7fa93b29226774949298626719d]\"     }, {         \"type\": \"assignments\",         \"title\": \"Assignment 2\",         \"property\": \"copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]\"     }]   }]   To import the items corresponding to a particular tree node, use the +property+ as a parameter to the {api:ContentMigrationsController#update Update endpoint} and assign a value of 1, for example:    copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]=1  You can include multiple copy parameters to selectively import multiple items or groups of items.
     * @summary List items for selective import
     * @param accountId ID
     * @param id ID
     * @param type The type of content to enumerate.
     */
    public async listItemsForSelectiveImportAccounts (accountId: string, id: string, type?: 'context_modules' | 'assignments' | 'quizzes' | 'assessment_question_banks' | 'discussion_topics' | 'wiki_pages' | 'context_external_tools' | 'tool_profiles' | 'announcements' | 'calendar_events' | 'rubrics' | 'groups' | 'learning_outcomes' | 'attachments', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: List of content items;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/content_migrations/{id}/selective_data'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listItemsForSelectiveImportAccounts.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listItemsForSelectiveImportAccounts.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'context_modules' | 'assignments' | 'quizzes' | 'assessment_question_banks' | 'discussion_topics' | 'wiki_pages' | 'context_external_tools' | 'tool_profiles' | 'announcements' | 'calendar_events' | 'rubrics' | 'groups' | 'learning_outcomes' | 'attachments'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: List of content items;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "List of content items");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Enumerates the content available for selective import in a tree structure. Each node provides a +property+ copy argument that can be supplied to the {api:ContentMigrationsController#update Update endpoint} to selectively copy the content associated with that tree node and its children. Each node may also provide a +sub_items_url+ or an array of +sub_items+ which you can use to obtain copy parameters for a subset of the resources in a given node.  If no +type+ is sent you will get a list of the top-level sections in the content. It will look something like this:    [{     \"type\": \"course_settings\",     \"property\": \"copy[all_course_settings]\",     \"title\": \"Course Settings\"   },   {     \"type\": \"context_modules\",     \"property\": \"copy[all_context_modules]\",     \"title\": \"Modules\",     \"count\": 5,     \"sub_items_url\": \"http://example.com/api/v1/courses/22/content_migrations/77/selective_data?type=context_modules\"   },   {     \"type\": \"assignments\",     \"property\": \"copy[all_assignments]\",     \"title\": \"Assignments\",     \"count\": 2,     \"sub_items_url\": \"http://localhost:3000/api/v1/courses/22/content_migrations/77/selective_data?type=assignments\"   }]  When a +type+ is provided, nodes may be further divided via +sub_items+. For example, using +type=assignments+ results in a node for each assignment group and a sub_item for each assignment, like this:    [{     \"type\": \"assignment_groups\",     \"title\": \"An Assignment Group\",     \"property\": \"copy[assignment_groups][id_i855cf145e5acc7435e1bf1c6e2126e5f]\",     \"sub_items\": [{         \"type\": \"assignments\",         \"title\": \"Assignment 1\",         \"property\": \"copy[assignments][id_i2102a7fa93b29226774949298626719d]\"     }, {         \"type\": \"assignments\",         \"title\": \"Assignment 2\",         \"property\": \"copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]\"     }]   }]   To import the items corresponding to a particular tree node, use the +property+ as a parameter to the {api:ContentMigrationsController#update Update endpoint} and assign a value of 1, for example:    copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]=1  You can include multiple copy parameters to selectively import multiple items or groups of items.
     * @summary List items for selective import
     * @param courseId ID
     * @param id ID
     * @param type The type of content to enumerate.
     */
    public async listItemsForSelectiveImportCourses (courseId: string, id: string, type?: 'context_modules' | 'assignments' | 'quizzes' | 'assessment_question_banks' | 'discussion_topics' | 'wiki_pages' | 'context_external_tools' | 'tool_profiles' | 'announcements' | 'calendar_events' | 'rubrics' | 'groups' | 'learning_outcomes' | 'attachments', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: List of content items;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/content_migrations/{id}/selective_data'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listItemsForSelectiveImportCourses.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listItemsForSelectiveImportCourses.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'context_modules' | 'assignments' | 'quizzes' | 'assessment_question_banks' | 'discussion_topics' | 'wiki_pages' | 'context_external_tools' | 'tool_profiles' | 'announcements' | 'calendar_events' | 'rubrics' | 'groups' | 'learning_outcomes' | 'attachments'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: List of content items;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "List of content items");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Enumerates the content available for selective import in a tree structure. Each node provides a +property+ copy argument that can be supplied to the {api:ContentMigrationsController#update Update endpoint} to selectively copy the content associated with that tree node and its children. Each node may also provide a +sub_items_url+ or an array of +sub_items+ which you can use to obtain copy parameters for a subset of the resources in a given node.  If no +type+ is sent you will get a list of the top-level sections in the content. It will look something like this:    [{     \"type\": \"course_settings\",     \"property\": \"copy[all_course_settings]\",     \"title\": \"Course Settings\"   },   {     \"type\": \"context_modules\",     \"property\": \"copy[all_context_modules]\",     \"title\": \"Modules\",     \"count\": 5,     \"sub_items_url\": \"http://example.com/api/v1/courses/22/content_migrations/77/selective_data?type=context_modules\"   },   {     \"type\": \"assignments\",     \"property\": \"copy[all_assignments]\",     \"title\": \"Assignments\",     \"count\": 2,     \"sub_items_url\": \"http://localhost:3000/api/v1/courses/22/content_migrations/77/selective_data?type=assignments\"   }]  When a +type+ is provided, nodes may be further divided via +sub_items+. For example, using +type=assignments+ results in a node for each assignment group and a sub_item for each assignment, like this:    [{     \"type\": \"assignment_groups\",     \"title\": \"An Assignment Group\",     \"property\": \"copy[assignment_groups][id_i855cf145e5acc7435e1bf1c6e2126e5f]\",     \"sub_items\": [{         \"type\": \"assignments\",         \"title\": \"Assignment 1\",         \"property\": \"copy[assignments][id_i2102a7fa93b29226774949298626719d]\"     }, {         \"type\": \"assignments\",         \"title\": \"Assignment 2\",         \"property\": \"copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]\"     }]   }]   To import the items corresponding to a particular tree node, use the +property+ as a parameter to the {api:ContentMigrationsController#update Update endpoint} and assign a value of 1, for example:    copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]=1  You can include multiple copy parameters to selectively import multiple items or groups of items.
     * @summary List items for selective import
     * @param groupId ID
     * @param id ID
     * @param type The type of content to enumerate.
     */
    public async listItemsForSelectiveImportGroups (groupId: string, id: string, type?: 'context_modules' | 'assignments' | 'quizzes' | 'assessment_question_banks' | 'discussion_topics' | 'wiki_pages' | 'context_external_tools' | 'tool_profiles' | 'announcements' | 'calendar_events' | 'rubrics' | 'groups' | 'learning_outcomes' | 'attachments', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: List of content items;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/content_migrations/{id}/selective_data'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling listItemsForSelectiveImportGroups.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listItemsForSelectiveImportGroups.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'context_modules' | 'assignments' | 'quizzes' | 'assessment_question_banks' | 'discussion_topics' | 'wiki_pages' | 'context_external_tools' | 'tool_profiles' | 'announcements' | 'calendar_events' | 'rubrics' | 'groups' | 'learning_outcomes' | 'attachments'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: List of content items;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "List of content items");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Enumerates the content available for selective import in a tree structure. Each node provides a +property+ copy argument that can be supplied to the {api:ContentMigrationsController#update Update endpoint} to selectively copy the content associated with that tree node and its children. Each node may also provide a +sub_items_url+ or an array of +sub_items+ which you can use to obtain copy parameters for a subset of the resources in a given node.  If no +type+ is sent you will get a list of the top-level sections in the content. It will look something like this:    [{     \"type\": \"course_settings\",     \"property\": \"copy[all_course_settings]\",     \"title\": \"Course Settings\"   },   {     \"type\": \"context_modules\",     \"property\": \"copy[all_context_modules]\",     \"title\": \"Modules\",     \"count\": 5,     \"sub_items_url\": \"http://example.com/api/v1/courses/22/content_migrations/77/selective_data?type=context_modules\"   },   {     \"type\": \"assignments\",     \"property\": \"copy[all_assignments]\",     \"title\": \"Assignments\",     \"count\": 2,     \"sub_items_url\": \"http://localhost:3000/api/v1/courses/22/content_migrations/77/selective_data?type=assignments\"   }]  When a +type+ is provided, nodes may be further divided via +sub_items+. For example, using +type=assignments+ results in a node for each assignment group and a sub_item for each assignment, like this:    [{     \"type\": \"assignment_groups\",     \"title\": \"An Assignment Group\",     \"property\": \"copy[assignment_groups][id_i855cf145e5acc7435e1bf1c6e2126e5f]\",     \"sub_items\": [{         \"type\": \"assignments\",         \"title\": \"Assignment 1\",         \"property\": \"copy[assignments][id_i2102a7fa93b29226774949298626719d]\"     }, {         \"type\": \"assignments\",         \"title\": \"Assignment 2\",         \"property\": \"copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]\"     }]   }]   To import the items corresponding to a particular tree node, use the +property+ as a parameter to the {api:ContentMigrationsController#update Update endpoint} and assign a value of 1, for example:    copy[assignments][id_i310cba275dc3f4aa8a3306bbbe380979]=1  You can include multiple copy parameters to selectively import multiple items or groups of items.
     * @summary List items for selective import
     * @param userId ID
     * @param id ID
     * @param type The type of content to enumerate.
     */
    public async listItemsForSelectiveImportUsers (userId: string, id: string, type?: 'context_modules' | 'assignments' | 'quizzes' | 'assessment_question_banks' | 'discussion_topics' | 'wiki_pages' | 'context_external_tools' | 'tool_profiles' | 'announcements' | 'calendar_events' | 'rubrics' | 'groups' | 'learning_outcomes' | 'attachments', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: List of content items;  }> {
        const localVarPath = this.basePath + '/v1/users/{user_id}/content_migrations/{id}/selective_data'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling listItemsForSelectiveImportUsers.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listItemsForSelectiveImportUsers.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'context_modules' | 'assignments' | 'quizzes' | 'assessment_question_banks' | 'discussion_topics' | 'wiki_pages' | 'context_external_tools' | 'tool_profiles' | 'announcements' | 'calendar_events' | 'rubrics' | 'groups' | 'learning_outcomes' | 'attachments'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: List of content items;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "List of content items");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns paginated migration issues
     * @summary List migration issues
     * @param accountId ID
     * @param contentMigrationId ID
     */
    public async listMigrationIssuesAccounts (accountId: string, contentMigrationId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<MigrationIssue>;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/content_migrations/{content_migration_id}/migration_issues'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'content_migration_id' + '}', encodeURIComponent(String(contentMigrationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listMigrationIssuesAccounts.');
        }

        // verify required parameter 'contentMigrationId' is not null or undefined
        if (contentMigrationId === null || contentMigrationId === undefined) {
            throw new Error('Required parameter contentMigrationId was null or undefined when calling listMigrationIssuesAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<MigrationIssue>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<MigrationIssue>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns paginated migration issues
     * @summary List migration issues
     * @param courseId ID
     * @param contentMigrationId ID
     */
    public async listMigrationIssuesCourses (courseId: string, contentMigrationId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<MigrationIssue>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'content_migration_id' + '}', encodeURIComponent(String(contentMigrationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listMigrationIssuesCourses.');
        }

        // verify required parameter 'contentMigrationId' is not null or undefined
        if (contentMigrationId === null || contentMigrationId === undefined) {
            throw new Error('Required parameter contentMigrationId was null or undefined when calling listMigrationIssuesCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<MigrationIssue>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<MigrationIssue>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns paginated migration issues
     * @summary List migration issues
     * @param groupId ID
     * @param contentMigrationId ID
     */
    public async listMigrationIssuesGroups (groupId: string, contentMigrationId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<MigrationIssue>;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/content_migrations/{content_migration_id}/migration_issues'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'content_migration_id' + '}', encodeURIComponent(String(contentMigrationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling listMigrationIssuesGroups.');
        }

        // verify required parameter 'contentMigrationId' is not null or undefined
        if (contentMigrationId === null || contentMigrationId === undefined) {
            throw new Error('Required parameter contentMigrationId was null or undefined when calling listMigrationIssuesGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<MigrationIssue>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<MigrationIssue>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns paginated migration issues
     * @summary List migration issues
     * @param userId ID
     * @param contentMigrationId ID
     */
    public async listMigrationIssuesUsers (userId: string, contentMigrationId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<MigrationIssue>;  }> {
        const localVarPath = this.basePath + '/v1/users/{user_id}/content_migrations/{content_migration_id}/migration_issues'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)))
            .replace('{' + 'content_migration_id' + '}', encodeURIComponent(String(contentMigrationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling listMigrationIssuesUsers.');
        }

        // verify required parameter 'contentMigrationId' is not null or undefined
        if (contentMigrationId === null || contentMigrationId === undefined) {
            throw new Error('Required parameter contentMigrationId was null or undefined when calling listMigrationIssuesUsers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<MigrationIssue>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<MigrationIssue>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Lists the currently available migration types. These values may change.
     * @summary List Migration Systems
     * @param accountId ID
     */
    public async listMigrationSystemsAccounts (accountId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Migrator>;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/content_migrations/migrators'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listMigrationSystemsAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Migrator>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Migrator>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Lists the currently available migration types. These values may change.
     * @summary List Migration Systems
     * @param courseId ID
     */
    public async listMigrationSystemsCourses (courseId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Migrator>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/content_migrations/migrators'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listMigrationSystemsCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Migrator>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Migrator>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Lists the currently available migration types. These values may change.
     * @summary List Migration Systems
     * @param groupId ID
     */
    public async listMigrationSystemsGroups (groupId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Migrator>;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/content_migrations/migrators'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling listMigrationSystemsGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Migrator>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Migrator>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Lists the currently available migration types. These values may change.
     * @summary List Migration Systems
     * @param userId ID
     */
    public async listMigrationSystemsUsers (userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Migrator>;  }> {
        const localVarPath = this.basePath + '/v1/users/{user_id}/content_migrations/migrators'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling listMigrationSystemsUsers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Migrator>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Migrator>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update a content migration. Takes same arguments as {api:ContentMigrationsController#create create} except that you can\'t change the migration type. However, changing most settings after the migration process has started will not do anything. Generally updating the content migration will be used when there is a file upload problem, or when importing content selectively. If the first upload has a problem you can supply new _pre_attachment_ values to start the process again.
     * @summary Update a content migration
     * @param accountId ID
     * @param id ID
     */
    public async updateContentMigrationAccounts (accountId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ContentMigration;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/content_migrations/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateContentMigrationAccounts.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateContentMigrationAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ContentMigration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ContentMigration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update a content migration. Takes same arguments as {api:ContentMigrationsController#create create} except that you can\'t change the migration type. However, changing most settings after the migration process has started will not do anything. Generally updating the content migration will be used when there is a file upload problem, or when importing content selectively. If the first upload has a problem you can supply new _pre_attachment_ values to start the process again.
     * @summary Update a content migration
     * @param courseId ID
     * @param id ID
     */
    public async updateContentMigrationCourses (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ContentMigration;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/content_migrations/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateContentMigrationCourses.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateContentMigrationCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ContentMigration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ContentMigration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update a content migration. Takes same arguments as {api:ContentMigrationsController#create create} except that you can\'t change the migration type. However, changing most settings after the migration process has started will not do anything. Generally updating the content migration will be used when there is a file upload problem, or when importing content selectively. If the first upload has a problem you can supply new _pre_attachment_ values to start the process again.
     * @summary Update a content migration
     * @param groupId ID
     * @param id ID
     */
    public async updateContentMigrationGroups (groupId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ContentMigration;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/content_migrations/{id}'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling updateContentMigrationGroups.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateContentMigrationGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ContentMigration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ContentMigration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update a content migration. Takes same arguments as {api:ContentMigrationsController#create create} except that you can\'t change the migration type. However, changing most settings after the migration process has started will not do anything. Generally updating the content migration will be used when there is a file upload problem, or when importing content selectively. If the first upload has a problem you can supply new _pre_attachment_ values to start the process again.
     * @summary Update a content migration
     * @param userId ID
     * @param id ID
     */
    public async updateContentMigrationUsers (userId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ContentMigration;  }> {
        const localVarPath = this.basePath + '/v1/users/{user_id}/content_migrations/{id}'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateContentMigrationUsers.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateContentMigrationUsers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ContentMigration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ContentMigration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the workflow_state of a migration issue
     * @summary Update a migration issue
     * @param accountId ID
     * @param contentMigrationId ID
     * @param id ID
     * @param workflowState Set the workflow_state of the issue.
     */
    public async updateMigrationIssueAccounts (accountId: string, contentMigrationId: string, id: string, workflowState: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/content_migrations/{content_migration_id}/migration_issues/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'content_migration_id' + '}', encodeURIComponent(String(contentMigrationId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateMigrationIssueAccounts.');
        }

        // verify required parameter 'contentMigrationId' is not null or undefined
        if (contentMigrationId === null || contentMigrationId === undefined) {
            throw new Error('Required parameter contentMigrationId was null or undefined when calling updateMigrationIssueAccounts.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateMigrationIssueAccounts.');
        }

        // verify required parameter 'workflowState' is not null or undefined
        if (workflowState === null || workflowState === undefined) {
            throw new Error('Required parameter workflowState was null or undefined when calling updateMigrationIssueAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (workflowState !== undefined) {
            localVarFormParams['workflow_state'] = ObjectSerializer.serialize(workflowState, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "MigrationIssue");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the workflow_state of a migration issue
     * @summary Update a migration issue
     * @param courseId ID
     * @param contentMigrationId ID
     * @param id ID
     * @param workflowState Set the workflow_state of the issue.
     */
    public async updateMigrationIssueCourses (courseId: string, contentMigrationId: string, id: string, workflowState: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'content_migration_id' + '}', encodeURIComponent(String(contentMigrationId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateMigrationIssueCourses.');
        }

        // verify required parameter 'contentMigrationId' is not null or undefined
        if (contentMigrationId === null || contentMigrationId === undefined) {
            throw new Error('Required parameter contentMigrationId was null or undefined when calling updateMigrationIssueCourses.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateMigrationIssueCourses.');
        }

        // verify required parameter 'workflowState' is not null or undefined
        if (workflowState === null || workflowState === undefined) {
            throw new Error('Required parameter workflowState was null or undefined when calling updateMigrationIssueCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (workflowState !== undefined) {
            localVarFormParams['workflow_state'] = ObjectSerializer.serialize(workflowState, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "MigrationIssue");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the workflow_state of a migration issue
     * @summary Update a migration issue
     * @param groupId ID
     * @param contentMigrationId ID
     * @param id ID
     * @param workflowState Set the workflow_state of the issue.
     */
    public async updateMigrationIssueGroups (groupId: string, contentMigrationId: string, id: string, workflowState: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/content_migrations/{content_migration_id}/migration_issues/{id}'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'content_migration_id' + '}', encodeURIComponent(String(contentMigrationId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling updateMigrationIssueGroups.');
        }

        // verify required parameter 'contentMigrationId' is not null or undefined
        if (contentMigrationId === null || contentMigrationId === undefined) {
            throw new Error('Required parameter contentMigrationId was null or undefined when calling updateMigrationIssueGroups.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateMigrationIssueGroups.');
        }

        // verify required parameter 'workflowState' is not null or undefined
        if (workflowState === null || workflowState === undefined) {
            throw new Error('Required parameter workflowState was null or undefined when calling updateMigrationIssueGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (workflowState !== undefined) {
            localVarFormParams['workflow_state'] = ObjectSerializer.serialize(workflowState, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "MigrationIssue");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the workflow_state of a migration issue
     * @summary Update a migration issue
     * @param userId ID
     * @param contentMigrationId ID
     * @param id ID
     * @param workflowState Set the workflow_state of the issue.
     */
    public async updateMigrationIssueUsers (userId: string, contentMigrationId: string, id: string, workflowState: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }> {
        const localVarPath = this.basePath + '/v1/users/{user_id}/content_migrations/{content_migration_id}/migration_issues/{id}'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)))
            .replace('{' + 'content_migration_id' + '}', encodeURIComponent(String(contentMigrationId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateMigrationIssueUsers.');
        }

        // verify required parameter 'contentMigrationId' is not null or undefined
        if (contentMigrationId === null || contentMigrationId === undefined) {
            throw new Error('Required parameter contentMigrationId was null or undefined when calling updateMigrationIssueUsers.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateMigrationIssueUsers.');
        }

        // verify required parameter 'workflowState' is not null or undefined
        if (workflowState === null || workflowState === undefined) {
            throw new Error('Required parameter workflowState was null or undefined when calling updateMigrationIssueUsers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (workflowState !== undefined) {
            localVarFormParams['workflow_state'] = ObjectSerializer.serialize(workflowState, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: MigrationIssue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "MigrationIssue");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
