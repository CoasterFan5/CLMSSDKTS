/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { AssignmentGroup } from '../model/assignmentGroup';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum AssignmentGroupsApiApiKeys {
}

export class AssignmentGroupsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: AssignmentGroupsApiApiKeys, value: string) {
        (this.authentications as any)[AssignmentGroupsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create a new assignment group for this course.
     * @summary Create an Assignment Group
     * @param courseId ID
     * @param name The assignment group\\\&#39;s name
     * @param position The position of this assignment group in relation to the other assignment groups
     * @param groupWeight The percent of the total grade that this assignment group represents
     * @param sisSourceId The sis source id of the Assignment Group
     * @param integrationData The integration data of the Assignment Group
     */
    public async createAssignmentGroup (courseId: string, name?: string, position?: number, groupWeight?: number, sisSourceId?: string, integrationData?: object, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AssignmentGroup;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignment_groups'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createAssignmentGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (position !== undefined) {
            localVarFormParams['position'] = ObjectSerializer.serialize(position, "number");
        }

        if (groupWeight !== undefined) {
            localVarFormParams['group_weight'] = ObjectSerializer.serialize(groupWeight, "number");
        }

        if (sisSourceId !== undefined) {
            localVarFormParams['sis_source_id'] = ObjectSerializer.serialize(sisSourceId, "string");
        }

        if (integrationData !== undefined) {
            localVarFormParams['integration_data'] = ObjectSerializer.serialize(integrationData, "object");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AssignmentGroup;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AssignmentGroup");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes the assignment group with the given id.
     * @summary Destroy an Assignment Group
     * @param courseId ID
     * @param assignmentGroupId ID
     * @param moveAssignmentsTo The ID of an active Assignment Group to which the assignments that are currently assigned to the destroyed Assignment Group will be assigned. NOTE: If this argument is not provided, any assignments in this Assignment Group will be deleted.
     */
    public async destroyAssignmentGroup (courseId: string, assignmentGroupId: string, moveAssignmentsTo?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AssignmentGroup;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignment_groups/{assignment_group_id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_group_id' + '}', encodeURIComponent(String(assignmentGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling destroyAssignmentGroup.');
        }

        // verify required parameter 'assignmentGroupId' is not null or undefined
        if (assignmentGroupId === null || assignmentGroupId === undefined) {
            throw new Error('Required parameter assignmentGroupId was null or undefined when calling destroyAssignmentGroup.');
        }

        if (moveAssignmentsTo !== undefined) {
            localVarQueryParameters['move_assignments_to'] = ObjectSerializer.serialize(moveAssignmentsTo, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AssignmentGroup;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AssignmentGroup");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Modify an existing Assignment Group.
     * @summary Edit an Assignment Group
     * @param courseId ID
     * @param assignmentGroupId ID
     * @param name The assignment group\\\&#39;s name
     * @param position The position of this assignment group in relation to the other assignment groups
     * @param groupWeight The percent of the total grade that this assignment group represents
     * @param sisSourceId The sis source id of the Assignment Group
     * @param integrationData The integration data of the Assignment Group
     * @param rules The grading rules that are applied within this assignment group See the Assignment Group object definition for format
     */
    public async editAssignmentGroup (courseId: string, assignmentGroupId: string, name?: string, position?: number, groupWeight?: number, sisSourceId?: string, integrationData?: object, rules?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AssignmentGroup;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignment_groups/{assignment_group_id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_group_id' + '}', encodeURIComponent(String(assignmentGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling editAssignmentGroup.');
        }

        // verify required parameter 'assignmentGroupId' is not null or undefined
        if (assignmentGroupId === null || assignmentGroupId === undefined) {
            throw new Error('Required parameter assignmentGroupId was null or undefined when calling editAssignmentGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (position !== undefined) {
            localVarFormParams['position'] = ObjectSerializer.serialize(position, "number");
        }

        if (groupWeight !== undefined) {
            localVarFormParams['group_weight'] = ObjectSerializer.serialize(groupWeight, "number");
        }

        if (sisSourceId !== undefined) {
            localVarFormParams['sis_source_id'] = ObjectSerializer.serialize(sisSourceId, "string");
        }

        if (integrationData !== undefined) {
            localVarFormParams['integration_data'] = ObjectSerializer.serialize(integrationData, "object");
        }

        if (rules !== undefined) {
            localVarFormParams['rules'] = ObjectSerializer.serialize(rules, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AssignmentGroup;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AssignmentGroup");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the assignment group with the given id.
     * @summary Get an Assignment Group
     * @param courseId ID
     * @param assignmentGroupId ID
     * @param include Associations to include with the group. \&quot;discussion_topic\&quot; and \&quot;assignment_visibility\&quot; and \&quot;submission\&quot; are only valid if \&quot;assignments\&quot; is also included. \&quot;score_statistics\&quot; is only valid if \&quot;submission\&quot; and \&quot;assignments\&quot; are also included. The \&quot;assignment_visibility\&quot; option additionally requires that the Differentiated Assignments course feature be turned on.
     * @param overrideAssignmentDates Apply assignment overrides for each assignment, defaults to true.
     * @param gradingPeriodId The id of the grading period in which assignment groups are being requested (Requires grading periods to exist on the account)
     */
    public async getAssignmentGroup (courseId: string, assignmentGroupId: string, include?: Array<string>, overrideAssignmentDates?: boolean, gradingPeriodId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AssignmentGroup;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignment_groups/{assignment_group_id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_group_id' + '}', encodeURIComponent(String(assignmentGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getAssignmentGroup.');
        }

        // verify required parameter 'assignmentGroupId' is not null or undefined
        if (assignmentGroupId === null || assignmentGroupId === undefined) {
            throw new Error('Required parameter assignmentGroupId was null or undefined when calling getAssignmentGroup.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (overrideAssignmentDates !== undefined) {
            localVarQueryParameters['override_assignment_dates'] = ObjectSerializer.serialize(overrideAssignmentDates, "boolean");
        }

        if (gradingPeriodId !== undefined) {
            localVarQueryParameters['grading_period_id'] = ObjectSerializer.serialize(gradingPeriodId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AssignmentGroup;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AssignmentGroup");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the paginated list of assignment groups for the current context. The returned groups are sorted by their position field.
     * @summary List assignment groups
     * @param courseId ID
     * @param include Associations to include with the group. \&quot;discussion_topic\&quot;, \&quot;all_dates\&quot;, \&quot;can_edit\&quot;, \&quot;assignment_visibility\&quot; &amp; \&quot;submission\&quot; are only valid if \&quot;assignments\&quot; is also included. \&quot;score_statistics\&quot; requires that the \&quot;assignments\&quot; and \&quot;submission\&quot; options are included. The \&quot;assignment_visibility\&quot; option additionally requires that the Differentiated Assignments course feature be turned on. If \&quot;observed_users\&quot; is passed along with \&quot;assignments\&quot; and \&quot;submission\&quot;, submissions for observed users will also be included as an array.
     * @param assignmentIds If \&quot;assignments\&quot; are included, optionally return only assignments having their ID in this array. This argument may also be passed as a comma separated string.
     * @param excludeAssignmentSubmissionTypes If \&quot;assignments\&quot; are included, those with the specified submission types will be excluded from the assignment groups.
     * @param overrideAssignmentDates Apply assignment overrides for each assignment, defaults to true.
     * @param gradingPeriodId The id of the grading period in which assignment groups are being requested (Requires grading periods to exist.)
     * @param scopeAssignmentsToStudent If true, all assignments returned will apply to the current user in the specified grading period. If assignments apply to other students in the specified grading period, but not the current user, they will not be returned. (Requires the grading_period_id argument and grading periods to exist. In addition, the current user must be a student.)
     */
    public async listAssignmentGroups (courseId: string, include?: Array<string>, assignmentIds?: Array<string>, excludeAssignmentSubmissionTypes?: Array<string>, overrideAssignmentDates?: boolean, gradingPeriodId?: number, scopeAssignmentsToStudent?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<AssignmentGroup>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignment_groups'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listAssignmentGroups.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (assignmentIds !== undefined) {
            localVarQueryParameters['assignment_ids'] = ObjectSerializer.serialize(assignmentIds, "Array<string>");
        }

        if (excludeAssignmentSubmissionTypes !== undefined) {
            localVarQueryParameters['exclude_assignment_submission_types'] = ObjectSerializer.serialize(excludeAssignmentSubmissionTypes, "Array<string>");
        }

        if (overrideAssignmentDates !== undefined) {
            localVarQueryParameters['override_assignment_dates'] = ObjectSerializer.serialize(overrideAssignmentDates, "boolean");
        }

        if (gradingPeriodId !== undefined) {
            localVarQueryParameters['grading_period_id'] = ObjectSerializer.serialize(gradingPeriodId, "number");
        }

        if (scopeAssignmentsToStudent !== undefined) {
            localVarQueryParameters['scope_assignments_to_student'] = ObjectSerializer.serialize(scopeAssignmentsToStudent, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<AssignmentGroup>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<AssignmentGroup>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
