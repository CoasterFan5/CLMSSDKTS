/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { ResultUrlStringTheurltotheresultthatwascreated } from '../model/resultUrlStringTheurltotheresultthatwascreated';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ScoreApiApiKeys {
}

export class ScoreApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ScoreApiApiKeys, value: string) {
        (this.authentications as any)[ScoreApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create a new Result from the score params. If this is for the first created line_item for a resourceLinkId, or it is a line item that is not attached to a resourceLinkId, then a submission record will be created for the associated assignment when gradingProgress is set to FullyGraded or PendingManual.  The submission score will also be updated when a score object is sent with either of those two values for gradingProgress. If a score object is sent with either of FullyGraded or PendingManual as the value for gradingProgress and scoreGiven is missing, the assignment will not be graded. This also supposes the line_item meets the condition to create a submission.  A submission comment with an unknown author will be created when the comment value is included. This also supposes the line_item meets the condition to create a submission.  It is also possible to submit a file along with this score, which will attach the file to the submission that is created. Files should be formatted as Content Items, with the correct syntax below.  Returns a url pointing to the Result. If any files were submitted, also returns the Content Items which were sent in the request, each with a url pointing to the Progress of the file upload.
     * @summary Create a Score
     * @param courseId ID
     * @param lineItemId ID
     * @param userId The lti_user_id or the Canvas user_id. Returns a 422 if user not found in Canvas or is not a student.
     * @param activityProgress Indicate to Canvas the status of the user towards the activity\\\&#39;s completion. Must be one of Initialized, Started, InProgress, Submitted, Completed.
     * @param gradingProgress Indicate to Canvas the status of the grading process. A value of PendingManual will require intervention by a grader. Values of NotReady, Failed, and Pending will cause the scoreGiven to be ignored. FullyGraded values will require no action. Possible values are NotReady, Failed, Pending, PendingManual, FullyGraded.
     * @param timestamp Date and time when the score was modified in the tool. Should use ISO8601-formatted date with subsecond precision. Returns a 400 if the timestamp is earlier than the updated_at time of the Result.
     * @param scoreGiven The Current score received in the tool for this line item and user, scaled to the scoreMaximum
     * @param scoreMaximum Maximum possible score for this result; it must be present if scoreGiven is present. Returns 422 if not present when scoreGiven is present.
     * @param comment Comment visible to the student about this score.
     * @param submission Contains metadata about the submission attempt. Supported fields listed below.
     * @param submissionSubmittedAt Date and time that the submission was originally created. Should use ISO8601-formatted date with subsecond precision.
     * @param httpsCanvasInstructureComLtiSubmission (EXTENSION) Optional submission type and data. Fields listed below.
     * @param httpsCanvasInstructureComLtiSubmissionNewSubmission (EXTENSION field) flag to indicate that this is a new submission. Defaults to true unless submission_type is none.
     * @param httpsCanvasInstructureComLtiSubmissionPreserveScore (EXTENSION field) flag to prevent a request from clearing an existing grade for a submission. Defaults to false.
     * @param httpsCanvasInstructureComLtiSubmissionPrioritizeNonToolGrade (EXTENSION field) flag to prevent a request from overwriting an existing grade for a submission. Defaults to false.
     * @param httpsCanvasInstructureComLtiSubmissionSubmissionType (EXTENSION field) permissible values are: none, basic_lti_launch, online_text_entry, external_tool, online_upload, or online_url. Defaults to external_tool. Ignored if content_items are provided.
     * @param httpsCanvasInstructureComLtiSubmissionSubmissionData (EXTENSION field) submission data (URL or body text). Only used for submission_types basic_lti_launch, online_text_entry, online_url. Ignored if content_items are provided.
     * @param httpsCanvasInstructureComLtiSubmissionSubmittedAt (EXTENSION field) Date and time that the submission was originally created. Should use ISO8601-formatted date with subsecond precision. This should match the date and time that the original submission happened in Canvas. Use of submission.submittedAt is preferred.
     * @param httpsCanvasInstructureComLtiSubmissionContentItems (EXTENSION field) Files that should be included with the submission. Each item should contain &#x60;type: file&#x60;, and a url pointing to the file. It can also contain a title, and an explicit MIME type if needed (otherwise, MIME type will be inferred from the title or url). If any items are present, submission_type will be online_upload.
     */
    public async createScore (courseId: string, lineItemId: string, userId: string, activityProgress: string, gradingProgress: string, timestamp: string, scoreGiven?: number, scoreMaximum?: number, comment?: string, submission?: object, submissionSubmittedAt?: string, httpsCanvasInstructureComLtiSubmission?: object, httpsCanvasInstructureComLtiSubmissionNewSubmission?: boolean, httpsCanvasInstructureComLtiSubmissionPreserveScore?: boolean, httpsCanvasInstructureComLtiSubmissionPrioritizeNonToolGrade?: boolean, httpsCanvasInstructureComLtiSubmissionSubmissionType?: string, httpsCanvasInstructureComLtiSubmissionSubmissionData?: string, httpsCanvasInstructureComLtiSubmissionSubmittedAt?: string, httpsCanvasInstructureComLtiSubmissionContentItems?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<ResultUrl String The url to the result that was created>;  }> {
        const localVarPath = this.basePath + '/lti/courses/{course_id}/line_items/{line_item_id}/scores'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'line_item_id' + '}', encodeURIComponent(String(lineItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createScore.');
        }

        // verify required parameter 'lineItemId' is not null or undefined
        if (lineItemId === null || lineItemId === undefined) {
            throw new Error('Required parameter lineItemId was null or undefined when calling createScore.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling createScore.');
        }

        // verify required parameter 'activityProgress' is not null or undefined
        if (activityProgress === null || activityProgress === undefined) {
            throw new Error('Required parameter activityProgress was null or undefined when calling createScore.');
        }

        // verify required parameter 'gradingProgress' is not null or undefined
        if (gradingProgress === null || gradingProgress === undefined) {
            throw new Error('Required parameter gradingProgress was null or undefined when calling createScore.');
        }

        // verify required parameter 'timestamp' is not null or undefined
        if (timestamp === null || timestamp === undefined) {
            throw new Error('Required parameter timestamp was null or undefined when calling createScore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (userId !== undefined) {
            localVarFormParams['userId'] = ObjectSerializer.serialize(userId, "string");
        }

        if (activityProgress !== undefined) {
            localVarFormParams['activityProgress'] = ObjectSerializer.serialize(activityProgress, "string");
        }

        if (gradingProgress !== undefined) {
            localVarFormParams['gradingProgress'] = ObjectSerializer.serialize(gradingProgress, "string");
        }

        if (timestamp !== undefined) {
            localVarFormParams['timestamp'] = ObjectSerializer.serialize(timestamp, "string");
        }

        if (scoreGiven !== undefined) {
            localVarFormParams['scoreGiven'] = ObjectSerializer.serialize(scoreGiven, "number");
        }

        if (scoreMaximum !== undefined) {
            localVarFormParams['scoreMaximum'] = ObjectSerializer.serialize(scoreMaximum, "number");
        }

        if (comment !== undefined) {
            localVarFormParams['comment'] = ObjectSerializer.serialize(comment, "string");
        }

        if (submission !== undefined) {
            localVarFormParams['submission'] = ObjectSerializer.serialize(submission, "object");
        }

        if (submissionSubmittedAt !== undefined) {
            localVarFormParams['submission[submittedAt]'] = ObjectSerializer.serialize(submissionSubmittedAt, "string");
        }

        if (httpsCanvasInstructureComLtiSubmission !== undefined) {
            localVarFormParams['https://canvas.instructure.com/lti/submission'] = ObjectSerializer.serialize(httpsCanvasInstructureComLtiSubmission, "object");
        }

        if (httpsCanvasInstructureComLtiSubmissionNewSubmission !== undefined) {
            localVarFormParams['https://canvas.instructure.com/lti/submission[new_submission]'] = ObjectSerializer.serialize(httpsCanvasInstructureComLtiSubmissionNewSubmission, "boolean");
        }

        if (httpsCanvasInstructureComLtiSubmissionPreserveScore !== undefined) {
            localVarFormParams['https://canvas.instructure.com/lti/submission[preserve_score]'] = ObjectSerializer.serialize(httpsCanvasInstructureComLtiSubmissionPreserveScore, "boolean");
        }

        if (httpsCanvasInstructureComLtiSubmissionPrioritizeNonToolGrade !== undefined) {
            localVarFormParams['https://canvas.instructure.com/lti/submission[prioritize_non_tool_grade]'] = ObjectSerializer.serialize(httpsCanvasInstructureComLtiSubmissionPrioritizeNonToolGrade, "boolean");
        }

        if (httpsCanvasInstructureComLtiSubmissionSubmissionType !== undefined) {
            localVarFormParams['https://canvas.instructure.com/lti/submission[submission_type]'] = ObjectSerializer.serialize(httpsCanvasInstructureComLtiSubmissionSubmissionType, "string");
        }

        if (httpsCanvasInstructureComLtiSubmissionSubmissionData !== undefined) {
            localVarFormParams['https://canvas.instructure.com/lti/submission[submission_data]'] = ObjectSerializer.serialize(httpsCanvasInstructureComLtiSubmissionSubmissionData, "string");
        }

        if (httpsCanvasInstructureComLtiSubmissionSubmittedAt !== undefined) {
            localVarFormParams['https://canvas.instructure.com/lti/submission[submitted_at]'] = ObjectSerializer.serialize(httpsCanvasInstructureComLtiSubmissionSubmittedAt, "string");
        }

        if (httpsCanvasInstructureComLtiSubmissionContentItems !== undefined) {
            localVarFormParams['https://canvas.instructure.com/lti/submission[content_items]'] = ObjectSerializer.serialize(httpsCanvasInstructureComLtiSubmissionContentItems, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<ResultUrl String The url to the result that was created>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<ResultUrl String The url to the result that was created>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
