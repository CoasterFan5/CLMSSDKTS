/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { DiscussionTopic } from '../model/discussionTopic';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DiscussionTopicsApiApiKeys {
}

export class DiscussionTopicsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: DiscussionTopicsApiApiKeys, value: string) {
        (this.authentications as any)[DiscussionTopicsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create an new discussion topic for the course or group.
     * @summary Create a new discussion topic
     * @param courseId ID
     * @param title no description
     * @param message no description
     * @param discussionType The type of discussion. Defaults to side_comment or not_threaded if not value is given. Accepted values are \\\&#39;side_comment\\\&#39;, \\\&#39;not_threaded\\\&#39; for discussions that only allow one level of nested comments, and \\\&#39;threaded\\\&#39; for fully threaded discussions.
     * @param published Whether this topic is published (true) or draft state (false). Only teachers and TAs have the ability to create draft state topics.
     * @param delayedPostAt If a timestamp is given, the topic will not be published until that time.
     * @param allowRating Whether or not users can rate entries in this topic.
     * @param lockAt If a timestamp is given, the topic will be scheduled to lock at the provided timestamp. If the timestamp is in the past, the topic will be locked.
     * @param podcastEnabled If true, the topic will have an associated podcast feed.
     * @param podcastHasStudentPosts If true, the podcast will include posts from students as well. Implies podcast_enabled.
     * @param requireInitialPost If true then a user may not respond to other replies until that user has made an initial reply. Defaults to false.
     * @param assignment To create an assignment discussion, pass the assignment parameters as a sub-object. See the {api:AssignmentsApiController#create Create an Assignment API} for the available parameters. The name parameter will be ignored, as it\\\&#39;s taken from the discussion title. If you want to make a discussion that was an assignment NOT an assignment, pass set_assignment &#x3D; false as part of the assignment object
     * @param isAnnouncement If true, this topic is an announcement. It will appear in the announcement\\\&#39;s section rather than the discussions section. This requires announcment-posting permissions.
     * @param pinned If true, this topic will be listed in the \\\&quot;Pinned Discussion\\\&quot; section
     * @param positionAfter By default, discussions are sorted chronologically by creation date, you can pass the id of another topic to have this one show up after the other when they are listed.
     * @param groupCategoryId If present, the topic will become a group discussion assigned to the group.
     * @param onlyGradersCanRate If true, only graders will be allowed to rate entries.
     * @param sortOrder Default sort order of the discussion. Accepted values are \\\&quot;asc\\\&quot;, \\\&quot;desc\\\&quot;.
     * @param sortOrderLocked If true, users cannot choose their prefered sort order
     * @param expanded If true, thread will be expanded by default
     * @param expandedLocked If true, users cannot choose their prefered thread expansion setting
     * @param sortByRating (DEPRECATED) If true, entries will be sorted by rating.
     * @param attachment A multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
     * @param specificSections A comma-separated list of sections ids to which the discussion topic should be made specific to.  If it is not desired to make the discussion topic specific to sections, then this parameter may be omitted or set to \\\&quot;all\\\&quot;.  Can only be present only on announcements and only those that are for a course (as opposed to a group).
     * @param lockComment If is_announcement and lock_comment are true, ‘Allow Participants to Comment’ setting is disabled.
     */
    public async createNewDiscussionTopicCourses (courseId: string, title?: string, message?: string, discussionType?: string, published?: boolean, delayedPostAt?: Date, allowRating?: boolean, lockAt?: Date, podcastEnabled?: boolean, podcastHasStudentPosts?: boolean, requireInitialPost?: boolean, assignment?: any, isAnnouncement?: boolean, pinned?: boolean, positionAfter?: string, groupCategoryId?: number, onlyGradersCanRate?: boolean, sortOrder?: string, sortOrderLocked?: boolean, expanded?: boolean, expandedLocked?: boolean, sortByRating?: boolean, attachment?: RequestFile, specificSections?: string, lockComment?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createNewDiscussionTopicCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (title !== undefined) {
            localVarFormParams['title'] = ObjectSerializer.serialize(title, "string");
        }

        if (message !== undefined) {
            localVarFormParams['message'] = ObjectSerializer.serialize(message, "string");
        }

        if (discussionType !== undefined) {
            localVarFormParams['discussion_type'] = ObjectSerializer.serialize(discussionType, "string");
        }

        if (published !== undefined) {
            localVarFormParams['published'] = ObjectSerializer.serialize(published, "boolean");
        }

        if (delayedPostAt !== undefined) {
            localVarFormParams['delayed_post_at'] = ObjectSerializer.serialize(delayedPostAt, "Date");
        }

        if (allowRating !== undefined) {
            localVarFormParams['allow_rating'] = ObjectSerializer.serialize(allowRating, "boolean");
        }

        if (lockAt !== undefined) {
            localVarFormParams['lock_at'] = ObjectSerializer.serialize(lockAt, "Date");
        }

        if (podcastEnabled !== undefined) {
            localVarFormParams['podcast_enabled'] = ObjectSerializer.serialize(podcastEnabled, "boolean");
        }

        if (podcastHasStudentPosts !== undefined) {
            localVarFormParams['podcast_has_student_posts'] = ObjectSerializer.serialize(podcastHasStudentPosts, "boolean");
        }

        if (requireInitialPost !== undefined) {
            localVarFormParams['require_initial_post'] = ObjectSerializer.serialize(requireInitialPost, "boolean");
        }

        if (assignment !== undefined) {
            localVarFormParams['assignment'] = ObjectSerializer.serialize(assignment, "any");
        }

        if (isAnnouncement !== undefined) {
            localVarFormParams['is_announcement'] = ObjectSerializer.serialize(isAnnouncement, "boolean");
        }

        if (pinned !== undefined) {
            localVarFormParams['pinned'] = ObjectSerializer.serialize(pinned, "boolean");
        }

        if (positionAfter !== undefined) {
            localVarFormParams['position_after'] = ObjectSerializer.serialize(positionAfter, "string");
        }

        if (groupCategoryId !== undefined) {
            localVarFormParams['group_category_id'] = ObjectSerializer.serialize(groupCategoryId, "number");
        }

        if (onlyGradersCanRate !== undefined) {
            localVarFormParams['only_graders_can_rate'] = ObjectSerializer.serialize(onlyGradersCanRate, "boolean");
        }

        if (sortOrder !== undefined) {
            localVarFormParams['sort_order'] = ObjectSerializer.serialize(sortOrder, "string");
        }

        if (sortOrderLocked !== undefined) {
            localVarFormParams['sort_order_locked'] = ObjectSerializer.serialize(sortOrderLocked, "boolean");
        }

        if (expanded !== undefined) {
            localVarFormParams['expanded'] = ObjectSerializer.serialize(expanded, "boolean");
        }

        if (expandedLocked !== undefined) {
            localVarFormParams['expanded_locked'] = ObjectSerializer.serialize(expandedLocked, "boolean");
        }

        if (sortByRating !== undefined) {
            localVarFormParams['sort_by_rating'] = ObjectSerializer.serialize(sortByRating, "boolean");
        }

        if (attachment !== undefined) {
            localVarFormParams['attachment'] = attachment;
        }
        localVarUseFormData = true;

        if (specificSections !== undefined) {
            localVarFormParams['specific_sections'] = ObjectSerializer.serialize(specificSections, "string");
        }

        if (lockComment !== undefined) {
            localVarFormParams['lock_comment'] = ObjectSerializer.serialize(lockComment, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create an new discussion topic for the course or group.
     * @summary Create a new discussion topic
     * @param groupId ID
     * @param title no description
     * @param message no description
     * @param discussionType The type of discussion. Defaults to side_comment or not_threaded if not value is given. Accepted values are \\\&#39;side_comment\\\&#39;, \\\&#39;not_threaded\\\&#39; for discussions that only allow one level of nested comments, and \\\&#39;threaded\\\&#39; for fully threaded discussions.
     * @param published Whether this topic is published (true) or draft state (false). Only teachers and TAs have the ability to create draft state topics.
     * @param delayedPostAt If a timestamp is given, the topic will not be published until that time.
     * @param allowRating Whether or not users can rate entries in this topic.
     * @param lockAt If a timestamp is given, the topic will be scheduled to lock at the provided timestamp. If the timestamp is in the past, the topic will be locked.
     * @param podcastEnabled If true, the topic will have an associated podcast feed.
     * @param podcastHasStudentPosts If true, the podcast will include posts from students as well. Implies podcast_enabled.
     * @param requireInitialPost If true then a user may not respond to other replies until that user has made an initial reply. Defaults to false.
     * @param assignment To create an assignment discussion, pass the assignment parameters as a sub-object. See the {api:AssignmentsApiController#create Create an Assignment API} for the available parameters. The name parameter will be ignored, as it\\\&#39;s taken from the discussion title. If you want to make a discussion that was an assignment NOT an assignment, pass set_assignment &#x3D; false as part of the assignment object
     * @param isAnnouncement If true, this topic is an announcement. It will appear in the announcement\\\&#39;s section rather than the discussions section. This requires announcment-posting permissions.
     * @param pinned If true, this topic will be listed in the \\\&quot;Pinned Discussion\\\&quot; section
     * @param positionAfter By default, discussions are sorted chronologically by creation date, you can pass the id of another topic to have this one show up after the other when they are listed.
     * @param groupCategoryId If present, the topic will become a group discussion assigned to the group.
     * @param onlyGradersCanRate If true, only graders will be allowed to rate entries.
     * @param sortOrder Default sort order of the discussion. Accepted values are \\\&quot;asc\\\&quot;, \\\&quot;desc\\\&quot;.
     * @param sortOrderLocked If true, users cannot choose their prefered sort order
     * @param expanded If true, thread will be expanded by default
     * @param expandedLocked If true, users cannot choose their prefered thread expansion setting
     * @param sortByRating (DEPRECATED) If true, entries will be sorted by rating.
     * @param attachment A multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
     * @param specificSections A comma-separated list of sections ids to which the discussion topic should be made specific to.  If it is not desired to make the discussion topic specific to sections, then this parameter may be omitted or set to \\\&quot;all\\\&quot;.  Can only be present only on announcements and only those that are for a course (as opposed to a group).
     * @param lockComment If is_announcement and lock_comment are true, ‘Allow Participants to Comment’ setting is disabled.
     */
    public async createNewDiscussionTopicGroups (groupId: string, title?: string, message?: string, discussionType?: string, published?: boolean, delayedPostAt?: Date, allowRating?: boolean, lockAt?: Date, podcastEnabled?: boolean, podcastHasStudentPosts?: boolean, requireInitialPost?: boolean, assignment?: any, isAnnouncement?: boolean, pinned?: boolean, positionAfter?: string, groupCategoryId?: number, onlyGradersCanRate?: boolean, sortOrder?: string, sortOrderLocked?: boolean, expanded?: boolean, expandedLocked?: boolean, sortByRating?: boolean, attachment?: RequestFile, specificSections?: string, lockComment?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling createNewDiscussionTopicGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (title !== undefined) {
            localVarFormParams['title'] = ObjectSerializer.serialize(title, "string");
        }

        if (message !== undefined) {
            localVarFormParams['message'] = ObjectSerializer.serialize(message, "string");
        }

        if (discussionType !== undefined) {
            localVarFormParams['discussion_type'] = ObjectSerializer.serialize(discussionType, "string");
        }

        if (published !== undefined) {
            localVarFormParams['published'] = ObjectSerializer.serialize(published, "boolean");
        }

        if (delayedPostAt !== undefined) {
            localVarFormParams['delayed_post_at'] = ObjectSerializer.serialize(delayedPostAt, "Date");
        }

        if (allowRating !== undefined) {
            localVarFormParams['allow_rating'] = ObjectSerializer.serialize(allowRating, "boolean");
        }

        if (lockAt !== undefined) {
            localVarFormParams['lock_at'] = ObjectSerializer.serialize(lockAt, "Date");
        }

        if (podcastEnabled !== undefined) {
            localVarFormParams['podcast_enabled'] = ObjectSerializer.serialize(podcastEnabled, "boolean");
        }

        if (podcastHasStudentPosts !== undefined) {
            localVarFormParams['podcast_has_student_posts'] = ObjectSerializer.serialize(podcastHasStudentPosts, "boolean");
        }

        if (requireInitialPost !== undefined) {
            localVarFormParams['require_initial_post'] = ObjectSerializer.serialize(requireInitialPost, "boolean");
        }

        if (assignment !== undefined) {
            localVarFormParams['assignment'] = ObjectSerializer.serialize(assignment, "any");
        }

        if (isAnnouncement !== undefined) {
            localVarFormParams['is_announcement'] = ObjectSerializer.serialize(isAnnouncement, "boolean");
        }

        if (pinned !== undefined) {
            localVarFormParams['pinned'] = ObjectSerializer.serialize(pinned, "boolean");
        }

        if (positionAfter !== undefined) {
            localVarFormParams['position_after'] = ObjectSerializer.serialize(positionAfter, "string");
        }

        if (groupCategoryId !== undefined) {
            localVarFormParams['group_category_id'] = ObjectSerializer.serialize(groupCategoryId, "number");
        }

        if (onlyGradersCanRate !== undefined) {
            localVarFormParams['only_graders_can_rate'] = ObjectSerializer.serialize(onlyGradersCanRate, "boolean");
        }

        if (sortOrder !== undefined) {
            localVarFormParams['sort_order'] = ObjectSerializer.serialize(sortOrder, "string");
        }

        if (sortOrderLocked !== undefined) {
            localVarFormParams['sort_order_locked'] = ObjectSerializer.serialize(sortOrderLocked, "boolean");
        }

        if (expanded !== undefined) {
            localVarFormParams['expanded'] = ObjectSerializer.serialize(expanded, "boolean");
        }

        if (expandedLocked !== undefined) {
            localVarFormParams['expanded_locked'] = ObjectSerializer.serialize(expandedLocked, "boolean");
        }

        if (sortByRating !== undefined) {
            localVarFormParams['sort_by_rating'] = ObjectSerializer.serialize(sortByRating, "boolean");
        }

        if (attachment !== undefined) {
            localVarFormParams['attachment'] = attachment;
        }
        localVarUseFormData = true;

        if (specificSections !== undefined) {
            localVarFormParams['specific_sections'] = ObjectSerializer.serialize(specificSections, "string");
        }

        if (lockComment !== undefined) {
            localVarFormParams['lock_comment'] = ObjectSerializer.serialize(lockComment, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete a discussion entry.  The entry must have been created by the current user, or the current user must have admin rights to the discussion. If the delete is not allowed, a 401 will be returned.  The discussion will be marked deleted, and the user_id and message will be cleared out.
     * @summary Delete an entry
     * @param courseId ID
     * @param topicId ID
     * @param id ID
     */
    public async deleteEntryCourses (courseId: string, topicId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling deleteEntryCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling deleteEntryCourses.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteEntryCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete a discussion entry.  The entry must have been created by the current user, or the current user must have admin rights to the discussion. If the delete is not allowed, a 401 will be returned.  The discussion will be marked deleted, and the user_id and message will be cleared out.
     * @summary Delete an entry
     * @param groupId ID
     * @param topicId ID
     * @param id ID
     */
    public async deleteEntryGroups (groupId: string, topicId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{id}'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling deleteEntryGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling deleteEntryGroups.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteEntryGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes the discussion topic. This will also delete the assignment, if it\'s an assignment discussion.
     * @summary Delete a topic
     * @param courseId ID
     * @param topicId ID
     */
    public async deleteTopicCourses (courseId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling deleteTopicCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling deleteTopicCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes the discussion topic. This will also delete the assignment, if it\'s an assignment discussion.
     * @summary Delete a topic
     * @param groupId ID
     * @param topicId ID
     */
    public async deleteTopicGroups (groupId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling deleteTopicGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling deleteTopicGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deprecated, to remove after VICE-5047 gets merged Disables the summary for a discussion topic.
     * @summary Disable summary
     * @param courseId ID
     * @param topicId ID
     */
    public async disableSummaryCourses (courseId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/summaries/disable'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling disableSummaryCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling disableSummaryCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deprecated, to remove after VICE-5047 gets merged Disables the summary for a discussion topic.
     * @summary Disable summary
     * @param groupId ID
     * @param topicId ID
     */
    public async disableSummaryGroups (groupId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/summaries/disable'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling disableSummaryGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling disableSummaryGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Duplicate a discussion topic according to context (Course/Group)
     * @summary Duplicate discussion topic
     * @param courseId ID
     * @param topicId ID
     */
    public async duplicateDiscussionTopicCourses (courseId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DiscussionTopic;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/duplicate'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling duplicateDiscussionTopicCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling duplicateDiscussionTopicCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DiscussionTopic;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DiscussionTopic");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Duplicate a discussion topic according to context (Course/Group)
     * @summary Duplicate discussion topic
     * @param groupId ID
     * @param topicId ID
     */
    public async duplicateDiscussionTopicGroups (groupId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DiscussionTopic;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/duplicate'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling duplicateDiscussionTopicGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling duplicateDiscussionTopicGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DiscussionTopic;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DiscussionTopic");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns: (1) last userInput (what current user had keyed in to produce the last discussion summary), (2) last discussion summary generated by the current user for current discussion topic, based on userInput, (3) and some usage information.
     * @summary Find Last Summary
     * @param courseId ID
     * @param topicId ID
     */
    public async findLastSummaryCourses (courseId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/summaries'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling findLastSummaryCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling findLastSummaryCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns: (1) last userInput (what current user had keyed in to produce the last discussion summary), (2) last discussion summary generated by the current user for current discussion topic, based on userInput, (3) and some usage information.
     * @summary Find Last Summary
     * @param groupId ID
     * @param topicId ID
     */
    public async findLastSummaryGroups (groupId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/summaries'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling findLastSummaryGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling findLastSummaryGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Generates a summary for a discussion topic. Returns the summary text and usage information.
     * @summary Find or Create Summary
     * @param courseId ID
     * @param topicId ID
     * @param userInput Areas or topics for the summary to focus on.
     */
    public async findOrCreateSummaryCourses (courseId: string, topicId: string, userInput?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/summaries'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling findOrCreateSummaryCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling findOrCreateSummaryCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (userInput !== undefined) {
            localVarFormParams['userInput'] = ObjectSerializer.serialize(userInput, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Generates a summary for a discussion topic. Returns the summary text and usage information.
     * @summary Find or Create Summary
     * @param groupId ID
     * @param topicId ID
     * @param userInput Areas or topics for the summary to focus on.
     */
    public async findOrCreateSummaryGroups (groupId: string, topicId: string, userInput?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/summaries'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling findOrCreateSummaryGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling findOrCreateSummaryGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (userInput !== undefined) {
            localVarFormParams['userInput'] = ObjectSerializer.serialize(userInput, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Return a cached structure of the discussion topic, containing all entries, their authors, and their message bodies.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body \'require_initial_post\'.  In some rare situations, this cached structure may not be available yet. In that case, the server will respond with a 503 error, and the caller should try again soon.  The response is an object containing the following keys: * \"participants\": A list of summary information on users who have posted to   the discussion. Each value is an object containing their id, display_name,   and avatar_url. * \"unread_entries\": A list of entry ids that are unread by the current   user. this implies that any entry not in this list is read. * \"entry_ratings\": A map of entry ids to ratings by the current user. Entries   not in this list have no rating. Only populated if rating is enabled. * \"forced_entries\": A list of entry ids that have forced_read_state set to   true. This flag is meant to indicate the entry\'s read_state has been   manually set to \'unread\' by the user, so the entry should not be   automatically marked as read. * \"view\": A threaded view of all the entries in the discussion, containing   the id, user_id, and message. * \"new_entries\": Because this view is eventually consistent, it\'s possible   that newly created or updated entries won\'t yet be reflected in the view.   If the application wants to also get a flat list of all entries not yet   reflected in the view, pass include_new_entries=1 to the request and this   array of entries will be returned. These entries are returned in a flat   array, in ascending created_at order.
     * @summary Get the full topic
     * @param courseId ID
     * @param topicId ID
     */
    public async getFullTopicCourses (courseId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/view'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getFullTopicCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling getFullTopicCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Return a cached structure of the discussion topic, containing all entries, their authors, and their message bodies.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body \'require_initial_post\'.  In some rare situations, this cached structure may not be available yet. In that case, the server will respond with a 503 error, and the caller should try again soon.  The response is an object containing the following keys: * \"participants\": A list of summary information on users who have posted to   the discussion. Each value is an object containing their id, display_name,   and avatar_url. * \"unread_entries\": A list of entry ids that are unread by the current   user. this implies that any entry not in this list is read. * \"entry_ratings\": A map of entry ids to ratings by the current user. Entries   not in this list have no rating. Only populated if rating is enabled. * \"forced_entries\": A list of entry ids that have forced_read_state set to   true. This flag is meant to indicate the entry\'s read_state has been   manually set to \'unread\' by the user, so the entry should not be   automatically marked as read. * \"view\": A threaded view of all the entries in the discussion, containing   the id, user_id, and message. * \"new_entries\": Because this view is eventually consistent, it\'s possible   that newly created or updated entries won\'t yet be reflected in the view.   If the application wants to also get a flat list of all entries not yet   reflected in the view, pass include_new_entries=1 to the request and this   array of entries will be returned. These entries are returned in a flat   array, in ascending created_at order.
     * @summary Get the full topic
     * @param groupId ID
     * @param topicId ID
     */
    public async getFullTopicGroups (groupId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/view'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getFullTopicGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling getFullTopicGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns data on an individual discussion topic. See the List action for the response formatting.
     * @summary Get a single topic
     * @param courseId ID
     * @param topicId ID
     * @param include If \&quot;all_dates\&quot; is passed, all dates associated with graded discussions\&#39; assignments will be included. if \&quot;sections\&quot; is passed, includes the course sections that are associated with the topic, if the topic is specific to certain sections of the course. If \&quot;sections_user_count\&quot; is passed, then:   (a) If sections were asked for *and* the topic is specific to certain       course sections, includes the number of users in each       section. (as part of the section json asked for above)   (b) Else, includes at the root level the total number of users in the       topic\&#39;s context (group or course) that the topic applies to. If \&quot;overrides\&quot; is passed, the overrides for the assignment will be included
     */
    public async getSingleTopicCourses (courseId: string, topicId: string, include?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getSingleTopicCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling getSingleTopicCourses.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns data on an individual discussion topic. See the List action for the response formatting.
     * @summary Get a single topic
     * @param groupId ID
     * @param topicId ID
     * @param include If \&quot;all_dates\&quot; is passed, all dates associated with graded discussions\&#39; assignments will be included. if \&quot;sections\&quot; is passed, includes the course sections that are associated with the topic, if the topic is specific to certain sections of the course. If \&quot;sections_user_count\&quot; is passed, then:   (a) If sections were asked for *and* the topic is specific to certain       course sections, includes the number of users in each       section. (as part of the section json asked for above)   (b) Else, includes at the root level the total number of users in the       topic\&#39;s context (group or course) that the topic applies to. If \&quot;overrides\&quot; is passed, the overrides for the assignment will be included
     */
    public async getSingleTopicGroups (groupId: string, topicId: string, include?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getSingleTopicGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling getSingleTopicGroups.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the paginated list of discussion topics for this course or group.
     * @summary List discussion topics
     * @param courseId ID
     * @param include If \&quot;all_dates\&quot; is passed, all dates associated with graded discussions\&#39; assignments will be included. if \&quot;sections\&quot; is passed, includes the course sections that are associated with the topic, if the topic is specific to certain sections of the course. If \&quot;sections_user_count\&quot; is passed, then:   (a) If sections were asked for *and* the topic is specific to certain       course sections, includes the number of users in each       section. (as part of the section json asked for above)   (b) Else, includes at the root level the total number of users in the       topic\&#39;s context (group or course) that the topic applies to. If \&quot;overrides\&quot; is passed, the overrides for the assignment will be included
     * @param orderBy Determines the order of the discussion topic list. Defaults to \&quot;position\&quot;.
     * @param scope Only return discussion topics in the given state(s). Defaults to including all topics. Filtering is done after pagination, so pages may be smaller than requested if topics are filtered. Can pass multiple states as comma separated string.
     * @param onlyAnnouncements Return announcements instead of discussion topics. Defaults to false
     * @param filterBy The state of the discussion topic to return. Currently only supports unread state.
     * @param searchTerm The partial title of the discussion topics to match and return.
     * @param excludeContextModuleLockedTopics For students, exclude topics that are locked by module progression. Defaults to false.
     */
    public async listDiscussionTopicsCourses (courseId: string, include?: Array<string>, orderBy?: 'position' | 'recent_activity' | 'title', scope?: 'locked' | 'unlocked' | 'pinned' | 'unpinned', onlyAnnouncements?: boolean, filterBy?: 'all' | 'unread', searchTerm?: string, excludeContextModuleLockedTopics?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<DiscussionTopic>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listDiscussionTopicsCourses.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['order_by'] = ObjectSerializer.serialize(orderBy, "'position' | 'recent_activity' | 'title'");
        }

        if (scope !== undefined) {
            localVarQueryParameters['scope'] = ObjectSerializer.serialize(scope, "'locked' | 'unlocked' | 'pinned' | 'unpinned'");
        }

        if (onlyAnnouncements !== undefined) {
            localVarQueryParameters['only_announcements'] = ObjectSerializer.serialize(onlyAnnouncements, "boolean");
        }

        if (filterBy !== undefined) {
            localVarQueryParameters['filter_by'] = ObjectSerializer.serialize(filterBy, "'all' | 'unread'");
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['search_term'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (excludeContextModuleLockedTopics !== undefined) {
            localVarQueryParameters['exclude_context_module_locked_topics'] = ObjectSerializer.serialize(excludeContextModuleLockedTopics, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<DiscussionTopic>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<DiscussionTopic>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the paginated list of discussion topics for this course or group.
     * @summary List discussion topics
     * @param groupId ID
     * @param include If \&quot;all_dates\&quot; is passed, all dates associated with graded discussions\&#39; assignments will be included. if \&quot;sections\&quot; is passed, includes the course sections that are associated with the topic, if the topic is specific to certain sections of the course. If \&quot;sections_user_count\&quot; is passed, then:   (a) If sections were asked for *and* the topic is specific to certain       course sections, includes the number of users in each       section. (as part of the section json asked for above)   (b) Else, includes at the root level the total number of users in the       topic\&#39;s context (group or course) that the topic applies to. If \&quot;overrides\&quot; is passed, the overrides for the assignment will be included
     * @param orderBy Determines the order of the discussion topic list. Defaults to \&quot;position\&quot;.
     * @param scope Only return discussion topics in the given state(s). Defaults to including all topics. Filtering is done after pagination, so pages may be smaller than requested if topics are filtered. Can pass multiple states as comma separated string.
     * @param onlyAnnouncements Return announcements instead of discussion topics. Defaults to false
     * @param filterBy The state of the discussion topic to return. Currently only supports unread state.
     * @param searchTerm The partial title of the discussion topics to match and return.
     * @param excludeContextModuleLockedTopics For students, exclude topics that are locked by module progression. Defaults to false.
     */
    public async listDiscussionTopicsGroups (groupId: string, include?: Array<string>, orderBy?: 'position' | 'recent_activity' | 'title', scope?: 'locked' | 'unlocked' | 'pinned' | 'unpinned', onlyAnnouncements?: boolean, filterBy?: 'all' | 'unread', searchTerm?: string, excludeContextModuleLockedTopics?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<DiscussionTopic>;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling listDiscussionTopicsGroups.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['order_by'] = ObjectSerializer.serialize(orderBy, "'position' | 'recent_activity' | 'title'");
        }

        if (scope !== undefined) {
            localVarQueryParameters['scope'] = ObjectSerializer.serialize(scope, "'locked' | 'unlocked' | 'pinned' | 'unpinned'");
        }

        if (onlyAnnouncements !== undefined) {
            localVarQueryParameters['only_announcements'] = ObjectSerializer.serialize(onlyAnnouncements, "boolean");
        }

        if (filterBy !== undefined) {
            localVarQueryParameters['filter_by'] = ObjectSerializer.serialize(filterBy, "'all' | 'unread'");
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['search_term'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (excludeContextModuleLockedTopics !== undefined) {
            localVarQueryParameters['exclude_context_module_locked_topics'] = ObjectSerializer.serialize(excludeContextModuleLockedTopics, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<DiscussionTopic>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<DiscussionTopic>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve a paginated list of discussion entries, given a list of ids.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body \'require_initial_post\'.
     * @summary List entries
     * @param courseId ID
     * @param topicId ID
     * @param ids A list of entry ids to retrieve. Entries will be returned in id order, smallest id first.
     */
    public async listEntriesCourses (courseId: string, topicId: string, ids?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/entry_list'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listEntriesCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling listEntriesCourses.');
        }

        if (ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(ids, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve a paginated list of discussion entries, given a list of ids.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body \'require_initial_post\'.
     * @summary List entries
     * @param groupId ID
     * @param topicId ID
     * @param ids A list of entry ids to retrieve. Entries will be returned in id order, smallest id first.
     */
    public async listEntriesGroups (groupId: string, topicId: string, ids?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/entry_list'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling listEntriesGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling listEntriesGroups.');
        }

        if (ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(ids, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve the (paginated) replies to a top-level entry in a discussion topic.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body \'require_initial_post\'.  Ordering of returned entries is newest-first by creation timestamp.
     * @summary List entry replies
     * @param courseId ID
     * @param topicId ID
     * @param entryId ID
     */
    public async listEntryRepliesCourses (courseId: string, topicId: string, entryId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'entry_id' + '}', encodeURIComponent(String(entryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listEntryRepliesCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling listEntryRepliesCourses.');
        }

        // verify required parameter 'entryId' is not null or undefined
        if (entryId === null || entryId === undefined) {
            throw new Error('Required parameter entryId was null or undefined when calling listEntryRepliesCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve the (paginated) replies to a top-level entry in a discussion topic.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body \'require_initial_post\'.  Ordering of returned entries is newest-first by creation timestamp.
     * @summary List entry replies
     * @param groupId ID
     * @param topicId ID
     * @param entryId ID
     */
    public async listEntryRepliesGroups (groupId: string, topicId: string, entryId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'entry_id' + '}', encodeURIComponent(String(entryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling listEntryRepliesGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling listEntryRepliesGroups.');
        }

        // verify required parameter 'entryId' is not null or undefined
        if (entryId === null || entryId === undefined) {
            throw new Error('Required parameter entryId was null or undefined when calling listEntryRepliesGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve the (paginated) top-level entries in a discussion topic.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body \'require_initial_post\'.  Will include the 10 most recent replies, if any, for each entry returned.  If the topic is a root topic with children corresponding to groups of a group assignment, entries from those subtopics for which the user belongs to the corresponding group will be returned.  Ordering of returned entries is newest-first by posting timestamp (reply activity is ignored).
     * @summary List topic entries
     * @param courseId ID
     * @param topicId ID
     */
    public async listTopicEntriesCourses (courseId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listTopicEntriesCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling listTopicEntriesCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve the (paginated) top-level entries in a discussion topic.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body \'require_initial_post\'.  Will include the 10 most recent replies, if any, for each entry returned.  If the topic is a root topic with children corresponding to groups of a group assignment, entries from those subtopics for which the user belongs to the corresponding group will be returned.  Ordering of returned entries is newest-first by posting timestamp (reply activity is ignored).
     * @summary List topic entries
     * @param groupId ID
     * @param topicId ID
     */
    public async listTopicEntriesGroups (groupId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling listTopicEntriesGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling listTopicEntriesGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark the discussion topic and all its entries as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark all entries as read
     * @param courseId ID
     * @param topicId ID
     * @param forcedReadState A boolean value to set all of the entries\\\&#39; forced_read_state. No change is made if this argument is not specified.
     */
    public async markAllEntriesAsReadCourses (courseId: string, topicId: string, forcedReadState?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/read_all'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markAllEntriesAsReadCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling markAllEntriesAsReadCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (forcedReadState !== undefined) {
            localVarFormParams['forced_read_state'] = ObjectSerializer.serialize(forcedReadState, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark the discussion topic and all its entries as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark all entries as read
     * @param groupId ID
     * @param topicId ID
     * @param forcedReadState A boolean value to set all of the entries\\\&#39; forced_read_state. No change is made if this argument is not specified.
     */
    public async markAllEntriesAsReadGroups (groupId: string, topicId: string, forcedReadState?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/read_all'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling markAllEntriesAsReadGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling markAllEntriesAsReadGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (forcedReadState !== undefined) {
            localVarFormParams['forced_read_state'] = ObjectSerializer.serialize(forcedReadState, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark the discussion topic and all its entries as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark all entries as unread
     * @param courseId ID
     * @param topicId ID
     * @param forcedReadState A boolean value to set all of the entries\&#39; forced_read_state. No change is made if this argument is not specified.
     */
    public async markAllEntriesAsUnreadCourses (courseId: string, topicId: string, forcedReadState?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/read_all'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markAllEntriesAsUnreadCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling markAllEntriesAsUnreadCourses.');
        }

        if (forcedReadState !== undefined) {
            localVarQueryParameters['forced_read_state'] = ObjectSerializer.serialize(forcedReadState, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark the discussion topic and all its entries as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark all entries as unread
     * @param groupId ID
     * @param topicId ID
     * @param forcedReadState A boolean value to set all of the entries\&#39; forced_read_state. No change is made if this argument is not specified.
     */
    public async markAllEntriesAsUnreadGroups (groupId: string, topicId: string, forcedReadState?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/read_all'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling markAllEntriesAsUnreadGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling markAllEntriesAsUnreadGroups.');
        }

        if (forcedReadState !== undefined) {
            localVarQueryParameters['forced_read_state'] = ObjectSerializer.serialize(forcedReadState, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark the initial text of all the discussion topics as read in  the context.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark all topic as read
     * @param courseId ID
     */
    public async markAllTopicAsReadCourses (courseId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/read_all'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markAllTopicAsReadCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark the initial text of all the discussion topics as read in  the context.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark all topic as read
     * @param groupId ID
     */
    public async markAllTopicAsReadGroups (groupId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/read_all'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling markAllTopicAsReadGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark a discussion entry as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark entry as read
     * @param courseId ID
     * @param topicId ID
     * @param entryId ID
     * @param forcedReadState A boolean value to set the entry\\\&#39;s forced_read_state. No change is made if this argument is not specified.
     */
    public async markEntryAsReadCourses (courseId: string, topicId: string, entryId: string, forcedReadState?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/read'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'entry_id' + '}', encodeURIComponent(String(entryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markEntryAsReadCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling markEntryAsReadCourses.');
        }

        // verify required parameter 'entryId' is not null or undefined
        if (entryId === null || entryId === undefined) {
            throw new Error('Required parameter entryId was null or undefined when calling markEntryAsReadCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (forcedReadState !== undefined) {
            localVarFormParams['forced_read_state'] = ObjectSerializer.serialize(forcedReadState, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark a discussion entry as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark entry as read
     * @param groupId ID
     * @param topicId ID
     * @param entryId ID
     * @param forcedReadState A boolean value to set the entry\\\&#39;s forced_read_state. No change is made if this argument is not specified.
     */
    public async markEntryAsReadGroups (groupId: string, topicId: string, entryId: string, forcedReadState?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/read'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'entry_id' + '}', encodeURIComponent(String(entryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling markEntryAsReadGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling markEntryAsReadGroups.');
        }

        // verify required parameter 'entryId' is not null or undefined
        if (entryId === null || entryId === undefined) {
            throw new Error('Required parameter entryId was null or undefined when calling markEntryAsReadGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (forcedReadState !== undefined) {
            localVarFormParams['forced_read_state'] = ObjectSerializer.serialize(forcedReadState, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark a discussion entry as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark entry as unread
     * @param courseId ID
     * @param topicId ID
     * @param entryId ID
     * @param forcedReadState A boolean value to set the entry\&#39;s forced_read_state. No change is made if this argument is not specified.
     */
    public async markEntryAsUnreadCourses (courseId: string, topicId: string, entryId: string, forcedReadState?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/read'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'entry_id' + '}', encodeURIComponent(String(entryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markEntryAsUnreadCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling markEntryAsUnreadCourses.');
        }

        // verify required parameter 'entryId' is not null or undefined
        if (entryId === null || entryId === undefined) {
            throw new Error('Required parameter entryId was null or undefined when calling markEntryAsUnreadCourses.');
        }

        if (forcedReadState !== undefined) {
            localVarQueryParameters['forced_read_state'] = ObjectSerializer.serialize(forcedReadState, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark a discussion entry as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark entry as unread
     * @param groupId ID
     * @param topicId ID
     * @param entryId ID
     * @param forcedReadState A boolean value to set the entry\&#39;s forced_read_state. No change is made if this argument is not specified.
     */
    public async markEntryAsUnreadGroups (groupId: string, topicId: string, entryId: string, forcedReadState?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/read'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'entry_id' + '}', encodeURIComponent(String(entryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling markEntryAsUnreadGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling markEntryAsUnreadGroups.');
        }

        // verify required parameter 'entryId' is not null or undefined
        if (entryId === null || entryId === undefined) {
            throw new Error('Required parameter entryId was null or undefined when calling markEntryAsUnreadGroups.');
        }

        if (forcedReadState !== undefined) {
            localVarQueryParameters['forced_read_state'] = ObjectSerializer.serialize(forcedReadState, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark the initial text of the discussion topic as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark topic as read
     * @param courseId ID
     * @param topicId ID
     */
    public async markTopicAsReadCourses (courseId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/read'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markTopicAsReadCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling markTopicAsReadCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark the initial text of the discussion topic as read.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark topic as read
     * @param groupId ID
     * @param topicId ID
     */
    public async markTopicAsReadGroups (groupId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/read'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling markTopicAsReadGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling markTopicAsReadGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark the initial text of the discussion topic as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark topic as unread
     * @param courseId ID
     * @param topicId ID
     */
    public async markTopicAsUnreadCourses (courseId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/read'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markTopicAsUnreadCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling markTopicAsUnreadCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark the initial text of the discussion topic as unread.  No request fields are necessary.  On success, the response will be 204 No Content with an empty body.
     * @summary Mark topic as unread
     * @param groupId ID
     * @param topicId ID
     */
    public async markTopicAsUnreadGroups (groupId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/read'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling markTopicAsUnreadGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling markTopicAsUnreadGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a new entry in a discussion topic. Returns a json representation of the created entry (see documentation for \'entries\' method) on success.
     * @summary Post an entry
     * @param courseId ID
     * @param topicId ID
     * @param message The body of the entry.
     * @param attachment a multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
     */
    public async postEntryCourses (courseId: string, topicId: string, message?: string, attachment?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling postEntryCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling postEntryCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (message !== undefined) {
            localVarFormParams['message'] = ObjectSerializer.serialize(message, "string");
        }

        if (attachment !== undefined) {
            localVarFormParams['attachment'] = ObjectSerializer.serialize(attachment, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a new entry in a discussion topic. Returns a json representation of the created entry (see documentation for \'entries\' method) on success.
     * @summary Post an entry
     * @param groupId ID
     * @param topicId ID
     * @param message The body of the entry.
     * @param attachment a multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
     */
    public async postEntryGroups (groupId: string, topicId: string, message?: string, attachment?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling postEntryGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling postEntryGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (message !== undefined) {
            localVarFormParams['message'] = ObjectSerializer.serialize(message, "string");
        }

        if (attachment !== undefined) {
            localVarFormParams['attachment'] = ObjectSerializer.serialize(attachment, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Add a reply to an entry in a discussion topic. Returns a json representation of the created reply (see documentation for \'replies\' method) on success.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body \'require_initial_post\'.
     * @summary Post a reply
     * @param courseId ID
     * @param topicId ID
     * @param entryId ID
     * @param message The body of the entry.
     * @param attachment a multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
     */
    public async postReplyCourses (courseId: string, topicId: string, entryId: string, message?: string, attachment?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'entry_id' + '}', encodeURIComponent(String(entryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling postReplyCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling postReplyCourses.');
        }

        // verify required parameter 'entryId' is not null or undefined
        if (entryId === null || entryId === undefined) {
            throw new Error('Required parameter entryId was null or undefined when calling postReplyCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (message !== undefined) {
            localVarFormParams['message'] = ObjectSerializer.serialize(message, "string");
        }

        if (attachment !== undefined) {
            localVarFormParams['attachment'] = ObjectSerializer.serialize(attachment, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Add a reply to an entry in a discussion topic. Returns a json representation of the created reply (see documentation for \'replies\' method) on success.  May require (depending on the topic) that the user has posted in the topic. If it is required, and the user has not posted, will respond with a 403 Forbidden status and the body \'require_initial_post\'.
     * @summary Post a reply
     * @param groupId ID
     * @param topicId ID
     * @param entryId ID
     * @param message The body of the entry.
     * @param attachment a multipart/form-data form-field-style attachment. Attachments larger than 1 kilobyte are subject to quota restrictions.
     */
    public async postReplyGroups (groupId: string, topicId: string, entryId: string, message?: string, attachment?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'entry_id' + '}', encodeURIComponent(String(entryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling postReplyGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling postReplyGroups.');
        }

        // verify required parameter 'entryId' is not null or undefined
        if (entryId === null || entryId === undefined) {
            throw new Error('Required parameter entryId was null or undefined when calling postReplyGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (message !== undefined) {
            localVarFormParams['message'] = ObjectSerializer.serialize(message, "string");
        }

        if (attachment !== undefined) {
            localVarFormParams['attachment'] = ObjectSerializer.serialize(attachment, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Rate a discussion entry.  On success, the response will be 204 No Content with an empty body.
     * @summary Rate entry
     * @param courseId ID
     * @param topicId ID
     * @param entryId ID
     * @param rating A rating to set on this entry. Only 0 and 1 are accepted.
     */
    public async rateEntryCourses (courseId: string, topicId: string, entryId: string, rating?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/rating'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'entry_id' + '}', encodeURIComponent(String(entryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling rateEntryCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling rateEntryCourses.');
        }

        // verify required parameter 'entryId' is not null or undefined
        if (entryId === null || entryId === undefined) {
            throw new Error('Required parameter entryId was null or undefined when calling rateEntryCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (rating !== undefined) {
            localVarFormParams['rating'] = ObjectSerializer.serialize(rating, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Rate a discussion entry.  On success, the response will be 204 No Content with an empty body.
     * @summary Rate entry
     * @param groupId ID
     * @param topicId ID
     * @param entryId ID
     * @param rating A rating to set on this entry. Only 0 and 1 are accepted.
     */
    public async rateEntryGroups (groupId: string, topicId: string, entryId: string, rating?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/rating'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'entry_id' + '}', encodeURIComponent(String(entryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling rateEntryGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling rateEntryGroups.');
        }

        // verify required parameter 'entryId' is not null or undefined
        if (entryId === null || entryId === undefined) {
            throw new Error('Required parameter entryId was null or undefined when calling rateEntryGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (rating !== undefined) {
            localVarFormParams['rating'] = ObjectSerializer.serialize(rating, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Puts the pinned discussion topics in the specified order. All pinned topics should be included.
     * @summary Reorder pinned topics
     * @param courseId ID
     * @param order The ids of the pinned discussion topics in the desired order. (For example, \\\&quot;order&#x3D;104,102,103\\\&quot;.)
     */
    public async reorderPinnedTopicsCourses (courseId: string, order: Array<number>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/reorder'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling reorderPinnedTopicsCourses.');
        }

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling reorderPinnedTopicsCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (order !== undefined) {
            localVarFormParams['order'] = ObjectSerializer.serialize(order, "Array<number>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Puts the pinned discussion topics in the specified order. All pinned topics should be included.
     * @summary Reorder pinned topics
     * @param groupId ID
     * @param order The ids of the pinned discussion topics in the desired order. (For example, \\\&quot;order&#x3D;104,102,103\\\&quot;.)
     */
    public async reorderPinnedTopicsGroups (groupId: string, order: Array<number>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/reorder'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling reorderPinnedTopicsGroups.');
        }

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling reorderPinnedTopicsGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (order !== undefined) {
            localVarFormParams['order'] = ObjectSerializer.serialize(order, "Array<number>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Subscribe to a topic to receive notifications about new entries  On success, the response will be 204 No Content with an empty body
     * @summary Subscribe to a topic
     * @param courseId ID
     * @param topicId ID
     */
    public async subscribeToTopicCourses (courseId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/subscribed'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling subscribeToTopicCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling subscribeToTopicCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Subscribe to a topic to receive notifications about new entries  On success, the response will be 204 No Content with an empty body
     * @summary Subscribe to a topic
     * @param groupId ID
     * @param topicId ID
     */
    public async subscribeToTopicGroups (groupId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/subscribed'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling subscribeToTopicGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling subscribeToTopicGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Persists feedback on a discussion topic summary.
     * @summary Summary Feedback
     * @param courseId ID
     * @param topicId ID
     * @param summaryId ID
     * @param action Required The action to take on the summary. Possible values are: - \\\&quot;seen\\\&quot;: Marks the summary as seen. This action saves the feedback if it\\\&#39;s not already persisted. - \\\&quot;like\\\&quot;: Marks the summary as liked. - \\\&quot;dislike\\\&quot;: Marks the summary as disliked. - \\\&quot;reset_like\\\&quot;: Resets the like status of the summary. - \\\&quot;regenerate\\\&quot;: Regenerates the summary feedback. - \\\&quot;disable_summary\\\&quot;: Disables the summary feedback. Any other value will result in an error response.
     */
    public async summaryFeedbackCourses (courseId: string, topicId: string, summaryId: string, action?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/summaries/{summary_id}/feedback'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'summary_id' + '}', encodeURIComponent(String(summaryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling summaryFeedbackCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling summaryFeedbackCourses.');
        }

        // verify required parameter 'summaryId' is not null or undefined
        if (summaryId === null || summaryId === undefined) {
            throw new Error('Required parameter summaryId was null or undefined when calling summaryFeedbackCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (action !== undefined) {
            localVarFormParams['_action'] = ObjectSerializer.serialize(action, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Persists feedback on a discussion topic summary.
     * @summary Summary Feedback
     * @param groupId ID
     * @param topicId ID
     * @param summaryId ID
     * @param action Required The action to take on the summary. Possible values are: - \\\&quot;seen\\\&quot;: Marks the summary as seen. This action saves the feedback if it\\\&#39;s not already persisted. - \\\&quot;like\\\&quot;: Marks the summary as liked. - \\\&quot;dislike\\\&quot;: Marks the summary as disliked. - \\\&quot;reset_like\\\&quot;: Resets the like status of the summary. - \\\&quot;regenerate\\\&quot;: Regenerates the summary feedback. - \\\&quot;disable_summary\\\&quot;: Disables the summary feedback. Any other value will result in an error response.
     */
    public async summaryFeedbackGroups (groupId: string, topicId: string, summaryId: string, action?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/summaries/{summary_id}/feedback'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'summary_id' + '}', encodeURIComponent(String(summaryId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling summaryFeedbackGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling summaryFeedbackGroups.');
        }

        // verify required parameter 'summaryId' is not null or undefined
        if (summaryId === null || summaryId === undefined) {
            throw new Error('Required parameter summaryId was null or undefined when calling summaryFeedbackGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (action !== undefined) {
            localVarFormParams['_action'] = ObjectSerializer.serialize(action, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Unsubscribe from a topic to stop receiving notifications about new entries  On success, the response will be 204 No Content with an empty body
     * @summary Unsubscribe from a topic
     * @param courseId ID
     * @param topicId ID
     */
    public async unsubscribeFromTopicCourses (courseId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/subscribed'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling unsubscribeFromTopicCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling unsubscribeFromTopicCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Unsubscribe from a topic to stop receiving notifications about new entries  On success, the response will be 204 No Content with an empty body
     * @summary Unsubscribe from a topic
     * @param groupId ID
     * @param topicId ID
     */
    public async unsubscribeFromTopicGroups (groupId: string, topicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/subscribed'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling unsubscribeFromTopicGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling unsubscribeFromTopicGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update an existing discussion entry.  The entry must have been created by the current user, or the current user must have admin rights to the discussion. If the edit is not allowed, a 401 will be returned.
     * @summary Update an entry
     * @param courseId ID
     * @param topicId ID
     * @param id ID
     * @param message The updated body of the entry.
     */
    public async updateEntryCourses (courseId: string, topicId: string, id: string, message?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateEntryCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling updateEntryCourses.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateEntryCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (message !== undefined) {
            localVarFormParams['message'] = ObjectSerializer.serialize(message, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update an existing discussion entry.  The entry must have been created by the current user, or the current user must have admin rights to the discussion. If the edit is not allowed, a 401 will be returned.
     * @summary Update an entry
     * @param groupId ID
     * @param topicId ID
     * @param id ID
     * @param message The updated body of the entry.
     */
    public async updateEntryGroups (groupId: string, topicId: string, id: string, message?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{id}'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling updateEntryGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling updateEntryGroups.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateEntryGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (message !== undefined) {
            localVarFormParams['message'] = ObjectSerializer.serialize(message, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update an existing discussion topic for the course or group.
     * @summary Update a topic
     * @param courseId ID
     * @param topicId ID
     * @param title no description
     * @param message no description
     * @param discussionType The type of discussion. Defaults to side_comment or not_threaded if not value is given. Accepted values are \\\&#39;side_comment\\\&#39;, \\\&#39;not_threaded\\\&#39; for discussions that only allow one level of nested comments, and \\\&#39;threaded\\\&#39; for fully threaded discussions.
     * @param published Whether this topic is published (true) or draft state (false). Only teachers and TAs have the ability to create draft state topics.
     * @param delayedPostAt If a timestamp is given, the topic will not be published until that time.
     * @param lockAt If a timestamp is given, the topic will be scheduled to lock at the provided timestamp. If the timestamp is in the past, the topic will be locked.
     * @param podcastEnabled If true, the topic will have an associated podcast feed.
     * @param podcastHasStudentPosts If true, the podcast will include posts from students as well. Implies podcast_enabled.
     * @param requireInitialPost If true then a user may not respond to other replies until that user has made an initial reply. Defaults to false.
     * @param assignment To create an assignment discussion, pass the assignment parameters as a sub-object. See the {api:AssignmentsApiController#create Create an Assignment API} for the available parameters. The name parameter will be ignored, as it\\\&#39;s taken from the discussion title. If you want to make a discussion that was an assignment NOT an assignment, pass set_assignment &#x3D; false as part of the assignment object
     * @param isAnnouncement If true, this topic is an announcement. It will appear in the announcement\\\&#39;s section rather than the discussions section. This requires announcment-posting permissions.
     * @param pinned If true, this topic will be listed in the \\\&quot;Pinned Discussion\\\&quot; section
     * @param positionAfter By default, discussions are sorted chronologically by creation date, you can pass the id of another topic to have this one show up after the other when they are listed.
     * @param groupCategoryId If present, the topic will become a group discussion assigned to the group.
     * @param allowRating If true, users will be allowed to rate entries.
     * @param onlyGradersCanRate If true, only graders will be allowed to rate entries.
     * @param sortOrder Default sort order of the discussion. Accepted values are \\\&quot;asc\\\&quot;, \\\&quot;desc\\\&quot;.
     * @param sortOrderLocked If true, users cannot choose their prefered sort order
     * @param expanded If true, thread will be expanded by default
     * @param expandedLocked If true, users cannot choose their prefered thread expansion setting
     * @param sortByRating (DEPRECATED) If true, entries will be sorted by rating.
     * @param specificSections A comma-separated list of sections ids to which the discussion topic should be made specific too.  If it is not desired to make the discussion topic specific to sections, then this parameter may be omitted or set to \\\&quot;all\\\&quot;.  Can only be present only on announcements and only those that are for a course (as opposed to a group).
     * @param lockComment If is_announcement and lock_comment are true, ‘Allow Participants to Comment’ setting is disabled.
     */
    public async updateTopicCourses (courseId: string, topicId: string, title?: string, message?: string, discussionType?: string, published?: boolean, delayedPostAt?: Date, lockAt?: Date, podcastEnabled?: boolean, podcastHasStudentPosts?: boolean, requireInitialPost?: boolean, assignment?: any, isAnnouncement?: boolean, pinned?: boolean, positionAfter?: string, groupCategoryId?: number, allowRating?: boolean, onlyGradersCanRate?: boolean, sortOrder?: string, sortOrderLocked?: boolean, expanded?: boolean, expandedLocked?: boolean, sortByRating?: boolean, specificSections?: string, lockComment?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{topic_id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateTopicCourses.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling updateTopicCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (title !== undefined) {
            localVarFormParams['title'] = ObjectSerializer.serialize(title, "string");
        }

        if (message !== undefined) {
            localVarFormParams['message'] = ObjectSerializer.serialize(message, "string");
        }

        if (discussionType !== undefined) {
            localVarFormParams['discussion_type'] = ObjectSerializer.serialize(discussionType, "string");
        }

        if (published !== undefined) {
            localVarFormParams['published'] = ObjectSerializer.serialize(published, "boolean");
        }

        if (delayedPostAt !== undefined) {
            localVarFormParams['delayed_post_at'] = ObjectSerializer.serialize(delayedPostAt, "Date");
        }

        if (lockAt !== undefined) {
            localVarFormParams['lock_at'] = ObjectSerializer.serialize(lockAt, "Date");
        }

        if (podcastEnabled !== undefined) {
            localVarFormParams['podcast_enabled'] = ObjectSerializer.serialize(podcastEnabled, "boolean");
        }

        if (podcastHasStudentPosts !== undefined) {
            localVarFormParams['podcast_has_student_posts'] = ObjectSerializer.serialize(podcastHasStudentPosts, "boolean");
        }

        if (requireInitialPost !== undefined) {
            localVarFormParams['require_initial_post'] = ObjectSerializer.serialize(requireInitialPost, "boolean");
        }

        if (assignment !== undefined) {
            localVarFormParams['assignment'] = ObjectSerializer.serialize(assignment, "any");
        }

        if (isAnnouncement !== undefined) {
            localVarFormParams['is_announcement'] = ObjectSerializer.serialize(isAnnouncement, "boolean");
        }

        if (pinned !== undefined) {
            localVarFormParams['pinned'] = ObjectSerializer.serialize(pinned, "boolean");
        }

        if (positionAfter !== undefined) {
            localVarFormParams['position_after'] = ObjectSerializer.serialize(positionAfter, "string");
        }

        if (groupCategoryId !== undefined) {
            localVarFormParams['group_category_id'] = ObjectSerializer.serialize(groupCategoryId, "number");
        }

        if (allowRating !== undefined) {
            localVarFormParams['allow_rating'] = ObjectSerializer.serialize(allowRating, "boolean");
        }

        if (onlyGradersCanRate !== undefined) {
            localVarFormParams['only_graders_can_rate'] = ObjectSerializer.serialize(onlyGradersCanRate, "boolean");
        }

        if (sortOrder !== undefined) {
            localVarFormParams['sort_order'] = ObjectSerializer.serialize(sortOrder, "string");
        }

        if (sortOrderLocked !== undefined) {
            localVarFormParams['sort_order_locked'] = ObjectSerializer.serialize(sortOrderLocked, "boolean");
        }

        if (expanded !== undefined) {
            localVarFormParams['expanded'] = ObjectSerializer.serialize(expanded, "boolean");
        }

        if (expandedLocked !== undefined) {
            localVarFormParams['expanded_locked'] = ObjectSerializer.serialize(expandedLocked, "boolean");
        }

        if (sortByRating !== undefined) {
            localVarFormParams['sort_by_rating'] = ObjectSerializer.serialize(sortByRating, "boolean");
        }

        if (specificSections !== undefined) {
            localVarFormParams['specific_sections'] = ObjectSerializer.serialize(specificSections, "string");
        }

        if (lockComment !== undefined) {
            localVarFormParams['lock_comment'] = ObjectSerializer.serialize(lockComment, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update an existing discussion topic for the course or group.
     * @summary Update a topic
     * @param groupId ID
     * @param topicId ID
     * @param title no description
     * @param message no description
     * @param discussionType The type of discussion. Defaults to side_comment or not_threaded if not value is given. Accepted values are \\\&#39;side_comment\\\&#39;, \\\&#39;not_threaded\\\&#39; for discussions that only allow one level of nested comments, and \\\&#39;threaded\\\&#39; for fully threaded discussions.
     * @param published Whether this topic is published (true) or draft state (false). Only teachers and TAs have the ability to create draft state topics.
     * @param delayedPostAt If a timestamp is given, the topic will not be published until that time.
     * @param lockAt If a timestamp is given, the topic will be scheduled to lock at the provided timestamp. If the timestamp is in the past, the topic will be locked.
     * @param podcastEnabled If true, the topic will have an associated podcast feed.
     * @param podcastHasStudentPosts If true, the podcast will include posts from students as well. Implies podcast_enabled.
     * @param requireInitialPost If true then a user may not respond to other replies until that user has made an initial reply. Defaults to false.
     * @param assignment To create an assignment discussion, pass the assignment parameters as a sub-object. See the {api:AssignmentsApiController#create Create an Assignment API} for the available parameters. The name parameter will be ignored, as it\\\&#39;s taken from the discussion title. If you want to make a discussion that was an assignment NOT an assignment, pass set_assignment &#x3D; false as part of the assignment object
     * @param isAnnouncement If true, this topic is an announcement. It will appear in the announcement\\\&#39;s section rather than the discussions section. This requires announcment-posting permissions.
     * @param pinned If true, this topic will be listed in the \\\&quot;Pinned Discussion\\\&quot; section
     * @param positionAfter By default, discussions are sorted chronologically by creation date, you can pass the id of another topic to have this one show up after the other when they are listed.
     * @param groupCategoryId If present, the topic will become a group discussion assigned to the group.
     * @param allowRating If true, users will be allowed to rate entries.
     * @param onlyGradersCanRate If true, only graders will be allowed to rate entries.
     * @param sortOrder Default sort order of the discussion. Accepted values are \\\&quot;asc\\\&quot;, \\\&quot;desc\\\&quot;.
     * @param sortOrderLocked If true, users cannot choose their prefered sort order
     * @param expanded If true, thread will be expanded by default
     * @param expandedLocked If true, users cannot choose their prefered thread expansion setting
     * @param sortByRating (DEPRECATED) If true, entries will be sorted by rating.
     * @param specificSections A comma-separated list of sections ids to which the discussion topic should be made specific too.  If it is not desired to make the discussion topic specific to sections, then this parameter may be omitted or set to \\\&quot;all\\\&quot;.  Can only be present only on announcements and only those that are for a course (as opposed to a group).
     * @param lockComment If is_announcement and lock_comment are true, ‘Allow Participants to Comment’ setting is disabled.
     */
    public async updateTopicGroups (groupId: string, topicId: string, title?: string, message?: string, discussionType?: string, published?: boolean, delayedPostAt?: Date, lockAt?: Date, podcastEnabled?: boolean, podcastHasStudentPosts?: boolean, requireInitialPost?: boolean, assignment?: any, isAnnouncement?: boolean, pinned?: boolean, positionAfter?: string, groupCategoryId?: number, allowRating?: boolean, onlyGradersCanRate?: boolean, sortOrder?: string, sortOrderLocked?: boolean, expanded?: boolean, expandedLocked?: boolean, sortByRating?: boolean, specificSections?: string, lockComment?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/discussion_topics/{topic_id}'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'topic_id' + '}', encodeURIComponent(String(topicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling updateTopicGroups.');
        }

        // verify required parameter 'topicId' is not null or undefined
        if (topicId === null || topicId === undefined) {
            throw new Error('Required parameter topicId was null or undefined when calling updateTopicGroups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (title !== undefined) {
            localVarFormParams['title'] = ObjectSerializer.serialize(title, "string");
        }

        if (message !== undefined) {
            localVarFormParams['message'] = ObjectSerializer.serialize(message, "string");
        }

        if (discussionType !== undefined) {
            localVarFormParams['discussion_type'] = ObjectSerializer.serialize(discussionType, "string");
        }

        if (published !== undefined) {
            localVarFormParams['published'] = ObjectSerializer.serialize(published, "boolean");
        }

        if (delayedPostAt !== undefined) {
            localVarFormParams['delayed_post_at'] = ObjectSerializer.serialize(delayedPostAt, "Date");
        }

        if (lockAt !== undefined) {
            localVarFormParams['lock_at'] = ObjectSerializer.serialize(lockAt, "Date");
        }

        if (podcastEnabled !== undefined) {
            localVarFormParams['podcast_enabled'] = ObjectSerializer.serialize(podcastEnabled, "boolean");
        }

        if (podcastHasStudentPosts !== undefined) {
            localVarFormParams['podcast_has_student_posts'] = ObjectSerializer.serialize(podcastHasStudentPosts, "boolean");
        }

        if (requireInitialPost !== undefined) {
            localVarFormParams['require_initial_post'] = ObjectSerializer.serialize(requireInitialPost, "boolean");
        }

        if (assignment !== undefined) {
            localVarFormParams['assignment'] = ObjectSerializer.serialize(assignment, "any");
        }

        if (isAnnouncement !== undefined) {
            localVarFormParams['is_announcement'] = ObjectSerializer.serialize(isAnnouncement, "boolean");
        }

        if (pinned !== undefined) {
            localVarFormParams['pinned'] = ObjectSerializer.serialize(pinned, "boolean");
        }

        if (positionAfter !== undefined) {
            localVarFormParams['position_after'] = ObjectSerializer.serialize(positionAfter, "string");
        }

        if (groupCategoryId !== undefined) {
            localVarFormParams['group_category_id'] = ObjectSerializer.serialize(groupCategoryId, "number");
        }

        if (allowRating !== undefined) {
            localVarFormParams['allow_rating'] = ObjectSerializer.serialize(allowRating, "boolean");
        }

        if (onlyGradersCanRate !== undefined) {
            localVarFormParams['only_graders_can_rate'] = ObjectSerializer.serialize(onlyGradersCanRate, "boolean");
        }

        if (sortOrder !== undefined) {
            localVarFormParams['sort_order'] = ObjectSerializer.serialize(sortOrder, "string");
        }

        if (sortOrderLocked !== undefined) {
            localVarFormParams['sort_order_locked'] = ObjectSerializer.serialize(sortOrderLocked, "boolean");
        }

        if (expanded !== undefined) {
            localVarFormParams['expanded'] = ObjectSerializer.serialize(expanded, "boolean");
        }

        if (expandedLocked !== undefined) {
            localVarFormParams['expanded_locked'] = ObjectSerializer.serialize(expandedLocked, "boolean");
        }

        if (sortByRating !== undefined) {
            localVarFormParams['sort_by_rating'] = ObjectSerializer.serialize(sortByRating, "boolean");
        }

        if (specificSections !== undefined) {
            localVarFormParams['specific_sections'] = ObjectSerializer.serialize(specificSections, "string");
        }

        if (lockComment !== undefined) {
            localVarFormParams['lock_comment'] = ObjectSerializer.serialize(lockComment, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
