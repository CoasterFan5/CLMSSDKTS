/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Module } from '../model/module';
import { ModuleAssignmentOverride } from '../model/moduleAssignmentOverride';
import { ModuleItem } from '../model/moduleItem';
import { ModuleItemSequence } from '../model/moduleItemSequence';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ModulesApiApiKeys {
}

export class ModulesApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ModulesApiApiKeys, value: string) {
        (this.authentications as any)[ModulesApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create and return a new module
     * @summary Create a module
     * @param courseId ID
     * @param moduleName The name of the module
     * @param moduleUnlockAt The date the module will unlock
     * @param modulePosition The position of this module in the course (1-based)
     * @param moduleRequireSequentialProgress Whether module items must be unlocked in order
     * @param modulePrerequisiteModuleIds IDs of Modules that must be completed before this one is unlocked. Prerequisite modules must precede this module (i.e. have a lower position value), otherwise they will be ignored
     * @param modulePublishFinalGrade Whether to publish the student\\\&#39;s final grade for the course upon completion of this module.
     */
    public async createModule (courseId: string, moduleName: string, moduleUnlockAt?: Date, modulePosition?: number, moduleRequireSequentialProgress?: boolean, modulePrerequisiteModuleIds?: Array<string>, modulePublishFinalGrade?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Module;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createModule.');
        }

        // verify required parameter 'moduleName' is not null or undefined
        if (moduleName === null || moduleName === undefined) {
            throw new Error('Required parameter moduleName was null or undefined when calling createModule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (moduleName !== undefined) {
            localVarFormParams['module[name]'] = ObjectSerializer.serialize(moduleName, "string");
        }

        if (moduleUnlockAt !== undefined) {
            localVarFormParams['module[unlock_at]'] = ObjectSerializer.serialize(moduleUnlockAt, "Date");
        }

        if (modulePosition !== undefined) {
            localVarFormParams['module[position]'] = ObjectSerializer.serialize(modulePosition, "number");
        }

        if (moduleRequireSequentialProgress !== undefined) {
            localVarFormParams['module[require_sequential_progress]'] = ObjectSerializer.serialize(moduleRequireSequentialProgress, "boolean");
        }

        if (modulePrerequisiteModuleIds !== undefined) {
            localVarFormParams['module[prerequisite_module_ids]'] = ObjectSerializer.serialize(modulePrerequisiteModuleIds, "Array<string>");
        }

        if (modulePublishFinalGrade !== undefined) {
            localVarFormParams['module[publish_final_grade]'] = ObjectSerializer.serialize(modulePublishFinalGrade, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Module;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Module");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create and return a new module item
     * @summary Create a module item
     * @param courseId ID
     * @param moduleId ID
     * @param moduleItemType The type of content linked to the item
     * @param moduleItemContentId The id of the content to link to the module item. Required, except for \\\&#39;ExternalUrl\\\&#39;, \\\&#39;Page\\\&#39;, and \\\&#39;SubHeader\\\&#39; types.
     * @param moduleItemTitle The name of the module item and associated content
     * @param moduleItemPosition The position of this item in the module (1-based).
     * @param moduleItemIndent 0-based indent level; module items may be indented to show a hierarchy
     * @param moduleItemPageUrl Suffix for the linked wiki page (e.g. \\\&#39;front-page\\\&#39;). Required for \\\&#39;Page\\\&#39; type.
     * @param moduleItemExternalUrl External url that the item points to. [Required for \\\&#39;ExternalUrl\\\&#39; and \\\&#39;ExternalTool\\\&#39; types.
     * @param moduleItemNewTab Whether the external tool opens in a new tab. Only applies to \\\&#39;ExternalTool\\\&#39; type.
     * @param moduleItemCompletionRequirementType Completion requirement for this module item. \\\&quot;must_view\\\&quot;: Applies to all item types \\\&quot;must_contribute\\\&quot;: Only applies to \\\&quot;Assignment\\\&quot;, \\\&quot;Discussion\\\&quot;, and \\\&quot;Page\\\&quot; types \\\&quot;must_submit\\\&quot;, \\\&quot;min_score\\\&quot;: Only apply to \\\&quot;Assignment\\\&quot; and \\\&quot;Quiz\\\&quot; types \\\&quot;must_mark_done\\\&quot;: Only applies to \\\&quot;Assignment\\\&quot; and \\\&quot;Page\\\&quot; types Inapplicable types will be ignored
     * @param moduleItemCompletionRequirementMinScore Minimum score required to complete. Required for completion_requirement type \\\&#39;min_score\\\&#39;.
     * @param moduleItemIframeWidth Width of the ExternalTool on launch
     * @param moduleItemIframeHeight Height of the ExternalTool on launch
     */
    public async createModuleItem (courseId: string, moduleId: string, moduleItemType: string, moduleItemContentId: string, moduleItemTitle?: string, moduleItemPosition?: number, moduleItemIndent?: number, moduleItemPageUrl?: string, moduleItemExternalUrl?: string, moduleItemNewTab?: boolean, moduleItemCompletionRequirementType?: string, moduleItemCompletionRequirementMinScore?: number, moduleItemIframeWidth?: number, moduleItemIframeHeight?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ModuleItem;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{module_id}/items'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'module_id' + '}', encodeURIComponent(String(moduleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createModuleItem.');
        }

        // verify required parameter 'moduleId' is not null or undefined
        if (moduleId === null || moduleId === undefined) {
            throw new Error('Required parameter moduleId was null or undefined when calling createModuleItem.');
        }

        // verify required parameter 'moduleItemType' is not null or undefined
        if (moduleItemType === null || moduleItemType === undefined) {
            throw new Error('Required parameter moduleItemType was null or undefined when calling createModuleItem.');
        }

        // verify required parameter 'moduleItemContentId' is not null or undefined
        if (moduleItemContentId === null || moduleItemContentId === undefined) {
            throw new Error('Required parameter moduleItemContentId was null or undefined when calling createModuleItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (moduleItemTitle !== undefined) {
            localVarFormParams['module_item[title]'] = ObjectSerializer.serialize(moduleItemTitle, "string");
        }

        if (moduleItemType !== undefined) {
            localVarFormParams['module_item[type]'] = ObjectSerializer.serialize(moduleItemType, "string");
        }

        if (moduleItemContentId !== undefined) {
            localVarFormParams['module_item[content_id]'] = ObjectSerializer.serialize(moduleItemContentId, "string");
        }

        if (moduleItemPosition !== undefined) {
            localVarFormParams['module_item[position]'] = ObjectSerializer.serialize(moduleItemPosition, "number");
        }

        if (moduleItemIndent !== undefined) {
            localVarFormParams['module_item[indent]'] = ObjectSerializer.serialize(moduleItemIndent, "number");
        }

        if (moduleItemPageUrl !== undefined) {
            localVarFormParams['module_item[page_url]'] = ObjectSerializer.serialize(moduleItemPageUrl, "string");
        }

        if (moduleItemExternalUrl !== undefined) {
            localVarFormParams['module_item[external_url]'] = ObjectSerializer.serialize(moduleItemExternalUrl, "string");
        }

        if (moduleItemNewTab !== undefined) {
            localVarFormParams['module_item[new_tab]'] = ObjectSerializer.serialize(moduleItemNewTab, "boolean");
        }

        if (moduleItemCompletionRequirementType !== undefined) {
            localVarFormParams['module_item[completion_requirement][type]'] = ObjectSerializer.serialize(moduleItemCompletionRequirementType, "string");
        }

        if (moduleItemCompletionRequirementMinScore !== undefined) {
            localVarFormParams['module_item[completion_requirement][min_score]'] = ObjectSerializer.serialize(moduleItemCompletionRequirementMinScore, "number");
        }

        if (moduleItemIframeWidth !== undefined) {
            localVarFormParams['module_item[iframe][width]'] = ObjectSerializer.serialize(moduleItemIframeWidth, "number");
        }

        if (moduleItemIframeHeight !== undefined) {
            localVarFormParams['module_item[iframe][height]'] = ObjectSerializer.serialize(moduleItemIframeHeight, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ModuleItem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ModuleItem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete a module
     * @summary Delete module
     * @param courseId ID
     * @param id ID
     */
    public async deleteModule (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Module;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling deleteModule.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteModule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Module;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Module");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete a module item
     * @summary Delete module item
     * @param courseId ID
     * @param moduleId ID
     * @param id ID
     */
    public async deleteModuleItem (courseId: string, moduleId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ModuleItem;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{module_id}/items/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'module_id' + '}', encodeURIComponent(String(moduleId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling deleteModuleItem.');
        }

        // verify required parameter 'moduleId' is not null or undefined
        if (moduleId === null || moduleId === undefined) {
            throw new Error('Required parameter moduleId was null or undefined when calling deleteModuleItem.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteModuleItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ModuleItem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ModuleItem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Given an asset in a course, find the ModuleItem it belongs to, the previous and next Module Items in the course sequence, and also any applicable mastery path rules
     * @summary Get module item sequence
     * @param courseId ID
     * @param assetType The type of asset to find module sequence information for. Use the ModuleItem if it is known (e.g., the user navigated from a module item), since this will avoid ambiguity if the asset appears more than once in the module sequence.
     * @param assetId The id of the asset (or the url in the case of a Page)
     */
    public async getModuleItemSequence (courseId: string, assetType?: 'ModuleItem' | 'File' | 'Page' | 'Discussion' | 'Assignment' | 'Quiz' | 'ExternalTool', assetId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ModuleItemSequence;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/module_item_sequence'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getModuleItemSequence.');
        }

        if (assetType !== undefined) {
            localVarQueryParameters['asset_type'] = ObjectSerializer.serialize(assetType, "'ModuleItem' | 'File' | 'Page' | 'Discussion' | 'Assignment' | 'Quiz' | 'ExternalTool'");
        }

        if (assetId !== undefined) {
            localVarQueryParameters['asset_id'] = ObjectSerializer.serialize(assetId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ModuleItemSequence;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ModuleItemSequence");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of the items in a module
     * @summary List module items
     * @param courseId ID
     * @param moduleId ID
     * @param include If included, will return additional details specific to the content associated with each item. Refer to the {api:Modules:Module%20Item Module Item specification} for more details. Includes standard lock information for each item.
     * @param searchTerm The partial title of the items to match and return.
     * @param studentId Returns module completion information for the student with this id.
     */
    public async listModuleItems (courseId: string, moduleId: string, include?: Array<string>, searchTerm?: string, studentId?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<ModuleItem>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{module_id}/items'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'module_id' + '}', encodeURIComponent(String(moduleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listModuleItems.');
        }

        // verify required parameter 'moduleId' is not null or undefined
        if (moduleId === null || moduleId === undefined) {
            throw new Error('Required parameter moduleId was null or undefined when calling listModuleItems.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['search_term'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (studentId !== undefined) {
            localVarQueryParameters['student_id'] = ObjectSerializer.serialize(studentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<ModuleItem>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<ModuleItem>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns a paginated list of AssignmentOverrides that apply to the ContextModule.
     * @summary List a module\'s overrides
     * @param courseId ID
     * @param contextModuleId ID
     */
    public async listModuleSOverrides (courseId: string, contextModuleId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<ModuleAssignmentOverride>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{context_module_id}/assignment_overrides'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'context_module_id' + '}', encodeURIComponent(String(contextModuleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listModuleSOverrides.');
        }

        // verify required parameter 'contextModuleId' is not null or undefined
        if (contextModuleId === null || contextModuleId === undefined) {
            throw new Error('Required parameter contextModuleId was null or undefined when calling listModuleSOverrides.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<ModuleAssignmentOverride>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<ModuleAssignmentOverride>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of the modules in a course
     * @summary List modules
     * @param courseId ID
     * @param include - \&quot;items\&quot;: Return module items inline if possible.   This parameter suggests that Canvas return module items directly   in the Module object JSON, to avoid having to make separate API   requests for each module when enumerating modules and items. Canvas   is free to omit \&#39;items\&#39; for any particular module if it deems them   too numerous to return inline. Callers must be prepared to use the   {api:ContextModuleItemsApiController#index List Module Items API}   if items are not returned. - \&quot;content_details\&quot;: Requires \&#39;items\&#39;. Returns additional   details with module items specific to their associated content items.   Includes standard lock information for each item.
     * @param searchTerm The partial name of the modules (and module items, if \&#39;items\&#39; is specified with include[]) to match and return.
     * @param studentId Returns module completion information for the student with this id.
     */
    public async listModules (courseId: string, include?: Array<string>, searchTerm?: string, studentId?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Module>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listModules.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['search_term'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (studentId !== undefined) {
            localVarQueryParameters['student_id'] = ObjectSerializer.serialize(studentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Module>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Module>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Mark a module item as done/not done. Use HTTP method PUT to mark as done, and DELETE to mark as not done.
     * @summary Mark module item as done/not done
     * @param courseId ID
     * @param moduleId ID
     * @param id ID
     */
    public async markModuleItemAsDoneNotDone (courseId: string, moduleId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{module_id}/items/{id}/done'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'module_id' + '}', encodeURIComponent(String(moduleId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markModuleItemAsDoneNotDone.');
        }

        // verify required parameter 'moduleId' is not null or undefined
        if (moduleId === null || moduleId === undefined) {
            throw new Error('Required parameter moduleId was null or undefined when calling markModuleItemAsDoneNotDone.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling markModuleItemAsDoneNotDone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Fulfills \"must view\" requirement for a module item. It is generally not necessary to do this explicitly, but it is provided for applications that need to access external content directly (bypassing the html_url redirect that normally allows Canvas to fulfill \"must view\" requirements).  This endpoint cannot be used to complete requirements on locked or unpublished module items.
     * @summary Mark module item read
     * @param courseId ID
     * @param moduleId ID
     * @param id ID
     */
    public async markModuleItemRead (courseId: string, moduleId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{module_id}/items/{id}/mark_read'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'module_id' + '}', encodeURIComponent(String(moduleId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling markModuleItemRead.');
        }

        // verify required parameter 'moduleId' is not null or undefined
        if (moduleId === null || moduleId === undefined) {
            throw new Error('Required parameter moduleId was null or undefined when calling markModuleItemRead.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling markModuleItemRead.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Resets module progressions to their default locked state and recalculates them based on the current requirements.  Adding progression requirements to an active course will not lock students out of modules they have already unlocked unless this action is called.
     * @summary Re-lock module progressions
     * @param courseId ID
     * @param id ID
     */
    public async reLockModuleProgressions (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Module;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{id}/relock'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling reLockModuleProgressions.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling reLockModuleProgressions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Module;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Module");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Select a mastery path when module item includes several possible paths. Requires Mastery Paths feature to be enabled.  Returns a compound document with the assignments included in the given path and any module items related to those assignments
     * @summary Select a mastery path
     * @param courseId ID
     * @param moduleId ID
     * @param id ID
     * @param assignmentSetId Assignment set chosen, as specified in the mastery_paths portion of the context module item response
     * @param studentId Which student the selection applies to.  If not specified, current user is implied.
     */
    public async selectMasteryPath (courseId: string, moduleId: string, id: string, assignmentSetId?: string, studentId?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{module_id}/items/{id}/select_mastery_path'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'module_id' + '}', encodeURIComponent(String(moduleId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling selectMasteryPath.');
        }

        // verify required parameter 'moduleId' is not null or undefined
        if (moduleId === null || moduleId === undefined) {
            throw new Error('Required parameter moduleId was null or undefined when calling selectMasteryPath.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling selectMasteryPath.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (assignmentSetId !== undefined) {
            localVarFormParams['assignment_set_id'] = ObjectSerializer.serialize(assignmentSetId, "string");
        }

        if (studentId !== undefined) {
            localVarFormParams['student_id'] = ObjectSerializer.serialize(studentId, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get information about a single module
     * @summary Show module
     * @param courseId ID
     * @param id ID
     * @param include - \&quot;items\&quot;: Return module items inline if possible.   This parameter suggests that Canvas return module items directly   in the Module object JSON, to avoid having to make separate API   requests for each module when enumerating modules and items. Canvas   is free to omit \&#39;items\&#39; for any particular module if it deems them   too numerous to return inline. Callers must be prepared to use the   {api:ContextModuleItemsApiController#index List Module Items API}   if items are not returned. - \&quot;content_details\&quot;: Requires \&#39;items\&#39;. Returns additional   details with module items specific to their associated content items.   Includes standard lock information for each item.
     * @param studentId Returns module completion information for the student with this id.
     */
    public async showModule (courseId: string, id: string, include?: Array<string>, studentId?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Module;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling showModule.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling showModule.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (studentId !== undefined) {
            localVarQueryParameters['student_id'] = ObjectSerializer.serialize(studentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Module;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Module");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get information about a single module item
     * @summary Show module item
     * @param courseId ID
     * @param moduleId ID
     * @param id ID
     * @param include If included, will return additional details specific to the content associated with this item. Refer to the {api:Modules:Module%20Item Module Item specification} for more details. Includes standard lock information for each item.
     * @param studentId Returns module completion information for the student with this id.
     */
    public async showModuleItem (courseId: string, moduleId: string, id: string, include?: Array<string>, studentId?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ModuleItem;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{module_id}/items/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'module_id' + '}', encodeURIComponent(String(moduleId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling showModuleItem.');
        }

        // verify required parameter 'moduleId' is not null or undefined
        if (moduleId === null || moduleId === undefined) {
            throw new Error('Required parameter moduleId was null or undefined when calling showModuleItem.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling showModuleItem.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (studentId !== undefined) {
            localVarQueryParameters['student_id'] = ObjectSerializer.serialize(studentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ModuleItem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ModuleItem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update and return an existing module
     * @summary Update a module
     * @param courseId ID
     * @param id ID
     * @param moduleName The name of the module
     * @param moduleUnlockAt The date the module will unlock
     * @param modulePosition The position of the module in the course (1-based)
     * @param moduleRequireSequentialProgress Whether module items must be unlocked in order
     * @param modulePrerequisiteModuleIds IDs of Modules that must be completed before this one is unlocked Prerequisite modules must precede this module (i.e. have a lower position value), otherwise they will be ignored
     * @param modulePublishFinalGrade Whether to publish the student\\\&#39;s final grade for the course upon completion of this module.
     * @param modulePublished Whether the module is published and visible to students
     */
    public async updateModule (courseId: string, id: string, moduleName?: string, moduleUnlockAt?: Date, modulePosition?: number, moduleRequireSequentialProgress?: boolean, modulePrerequisiteModuleIds?: Array<string>, modulePublishFinalGrade?: boolean, modulePublished?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Module;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateModule.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateModule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (moduleName !== undefined) {
            localVarFormParams['module[name]'] = ObjectSerializer.serialize(moduleName, "string");
        }

        if (moduleUnlockAt !== undefined) {
            localVarFormParams['module[unlock_at]'] = ObjectSerializer.serialize(moduleUnlockAt, "Date");
        }

        if (modulePosition !== undefined) {
            localVarFormParams['module[position]'] = ObjectSerializer.serialize(modulePosition, "number");
        }

        if (moduleRequireSequentialProgress !== undefined) {
            localVarFormParams['module[require_sequential_progress]'] = ObjectSerializer.serialize(moduleRequireSequentialProgress, "boolean");
        }

        if (modulePrerequisiteModuleIds !== undefined) {
            localVarFormParams['module[prerequisite_module_ids]'] = ObjectSerializer.serialize(modulePrerequisiteModuleIds, "Array<string>");
        }

        if (modulePublishFinalGrade !== undefined) {
            localVarFormParams['module[publish_final_grade]'] = ObjectSerializer.serialize(modulePublishFinalGrade, "boolean");
        }

        if (modulePublished !== undefined) {
            localVarFormParams['module[published]'] = ObjectSerializer.serialize(modulePublished, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Module;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Module");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update and return an existing module item
     * @summary Update a module item
     * @param courseId ID
     * @param moduleId ID
     * @param id ID
     * @param moduleItemTitle The name of the module item
     * @param moduleItemPosition The position of this item in the module (1-based)
     * @param moduleItemIndent 0-based indent level; module items may be indented to show a hierarchy
     * @param moduleItemExternalUrl External url that the item points to. Only applies to \\\&#39;ExternalUrl\\\&#39; type.
     * @param moduleItemNewTab Whether the external tool opens in a new tab. Only applies to \\\&#39;ExternalTool\\\&#39; type.
     * @param moduleItemCompletionRequirementType Completion requirement for this module item. \\\&quot;must_view\\\&quot;: Applies to all item types \\\&quot;must_contribute\\\&quot;: Only applies to \\\&quot;Assignment\\\&quot;, \\\&quot;Discussion\\\&quot;, and \\\&quot;Page\\\&quot; types \\\&quot;must_submit\\\&quot;, \\\&quot;min_score\\\&quot;: Only apply to \\\&quot;Assignment\\\&quot; and \\\&quot;Quiz\\\&quot; types \\\&quot;must_mark_done\\\&quot;: Only applies to \\\&quot;Assignment\\\&quot; and \\\&quot;Page\\\&quot; types Inapplicable types will be ignored
     * @param moduleItemCompletionRequirementMinScore Minimum score required to complete, Required for completion_requirement type \\\&#39;min_score\\\&#39;.
     * @param moduleItemPublished Whether the module item is published and visible to students.
     * @param moduleItemModuleId Move this item to another module by specifying the target module id here. The target module must be in the same course.
     */
    public async updateModuleItem (courseId: string, moduleId: string, id: string, moduleItemTitle?: string, moduleItemPosition?: number, moduleItemIndent?: number, moduleItemExternalUrl?: string, moduleItemNewTab?: boolean, moduleItemCompletionRequirementType?: string, moduleItemCompletionRequirementMinScore?: number, moduleItemPublished?: boolean, moduleItemModuleId?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ModuleItem;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{module_id}/items/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'module_id' + '}', encodeURIComponent(String(moduleId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateModuleItem.');
        }

        // verify required parameter 'moduleId' is not null or undefined
        if (moduleId === null || moduleId === undefined) {
            throw new Error('Required parameter moduleId was null or undefined when calling updateModuleItem.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateModuleItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (moduleItemTitle !== undefined) {
            localVarFormParams['module_item[title]'] = ObjectSerializer.serialize(moduleItemTitle, "string");
        }

        if (moduleItemPosition !== undefined) {
            localVarFormParams['module_item[position]'] = ObjectSerializer.serialize(moduleItemPosition, "number");
        }

        if (moduleItemIndent !== undefined) {
            localVarFormParams['module_item[indent]'] = ObjectSerializer.serialize(moduleItemIndent, "number");
        }

        if (moduleItemExternalUrl !== undefined) {
            localVarFormParams['module_item[external_url]'] = ObjectSerializer.serialize(moduleItemExternalUrl, "string");
        }

        if (moduleItemNewTab !== undefined) {
            localVarFormParams['module_item[new_tab]'] = ObjectSerializer.serialize(moduleItemNewTab, "boolean");
        }

        if (moduleItemCompletionRequirementType !== undefined) {
            localVarFormParams['module_item[completion_requirement][type]'] = ObjectSerializer.serialize(moduleItemCompletionRequirementType, "string");
        }

        if (moduleItemCompletionRequirementMinScore !== undefined) {
            localVarFormParams['module_item[completion_requirement][min_score]'] = ObjectSerializer.serialize(moduleItemCompletionRequirementMinScore, "number");
        }

        if (moduleItemPublished !== undefined) {
            localVarFormParams['module_item[published]'] = ObjectSerializer.serialize(moduleItemPublished, "boolean");
        }

        if (moduleItemModuleId !== undefined) {
            localVarFormParams['module_item[module_id]'] = ObjectSerializer.serialize(moduleItemModuleId, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ModuleItem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ModuleItem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Accepts a list of overrides and applies them to the ContextModule. Returns 204 No Content response code if successful.
     * @summary Update a module\'s overrides
     * @param courseId ID
     * @param contextModuleId ID
     * @param overrides List of overrides to apply to the module. Overrides that already exist should include an ID and will be updated if needed. New overrides will be created for overrides in the list without an ID. Overrides not included in the list will be deleted. Providing an empty list will delete all of the module\\\&#39;s overrides. Keys for each override object can include: \\\&#39;id\\\&#39;, \\\&#39;title\\\&#39;, \\\&#39;student_ids\\\&#39;, and \\\&#39;course_section_id\\\&#39;. \\\&#39;group_id\\\&#39; is accepted if the Differentiation Tags account setting is enabled.
     */
    public async updateModuleSOverrides (courseId: string, contextModuleId: string, overrides: Array<Array<object>>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{context_module_id}/assignment_overrides'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'context_module_id' + '}', encodeURIComponent(String(contextModuleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateModuleSOverrides.');
        }

        // verify required parameter 'contextModuleId' is not null or undefined
        if (contextModuleId === null || contextModuleId === undefined) {
            throw new Error('Required parameter contextModuleId was null or undefined when calling updateModuleSOverrides.');
        }

        // verify required parameter 'overrides' is not null or undefined
        if (overrides === null || overrides === undefined) {
            throw new Error('Required parameter overrides was null or undefined when calling updateModuleSOverrides.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (overrides !== undefined) {
            localVarFormParams['overrides'] = ObjectSerializer.serialize(overrides, "Array<Array<object>>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
