/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Assignment } from '../model/assignment';
import { AssignmentOverride } from '../model/assignmentOverride';
import { BasicUser } from '../model/basicUser';
import { Progress } from '../model/progress';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum AssignmentsApiApiKeys {
}

export class AssignmentsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: AssignmentsApiApiKeys, value: string) {
        (this.authentications as any)[AssignmentsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Creates the specified overrides for each assignment.  Handles creation in a transaction, so all records are created or none are.  One of student_ids, group_id, or course_section_id must be present. At most one should be present; if multiple are present only the most specific (student_ids first, then group_id, then course_section_id) is used and any others are ignored.  Errors are reported in an errors attribute, an array of errors corresponding to inputs.  Global errors will be reported as a single element errors array
     * @summary Batch create overrides in a course
     * @param courseId ID
     * @param assignmentOverrides Attributes for the new assignment overrides. See {api:AssignmentOverridesController#create Create an assignment override} for available attributes
     */
    public async batchCreateOverridesInCourse (courseId: string, assignmentOverrides: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<AssignmentOverride>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/overrides'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling batchCreateOverridesInCourse.');
        }

        // verify required parameter 'assignmentOverrides' is not null or undefined
        if (assignmentOverrides === null || assignmentOverrides === undefined) {
            throw new Error('Required parameter assignmentOverrides was null or undefined when calling batchCreateOverridesInCourse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (assignmentOverrides !== undefined) {
            localVarFormParams['assignment_overrides'] = ObjectSerializer.serialize(assignmentOverrides, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<AssignmentOverride>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<AssignmentOverride>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns a list of specified overrides in this course, providing they target sections/groups/students visible to the current user. Returns null elements in the list for requests that were not found.
     * @summary Batch retrieve overrides in a course
     * @param courseId ID
     * @param assignmentOverridesId Ids of overrides to retrieve
     * @param assignmentOverridesAssignmentId Ids of assignments for each override
     */
    public async batchRetrieveOverridesInCourse (courseId: string, assignmentOverridesId: Array<string>, assignmentOverridesAssignmentId: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<AssignmentOverride>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/overrides'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling batchRetrieveOverridesInCourse.');
        }

        // verify required parameter 'assignmentOverridesId' is not null or undefined
        if (assignmentOverridesId === null || assignmentOverridesId === undefined) {
            throw new Error('Required parameter assignmentOverridesId was null or undefined when calling batchRetrieveOverridesInCourse.');
        }

        // verify required parameter 'assignmentOverridesAssignmentId' is not null or undefined
        if (assignmentOverridesAssignmentId === null || assignmentOverridesAssignmentId === undefined) {
            throw new Error('Required parameter assignmentOverridesAssignmentId was null or undefined when calling batchRetrieveOverridesInCourse.');
        }

        if (assignmentOverridesId !== undefined) {
            localVarQueryParameters['assignment_overrides[id]'] = ObjectSerializer.serialize(assignmentOverridesId, "Array<string>");
        }

        if (assignmentOverridesAssignmentId !== undefined) {
            localVarQueryParameters['assignment_overrides[assignment_id]'] = ObjectSerializer.serialize(assignmentOverridesAssignmentId, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<AssignmentOverride>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<AssignmentOverride>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates a list of specified overrides for each assignment.  Handles overrides in a transaction, so either all updates are applied or none. See {api:AssignmentOverridesController#update Update an assignment override} for available attributes.  All current overridden values must be supplied if they are to be retained; e.g. if due_at was overridden, but this PUT omits a value for due_at, due_at will no longer be overridden. If the override is adhoc and student_ids is not supplied, the target override set is unchanged. Target override sets cannot be changed for group or section overrides.  Errors are reported in an errors attribute, an array of errors corresponding to inputs.  Global errors will be reported as a single element errors array
     * @summary Batch update overrides in a course
     * @param courseId ID
     * @param assignmentOverrides Attributes for the updated overrides.
     */
    public async batchUpdateOverridesInCourse (courseId: string, assignmentOverrides: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<AssignmentOverride>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/overrides'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling batchUpdateOverridesInCourse.');
        }

        // verify required parameter 'assignmentOverrides' is not null or undefined
        if (assignmentOverrides === null || assignmentOverrides === undefined) {
            throw new Error('Required parameter assignmentOverrides was null or undefined when calling batchUpdateOverridesInCourse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (assignmentOverrides !== undefined) {
            localVarFormParams['assignment_overrides'] = ObjectSerializer.serialize(assignmentOverrides, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<AssignmentOverride>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<AssignmentOverride>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update due dates and availability dates for multiple assignments in a course.  Accepts a JSON array of objects containing two keys each: +id+, the assignment id, and +all_dates+, an array of +AssignmentDate+ structures containing the base and/or override dates for the assignment, as returned from the {api:AssignmentsApiController#index List assignments} endpoint with +include[]=all_dates+.  This endpoint cannot create or destroy assignment overrides; any existing assignment overrides that are not referenced in the arguments will be left alone. If an override is given, any dates that are not supplied with it will be defaulted. To clear a date, specify null explicitly.  All referenced assignments will be validated before any are saved. A list of errors will be returned if any provided dates are invalid, and no changes will be saved.  The bulk update is performed in a background job, use the {api:ProgressController#show Progress API} to check its status.
     * @summary Bulk update assignment dates
     * @param courseId ID
     */
    public async bulkUpdateAssignmentDates (courseId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Progress;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/bulk_update'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling bulkUpdateAssignmentDates.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Progress;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Progress");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a new assignment for this course. The assignment is created in the active state.
     * @summary Create an assignment
     * @param courseId ID
     * @param assignmentName The assignment name.
     * @param assignmentPosition The position of this assignment in the group when displaying assignment lists.
     * @param assignmentSubmissionTypes List of supported submission types for the assignment. Unless the assignment is allowing online submissions, the array should only have one element.  If not allowing online submissions, your options are:   \\\&quot;online_quiz\\\&quot;   \\\&quot;none\\\&quot;   \\\&quot;on_paper\\\&quot;   \\\&quot;discussion_topic\\\&quot;   \\\&quot;external_tool\\\&quot;  If you are allowing online submissions, you can have one or many allowed submission types:    \\\&quot;online_upload\\\&quot;   \\\&quot;online_text_entry\\\&quot;   \\\&quot;online_url\\\&quot;   \\\&quot;media_recording\\\&quot; (Only valid when the Kaltura plugin is enabled)   \\\&quot;student_annotation\\\&quot;
     * @param assignmentAllowedExtensions Allowed extensions if submission_types includes \\\&quot;online_upload\\\&quot;  Example:   allowed_extensions: [\\\&quot;docx\\\&quot;,\\\&quot;ppt\\\&quot;]
     * @param assignmentTurnitinEnabled Only applies when the Turnitin plugin is enabled for a course and the submission_types array includes \\\&quot;online_upload\\\&quot;. Toggles Turnitin submissions for the assignment. Will be ignored if Turnitin is not available for the course.
     * @param assignmentVericiteEnabled Only applies when the VeriCite plugin is enabled for a course and the submission_types array includes \\\&quot;online_upload\\\&quot;. Toggles VeriCite submissions for the assignment. Will be ignored if VeriCite is not available for the course.
     * @param assignmentTurnitinSettings Settings to send along to turnitin. See Assignment object definition for format.
     * @param assignmentIntegrationData Data used for SIS integrations. Requires admin-level token with the \\\&quot;Manage SIS\\\&quot; permission. JSON string required.
     * @param assignmentIntegrationId Unique ID from third party integrations
     * @param assignmentPeerReviews If submission_types does not include external_tool,discussion_topic, online_quiz, or on_paper, determines whether or not peer reviews will be turned on for the assignment.
     * @param assignmentAutomaticPeerReviews Whether peer reviews will be assigned automatically by Canvas or if teachers must manually assign peer reviews. Does not apply if peer reviews are not enabled.
     * @param assignmentNotifyOfUpdate If true, Canvas will send a notification to students in the class notifying them that the content has changed.
     * @param assignmentGroupCategoryId If present, the assignment will become a group assignment assigned to the group.
     * @param assignmentGradeGroupStudentsIndividually If this is a group assignment, teachers have the options to grade students individually. If false, Canvas will apply the assignment\\\&#39;s score to each member of the group. If true, the teacher can manually assign scores to each member of the group.
     * @param assignmentExternalToolTagAttributes Hash of external tool parameters if submission_types is [\\\&quot;external_tool\\\&quot;]. See Assignment object definition for format.
     * @param assignmentPointsPossible The maximum points possible on the assignment.
     * @param assignmentGradingType The strategy used for grading the assignment. The assignment defaults to \\\&quot;points\\\&quot; if this field is omitted.
     * @param assignmentDueAt The day/time the assignment is due. Must be between the lock dates if there are lock dates. Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z.
     * @param assignmentLockAt The day/time the assignment is locked after. Must be after the due date if there is a due date. Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z.
     * @param assignmentUnlockAt The day/time the assignment is unlocked. Must be before the due date if there is a due date. Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z.
     * @param assignmentDescription The assignment\\\&#39;s description, supports HTML.
     * @param assignmentAssignmentGroupId The assignment group id to put the assignment in. Defaults to the top assignment group in the course.
     * @param assignmentAssignmentOverrides List of overrides for the assignment.
     * @param assignmentOnlyVisibleToOverrides Whether this assignment is only visible to overrides (Only useful if \\\&#39;differentiated assignments\\\&#39; account setting is on)
     * @param assignmentPublished Whether this assignment is published. (Only useful if \\\&#39;draft state\\\&#39; account setting is on) Unpublished assignments are not visible to students.
     * @param assignmentGradingStandardId The grading standard id to set for the course.  If no value is provided for this argument the current grading_standard will be un-set from this course. This will update the grading_type for the course to \\\&#39;letter_grade\\\&#39; unless it is already \\\&#39;gpa_scale\\\&#39;.
     * @param assignmentOmitFromFinalGrade Whether this assignment is counted towards a student\\\&#39;s final grade.
     * @param assignmentHideInGradebook Whether this assignment is shown in the gradebook.
     * @param assignmentQuizLti Whether this assignment should use the Quizzes 2 LTI tool. Sets the submission type to \\\&#39;external_tool\\\&#39; and configures the external tool attributes to use the Quizzes 2 LTI tool configured for this course. Has no effect if no Quizzes 2 LTI tool is configured.
     * @param assignmentModeratedGrading Whether this assignment is moderated.
     * @param assignmentGraderCount The maximum number of provisional graders who may issue grades for this assignment. Only relevant for moderated assignments. Must be a positive value, and must be set to 1 if the course has fewer than two active instructors. Otherwise, the maximum value is the number of active instructors in the course minus one, or 10 if the course has more than 11 active instructors.
     * @param assignmentFinalGraderId The user ID of the grader responsible for choosing final grades for this assignment. Only relevant for moderated assignments.
     * @param assignmentGraderCommentsVisibleToGraders Boolean indicating if provisional graders\\\&#39; comments are visible to other provisional graders. Only relevant for moderated assignments.
     * @param assignmentGradersAnonymousToGraders Boolean indicating if provisional graders\\\&#39; identities are hidden from other provisional graders. Only relevant for moderated assignments.
     * @param assignmentGradersNamesVisibleToFinalGrader Boolean indicating if provisional grader identities are visible to the the final grader. Only relevant for moderated assignments.
     * @param assignmentAnonymousGrading Boolean indicating if the assignment is graded anonymously. If true, graders cannot see student identities.
     * @param assignmentAllowedAttempts The number of submission attempts allowed for this assignment. Set to -1 for unlimited attempts.
     * @param assignmentAnnotatableAttachmentId The Attachment ID of the document being annotated.  Only applies when submission_types includes \\\&quot;student_annotation\\\&quot;.
     */
    public async createAssignment (courseId: string, assignmentName: string, assignmentPosition?: number, assignmentSubmissionTypes?: Array<string>, assignmentAllowedExtensions?: Array<string>, assignmentTurnitinEnabled?: boolean, assignmentVericiteEnabled?: boolean, assignmentTurnitinSettings?: string, assignmentIntegrationData?: string, assignmentIntegrationId?: string, assignmentPeerReviews?: boolean, assignmentAutomaticPeerReviews?: boolean, assignmentNotifyOfUpdate?: boolean, assignmentGroupCategoryId?: number, assignmentGradeGroupStudentsIndividually?: number, assignmentExternalToolTagAttributes?: string, assignmentPointsPossible?: number, assignmentGradingType?: string, assignmentDueAt?: Date, assignmentLockAt?: Date, assignmentUnlockAt?: Date, assignmentDescription?: string, assignmentAssignmentGroupId?: number, assignmentAssignmentOverrides?: Array<string>, assignmentOnlyVisibleToOverrides?: boolean, assignmentPublished?: boolean, assignmentGradingStandardId?: number, assignmentOmitFromFinalGrade?: boolean, assignmentHideInGradebook?: boolean, assignmentQuizLti?: boolean, assignmentModeratedGrading?: boolean, assignmentGraderCount?: number, assignmentFinalGraderId?: number, assignmentGraderCommentsVisibleToGraders?: boolean, assignmentGradersAnonymousToGraders?: boolean, assignmentGradersNamesVisibleToFinalGrader?: boolean, assignmentAnonymousGrading?: boolean, assignmentAllowedAttempts?: number, assignmentAnnotatableAttachmentId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Assignment;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createAssignment.');
        }

        // verify required parameter 'assignmentName' is not null or undefined
        if (assignmentName === null || assignmentName === undefined) {
            throw new Error('Required parameter assignmentName was null or undefined when calling createAssignment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (assignmentName !== undefined) {
            localVarFormParams['assignment[name]'] = ObjectSerializer.serialize(assignmentName, "string");
        }

        if (assignmentPosition !== undefined) {
            localVarFormParams['assignment[position]'] = ObjectSerializer.serialize(assignmentPosition, "number");
        }

        if (assignmentSubmissionTypes !== undefined) {
            localVarFormParams['assignment[submission_types]'] = ObjectSerializer.serialize(assignmentSubmissionTypes, "Array<string>");
        }

        if (assignmentAllowedExtensions !== undefined) {
            localVarFormParams['assignment[allowed_extensions]'] = ObjectSerializer.serialize(assignmentAllowedExtensions, "Array<string>");
        }

        if (assignmentTurnitinEnabled !== undefined) {
            localVarFormParams['assignment[turnitin_enabled]'] = ObjectSerializer.serialize(assignmentTurnitinEnabled, "boolean");
        }

        if (assignmentVericiteEnabled !== undefined) {
            localVarFormParams['assignment[vericite_enabled]'] = ObjectSerializer.serialize(assignmentVericiteEnabled, "boolean");
        }

        if (assignmentTurnitinSettings !== undefined) {
            localVarFormParams['assignment[turnitin_settings]'] = ObjectSerializer.serialize(assignmentTurnitinSettings, "string");
        }

        if (assignmentIntegrationData !== undefined) {
            localVarFormParams['assignment[integration_data]'] = ObjectSerializer.serialize(assignmentIntegrationData, "string");
        }

        if (assignmentIntegrationId !== undefined) {
            localVarFormParams['assignment[integration_id]'] = ObjectSerializer.serialize(assignmentIntegrationId, "string");
        }

        if (assignmentPeerReviews !== undefined) {
            localVarFormParams['assignment[peer_reviews]'] = ObjectSerializer.serialize(assignmentPeerReviews, "boolean");
        }

        if (assignmentAutomaticPeerReviews !== undefined) {
            localVarFormParams['assignment[automatic_peer_reviews]'] = ObjectSerializer.serialize(assignmentAutomaticPeerReviews, "boolean");
        }

        if (assignmentNotifyOfUpdate !== undefined) {
            localVarFormParams['assignment[notify_of_update]'] = ObjectSerializer.serialize(assignmentNotifyOfUpdate, "boolean");
        }

        if (assignmentGroupCategoryId !== undefined) {
            localVarFormParams['assignment[group_category_id]'] = ObjectSerializer.serialize(assignmentGroupCategoryId, "number");
        }

        if (assignmentGradeGroupStudentsIndividually !== undefined) {
            localVarFormParams['assignment[grade_group_students_individually]'] = ObjectSerializer.serialize(assignmentGradeGroupStudentsIndividually, "number");
        }

        if (assignmentExternalToolTagAttributes !== undefined) {
            localVarFormParams['assignment[external_tool_tag_attributes]'] = ObjectSerializer.serialize(assignmentExternalToolTagAttributes, "string");
        }

        if (assignmentPointsPossible !== undefined) {
            localVarFormParams['assignment[points_possible]'] = ObjectSerializer.serialize(assignmentPointsPossible, "number");
        }

        if (assignmentGradingType !== undefined) {
            localVarFormParams['assignment[grading_type]'] = ObjectSerializer.serialize(assignmentGradingType, "string");
        }

        if (assignmentDueAt !== undefined) {
            localVarFormParams['assignment[due_at]'] = ObjectSerializer.serialize(assignmentDueAt, "Date");
        }

        if (assignmentLockAt !== undefined) {
            localVarFormParams['assignment[lock_at]'] = ObjectSerializer.serialize(assignmentLockAt, "Date");
        }

        if (assignmentUnlockAt !== undefined) {
            localVarFormParams['assignment[unlock_at]'] = ObjectSerializer.serialize(assignmentUnlockAt, "Date");
        }

        if (assignmentDescription !== undefined) {
            localVarFormParams['assignment[description]'] = ObjectSerializer.serialize(assignmentDescription, "string");
        }

        if (assignmentAssignmentGroupId !== undefined) {
            localVarFormParams['assignment[assignment_group_id]'] = ObjectSerializer.serialize(assignmentAssignmentGroupId, "number");
        }

        if (assignmentAssignmentOverrides !== undefined) {
            localVarFormParams['assignment[assignment_overrides]'] = ObjectSerializer.serialize(assignmentAssignmentOverrides, "Array<string>");
        }

        if (assignmentOnlyVisibleToOverrides !== undefined) {
            localVarFormParams['assignment[only_visible_to_overrides]'] = ObjectSerializer.serialize(assignmentOnlyVisibleToOverrides, "boolean");
        }

        if (assignmentPublished !== undefined) {
            localVarFormParams['assignment[published]'] = ObjectSerializer.serialize(assignmentPublished, "boolean");
        }

        if (assignmentGradingStandardId !== undefined) {
            localVarFormParams['assignment[grading_standard_id]'] = ObjectSerializer.serialize(assignmentGradingStandardId, "number");
        }

        if (assignmentOmitFromFinalGrade !== undefined) {
            localVarFormParams['assignment[omit_from_final_grade]'] = ObjectSerializer.serialize(assignmentOmitFromFinalGrade, "boolean");
        }

        if (assignmentHideInGradebook !== undefined) {
            localVarFormParams['assignment[hide_in_gradebook]'] = ObjectSerializer.serialize(assignmentHideInGradebook, "boolean");
        }

        if (assignmentQuizLti !== undefined) {
            localVarFormParams['assignment[quiz_lti]'] = ObjectSerializer.serialize(assignmentQuizLti, "boolean");
        }

        if (assignmentModeratedGrading !== undefined) {
            localVarFormParams['assignment[moderated_grading]'] = ObjectSerializer.serialize(assignmentModeratedGrading, "boolean");
        }

        if (assignmentGraderCount !== undefined) {
            localVarFormParams['assignment[grader_count]'] = ObjectSerializer.serialize(assignmentGraderCount, "number");
        }

        if (assignmentFinalGraderId !== undefined) {
            localVarFormParams['assignment[final_grader_id]'] = ObjectSerializer.serialize(assignmentFinalGraderId, "number");
        }

        if (assignmentGraderCommentsVisibleToGraders !== undefined) {
            localVarFormParams['assignment[grader_comments_visible_to_graders]'] = ObjectSerializer.serialize(assignmentGraderCommentsVisibleToGraders, "boolean");
        }

        if (assignmentGradersAnonymousToGraders !== undefined) {
            localVarFormParams['assignment[graders_anonymous_to_graders]'] = ObjectSerializer.serialize(assignmentGradersAnonymousToGraders, "boolean");
        }

        if (assignmentGradersNamesVisibleToFinalGrader !== undefined) {
            localVarFormParams['assignment[graders_names_visible_to_final_grader]'] = ObjectSerializer.serialize(assignmentGradersNamesVisibleToFinalGrader, "boolean");
        }

        if (assignmentAnonymousGrading !== undefined) {
            localVarFormParams['assignment[anonymous_grading]'] = ObjectSerializer.serialize(assignmentAnonymousGrading, "boolean");
        }

        if (assignmentAllowedAttempts !== undefined) {
            localVarFormParams['assignment[allowed_attempts]'] = ObjectSerializer.serialize(assignmentAllowedAttempts, "number");
        }

        if (assignmentAnnotatableAttachmentId !== undefined) {
            localVarFormParams['assignment[annotatable_attachment_id]'] = ObjectSerializer.serialize(assignmentAnnotatableAttachmentId, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Assignment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Assignment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * One of student_ids, group_id, or course_section_id must be present. At most one should be present; if multiple are present only the most specific (student_ids first, then group_id, then course_section_id) is used and any others are ignored.
     * @summary Create an assignment override
     * @param courseId ID
     * @param assignmentId ID
     * @param assignmentOverrideStudentIds The IDs of the override\\\&#39;s target students. If present, the IDs must each identify a user with an active student enrollment in the course that is not already targetted by a different adhoc override.
     * @param assignmentOverrideTitle The title of the adhoc assignment override. Required if student_ids is present, ignored otherwise (the title is set to the name of the targetted group or section instead).
     * @param assignmentOverrideGroupId The ID of the override\\\&#39;s target group. If present, the following conditions must be met for the override to be successful:  1. the assignment MUST be a group assignment (a group_category_id is assigned to it) 2. the ID must identify an active group in the group set the assignment is in 3. the ID must not be targetted by a different override  See {Appendix: Group assignments} for more info.
     * @param assignmentOverrideCourseSectionId The ID of the override\\\&#39;s target section. If present, must identify an active section of the assignment\\\&#39;s course not already targetted by a different override.
     * @param assignmentOverrideDueAt The day/time the overridden assignment is due. Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z. If absent, this override will not affect due date. May be present but null to indicate the override removes any previous due date.
     * @param assignmentOverrideUnlockAt The day/time the overridden assignment becomes unlocked. Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z. If absent, this override will not affect the unlock date. May be present but null to indicate the override removes any previous unlock date.
     * @param assignmentOverrideLockAt The day/time the overridden assignment becomes locked. Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z. If absent, this override will not affect the lock date. May be present but null to indicate the override removes any previous lock date.
     */
    public async createAssignmentOverride (courseId: string, assignmentId: string, assignmentOverrideStudentIds?: Array<number>, assignmentOverrideTitle?: string, assignmentOverrideGroupId?: number, assignmentOverrideCourseSectionId?: number, assignmentOverrideDueAt?: Date, assignmentOverrideUnlockAt?: Date, assignmentOverrideLockAt?: Date, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AssignmentOverride;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/overrides'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling createAssignmentOverride.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling createAssignmentOverride.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (assignmentOverrideStudentIds !== undefined) {
            localVarFormParams['assignment_override[student_ids]'] = ObjectSerializer.serialize(assignmentOverrideStudentIds, "Array<number>");
        }

        if (assignmentOverrideTitle !== undefined) {
            localVarFormParams['assignment_override[title]'] = ObjectSerializer.serialize(assignmentOverrideTitle, "string");
        }

        if (assignmentOverrideGroupId !== undefined) {
            localVarFormParams['assignment_override[group_id]'] = ObjectSerializer.serialize(assignmentOverrideGroupId, "number");
        }

        if (assignmentOverrideCourseSectionId !== undefined) {
            localVarFormParams['assignment_override[course_section_id]'] = ObjectSerializer.serialize(assignmentOverrideCourseSectionId, "number");
        }

        if (assignmentOverrideDueAt !== undefined) {
            localVarFormParams['assignment_override[due_at]'] = ObjectSerializer.serialize(assignmentOverrideDueAt, "Date");
        }

        if (assignmentOverrideUnlockAt !== undefined) {
            localVarFormParams['assignment_override[unlock_at]'] = ObjectSerializer.serialize(assignmentOverrideUnlockAt, "Date");
        }

        if (assignmentOverrideLockAt !== undefined) {
            localVarFormParams['assignment_override[lock_at]'] = ObjectSerializer.serialize(assignmentOverrideLockAt, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AssignmentOverride;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AssignmentOverride");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete the given assignment.
     * @summary Delete an assignment
     * @param courseId ID
     * @param id ID
     */
    public async deleteAssignment (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Assignment;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling deleteAssignment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteAssignment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Assignment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Assignment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes an override and returns its former details.
     * @summary Delete an assignment override
     * @param courseId ID
     * @param assignmentId ID
     * @param id ID
     */
    public async deleteAssignmentOverride (courseId: string, assignmentId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AssignmentOverride;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/overrides/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling deleteAssignmentOverride.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling deleteAssignmentOverride.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteAssignmentOverride.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AssignmentOverride;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AssignmentOverride");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Duplicate an assignment and return a json based on result_type argument.
     * @summary Duplicate assignment
     * @param courseId ID
     * @param assignmentId ID
     * @param resultType Optional information: When the root account has the feature &#x60;newquizzes_on_quiz_page&#x60; enabled and this argument is set to \\\&quot;Quiz\\\&quot; the response will be serialized into a quiz format({file:doc/api/quizzes.html#Quiz}); When this argument isn\\\&#39;t specified the response will be serialized into an assignment format;
     */
    public async duplicateAssignment (courseId: string, assignmentId: string, resultType?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Assignment;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/duplicate'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling duplicateAssignment.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling duplicateAssignment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (resultType !== undefined) {
            localVarFormParams['result_type'] = ObjectSerializer.serialize(resultType, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Assignment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Assignment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Modify an existing assignment.
     * @summary Edit an assignment
     * @param courseId ID
     * @param id ID
     * @param assignmentName The assignment name.
     * @param assignmentPosition The position of this assignment in the group when displaying assignment lists.
     * @param assignmentSubmissionTypes Only applies if the assignment doesn\\\&#39;t have student submissions.
     * @param assignmentAllowedExtensions Allowed extensions if submission_types includes \\\&quot;online_upload\\\&quot;  Example:   allowed_extensions: [\\\&quot;docx\\\&quot;,\\\&quot;ppt\\\&quot;]
     * @param assignmentTurnitinEnabled Only applies when the Turnitin plugin is enabled for a course and the submission_types array includes \\\&quot;online_upload\\\&quot;. Toggles Turnitin submissions for the assignment. Will be ignored if Turnitin is not available for the course.
     * @param assignmentVericiteEnabled Only applies when the VeriCite plugin is enabled for a course and the submission_types array includes \\\&quot;online_upload\\\&quot;. Toggles VeriCite submissions for the assignment. Will be ignored if VeriCite is not available for the course.
     * @param assignmentTurnitinSettings Settings to send along to turnitin. See Assignment object definition for format.
     * @param assignmentSisAssignmentId The sis id of the Assignment
     * @param assignmentIntegrationData Data used for SIS integrations. Requires admin-level token with the \\\&quot;Manage SIS\\\&quot; permission. JSON string required.
     * @param assignmentIntegrationId Unique ID from third party integrations
     * @param assignmentPeerReviews If submission_types does not include external_tool,discussion_topic, online_quiz, or on_paper, determines whether or not peer reviews will be turned on for the assignment.
     * @param assignmentAutomaticPeerReviews Whether peer reviews will be assigned automatically by Canvas or if teachers must manually assign peer reviews. Does not apply if peer reviews are not enabled.
     * @param assignmentNotifyOfUpdate If true, Canvas will send a notification to students in the class notifying them that the content has changed.
     * @param assignmentGroupCategoryId If present, the assignment will become a group assignment assigned to the group.
     * @param assignmentGradeGroupStudentsIndividually If this is a group assignment, teachers have the options to grade students individually. If false, Canvas will apply the assignment\\\&#39;s score to each member of the group. If true, the teacher can manually assign scores to each member of the group.
     * @param assignmentExternalToolTagAttributes Hash of external tool parameters if submission_types is [\\\&quot;external_tool\\\&quot;]. See Assignment object definition for format.
     * @param assignmentPointsPossible The maximum points possible on the assignment.
     * @param assignmentGradingType The strategy used for grading the assignment. The assignment defaults to \\\&quot;points\\\&quot; if this field is omitted.
     * @param assignmentDueAt The day/time the assignment is due. Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z.
     * @param assignmentLockAt The day/time the assignment is locked after. Must be after the due date if there is a due date. Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z.
     * @param assignmentUnlockAt The day/time the assignment is unlocked. Must be before the due date if there is a due date. Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z.
     * @param assignmentDescription The assignment\\\&#39;s description, supports HTML.
     * @param assignmentAssignmentGroupId The assignment group id to put the assignment in. Defaults to the top assignment group in the course.
     * @param assignmentAssignmentOverrides List of overrides for the assignment. If the +assignment[assignment_overrides]+ key is absent, any existing overrides are kept as is. If the +assignment[assignment_overrides]+ key is present, existing overrides are updated or deleted (and new ones created, as necessary) to match the provided list.
     * @param assignmentOnlyVisibleToOverrides Whether this assignment is only visible to overrides (Only useful if \\\&#39;differentiated assignments\\\&#39; account setting is on)
     * @param assignmentPublished Whether this assignment is published. (Only useful if \\\&#39;draft state\\\&#39; account setting is on) Unpublished assignments are not visible to students.
     * @param assignmentGradingStandardId The grading standard id to set for the course.  If no value is provided for this argument the current grading_standard will be un-set from this course. This will update the grading_type for the course to \\\&#39;letter_grade\\\&#39; unless it is already \\\&#39;gpa_scale\\\&#39;.
     * @param assignmentOmitFromFinalGrade Whether this assignment is counted towards a student\\\&#39;s final grade.
     * @param assignmentHideInGradebook Whether this assignment is shown in the gradebook.
     * @param assignmentModeratedGrading Whether this assignment is moderated.
     * @param assignmentGraderCount The maximum number of provisional graders who may issue grades for this assignment. Only relevant for moderated assignments. Must be a positive value, and must be set to 1 if the course has fewer than two active instructors. Otherwise, the maximum value is the number of active instructors in the course minus one, or 10 if the course has more than 11 active instructors.
     * @param assignmentFinalGraderId The user ID of the grader responsible for choosing final grades for this assignment. Only relevant for moderated assignments.
     * @param assignmentGraderCommentsVisibleToGraders Boolean indicating if provisional graders\\\&#39; comments are visible to other provisional graders. Only relevant for moderated assignments.
     * @param assignmentGradersAnonymousToGraders Boolean indicating if provisional graders\\\&#39; identities are hidden from other provisional graders. Only relevant for moderated assignments.
     * @param assignmentGradersNamesVisibleToFinalGrader Boolean indicating if provisional grader identities are visible to the the final grader. Only relevant for moderated assignments.
     * @param assignmentAnonymousGrading Boolean indicating if the assignment is graded anonymously. If true, graders cannot see student identities.
     * @param assignmentAllowedAttempts The number of submission attempts allowed for this assignment. Set to -1 or null for unlimited attempts.
     * @param assignmentAnnotatableAttachmentId The Attachment ID of the document being annotated.  Only applies when submission_types includes \\\&quot;student_annotation\\\&quot;.
     * @param assignmentForceUpdatedAt If true, updated_at will be set even if no changes were made.
     */
    public async editAssignment (courseId: string, id: string, assignmentName?: string, assignmentPosition?: number, assignmentSubmissionTypes?: Array<string>, assignmentAllowedExtensions?: Array<string>, assignmentTurnitinEnabled?: boolean, assignmentVericiteEnabled?: boolean, assignmentTurnitinSettings?: string, assignmentSisAssignmentId?: string, assignmentIntegrationData?: string, assignmentIntegrationId?: string, assignmentPeerReviews?: boolean, assignmentAutomaticPeerReviews?: boolean, assignmentNotifyOfUpdate?: boolean, assignmentGroupCategoryId?: number, assignmentGradeGroupStudentsIndividually?: number, assignmentExternalToolTagAttributes?: string, assignmentPointsPossible?: number, assignmentGradingType?: string, assignmentDueAt?: Date, assignmentLockAt?: Date, assignmentUnlockAt?: Date, assignmentDescription?: string, assignmentAssignmentGroupId?: number, assignmentAssignmentOverrides?: Array<string>, assignmentOnlyVisibleToOverrides?: boolean, assignmentPublished?: boolean, assignmentGradingStandardId?: number, assignmentOmitFromFinalGrade?: boolean, assignmentHideInGradebook?: boolean, assignmentModeratedGrading?: boolean, assignmentGraderCount?: number, assignmentFinalGraderId?: number, assignmentGraderCommentsVisibleToGraders?: boolean, assignmentGradersAnonymousToGraders?: boolean, assignmentGradersNamesVisibleToFinalGrader?: boolean, assignmentAnonymousGrading?: boolean, assignmentAllowedAttempts?: number, assignmentAnnotatableAttachmentId?: number, assignmentForceUpdatedAt?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Assignment;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling editAssignment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling editAssignment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (assignmentName !== undefined) {
            localVarFormParams['assignment[name]'] = ObjectSerializer.serialize(assignmentName, "string");
        }

        if (assignmentPosition !== undefined) {
            localVarFormParams['assignment[position]'] = ObjectSerializer.serialize(assignmentPosition, "number");
        }

        if (assignmentSubmissionTypes !== undefined) {
            localVarFormParams['assignment[submission_types]'] = ObjectSerializer.serialize(assignmentSubmissionTypes, "Array<string>");
        }

        if (assignmentAllowedExtensions !== undefined) {
            localVarFormParams['assignment[allowed_extensions]'] = ObjectSerializer.serialize(assignmentAllowedExtensions, "Array<string>");
        }

        if (assignmentTurnitinEnabled !== undefined) {
            localVarFormParams['assignment[turnitin_enabled]'] = ObjectSerializer.serialize(assignmentTurnitinEnabled, "boolean");
        }

        if (assignmentVericiteEnabled !== undefined) {
            localVarFormParams['assignment[vericite_enabled]'] = ObjectSerializer.serialize(assignmentVericiteEnabled, "boolean");
        }

        if (assignmentTurnitinSettings !== undefined) {
            localVarFormParams['assignment[turnitin_settings]'] = ObjectSerializer.serialize(assignmentTurnitinSettings, "string");
        }

        if (assignmentSisAssignmentId !== undefined) {
            localVarFormParams['assignment[sis_assignment_id]'] = ObjectSerializer.serialize(assignmentSisAssignmentId, "string");
        }

        if (assignmentIntegrationData !== undefined) {
            localVarFormParams['assignment[integration_data]'] = ObjectSerializer.serialize(assignmentIntegrationData, "string");
        }

        if (assignmentIntegrationId !== undefined) {
            localVarFormParams['assignment[integration_id]'] = ObjectSerializer.serialize(assignmentIntegrationId, "string");
        }

        if (assignmentPeerReviews !== undefined) {
            localVarFormParams['assignment[peer_reviews]'] = ObjectSerializer.serialize(assignmentPeerReviews, "boolean");
        }

        if (assignmentAutomaticPeerReviews !== undefined) {
            localVarFormParams['assignment[automatic_peer_reviews]'] = ObjectSerializer.serialize(assignmentAutomaticPeerReviews, "boolean");
        }

        if (assignmentNotifyOfUpdate !== undefined) {
            localVarFormParams['assignment[notify_of_update]'] = ObjectSerializer.serialize(assignmentNotifyOfUpdate, "boolean");
        }

        if (assignmentGroupCategoryId !== undefined) {
            localVarFormParams['assignment[group_category_id]'] = ObjectSerializer.serialize(assignmentGroupCategoryId, "number");
        }

        if (assignmentGradeGroupStudentsIndividually !== undefined) {
            localVarFormParams['assignment[grade_group_students_individually]'] = ObjectSerializer.serialize(assignmentGradeGroupStudentsIndividually, "number");
        }

        if (assignmentExternalToolTagAttributes !== undefined) {
            localVarFormParams['assignment[external_tool_tag_attributes]'] = ObjectSerializer.serialize(assignmentExternalToolTagAttributes, "string");
        }

        if (assignmentPointsPossible !== undefined) {
            localVarFormParams['assignment[points_possible]'] = ObjectSerializer.serialize(assignmentPointsPossible, "number");
        }

        if (assignmentGradingType !== undefined) {
            localVarFormParams['assignment[grading_type]'] = ObjectSerializer.serialize(assignmentGradingType, "string");
        }

        if (assignmentDueAt !== undefined) {
            localVarFormParams['assignment[due_at]'] = ObjectSerializer.serialize(assignmentDueAt, "Date");
        }

        if (assignmentLockAt !== undefined) {
            localVarFormParams['assignment[lock_at]'] = ObjectSerializer.serialize(assignmentLockAt, "Date");
        }

        if (assignmentUnlockAt !== undefined) {
            localVarFormParams['assignment[unlock_at]'] = ObjectSerializer.serialize(assignmentUnlockAt, "Date");
        }

        if (assignmentDescription !== undefined) {
            localVarFormParams['assignment[description]'] = ObjectSerializer.serialize(assignmentDescription, "string");
        }

        if (assignmentAssignmentGroupId !== undefined) {
            localVarFormParams['assignment[assignment_group_id]'] = ObjectSerializer.serialize(assignmentAssignmentGroupId, "number");
        }

        if (assignmentAssignmentOverrides !== undefined) {
            localVarFormParams['assignment[assignment_overrides]'] = ObjectSerializer.serialize(assignmentAssignmentOverrides, "Array<string>");
        }

        if (assignmentOnlyVisibleToOverrides !== undefined) {
            localVarFormParams['assignment[only_visible_to_overrides]'] = ObjectSerializer.serialize(assignmentOnlyVisibleToOverrides, "boolean");
        }

        if (assignmentPublished !== undefined) {
            localVarFormParams['assignment[published]'] = ObjectSerializer.serialize(assignmentPublished, "boolean");
        }

        if (assignmentGradingStandardId !== undefined) {
            localVarFormParams['assignment[grading_standard_id]'] = ObjectSerializer.serialize(assignmentGradingStandardId, "number");
        }

        if (assignmentOmitFromFinalGrade !== undefined) {
            localVarFormParams['assignment[omit_from_final_grade]'] = ObjectSerializer.serialize(assignmentOmitFromFinalGrade, "boolean");
        }

        if (assignmentHideInGradebook !== undefined) {
            localVarFormParams['assignment[hide_in_gradebook]'] = ObjectSerializer.serialize(assignmentHideInGradebook, "boolean");
        }

        if (assignmentModeratedGrading !== undefined) {
            localVarFormParams['assignment[moderated_grading]'] = ObjectSerializer.serialize(assignmentModeratedGrading, "boolean");
        }

        if (assignmentGraderCount !== undefined) {
            localVarFormParams['assignment[grader_count]'] = ObjectSerializer.serialize(assignmentGraderCount, "number");
        }

        if (assignmentFinalGraderId !== undefined) {
            localVarFormParams['assignment[final_grader_id]'] = ObjectSerializer.serialize(assignmentFinalGraderId, "number");
        }

        if (assignmentGraderCommentsVisibleToGraders !== undefined) {
            localVarFormParams['assignment[grader_comments_visible_to_graders]'] = ObjectSerializer.serialize(assignmentGraderCommentsVisibleToGraders, "boolean");
        }

        if (assignmentGradersAnonymousToGraders !== undefined) {
            localVarFormParams['assignment[graders_anonymous_to_graders]'] = ObjectSerializer.serialize(assignmentGradersAnonymousToGraders, "boolean");
        }

        if (assignmentGradersNamesVisibleToFinalGrader !== undefined) {
            localVarFormParams['assignment[graders_names_visible_to_final_grader]'] = ObjectSerializer.serialize(assignmentGradersNamesVisibleToFinalGrader, "boolean");
        }

        if (assignmentAnonymousGrading !== undefined) {
            localVarFormParams['assignment[anonymous_grading]'] = ObjectSerializer.serialize(assignmentAnonymousGrading, "boolean");
        }

        if (assignmentAllowedAttempts !== undefined) {
            localVarFormParams['assignment[allowed_attempts]'] = ObjectSerializer.serialize(assignmentAllowedAttempts, "number");
        }

        if (assignmentAnnotatableAttachmentId !== undefined) {
            localVarFormParams['assignment[annotatable_attachment_id]'] = ObjectSerializer.serialize(assignmentAnnotatableAttachmentId, "number");
        }

        if (assignmentForceUpdatedAt !== undefined) {
            localVarFormParams['assignment[force_updated_at]'] = ObjectSerializer.serialize(assignmentForceUpdatedAt, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Assignment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Assignment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the assignment with the given id.
     * @summary Get a single assignment
     * @param courseId ID
     * @param id ID
     * @param include Associations to include with the assignment. The \&quot;assignment_visibility\&quot; option requires that the Differentiated Assignments course feature be turned on. If \&quot;observed_users\&quot; is passed, submissions for observed users will also be included. For \&quot;score_statistics\&quot; to be included, the \&quot;submission\&quot; option must also be set.
     * @param overrideAssignmentDates Apply assignment overrides to the assignment, defaults to true.
     * @param needsGradingCountBySection Split up \&quot;needs_grading_count\&quot; by sections into the \&quot;needs_grading_count_by_section\&quot; key, defaults to false
     * @param allDates All dates associated with the assignment, if applicable
     */
    public async getSingleAssignment (courseId: string, id: string, include?: Array<string>, overrideAssignmentDates?: boolean, needsGradingCountBySection?: boolean, allDates?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Assignment;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getSingleAssignment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSingleAssignment.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (overrideAssignmentDates !== undefined) {
            localVarQueryParameters['override_assignment_dates'] = ObjectSerializer.serialize(overrideAssignmentDates, "boolean");
        }

        if (needsGradingCountBySection !== undefined) {
            localVarQueryParameters['needs_grading_count_by_section'] = ObjectSerializer.serialize(needsGradingCountBySection, "boolean");
        }

        if (allDates !== undefined) {
            localVarQueryParameters['all_dates'] = ObjectSerializer.serialize(allDates, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Assignment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Assignment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns details of the the override with the given id.
     * @summary Get a single assignment override
     * @param courseId ID
     * @param assignmentId ID
     * @param id ID
     */
    public async getSingleAssignmentOverride (courseId: string, assignmentId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AssignmentOverride;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/overrides/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getSingleAssignmentOverride.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling getSingleAssignmentOverride.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSingleAssignmentOverride.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AssignmentOverride;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AssignmentOverride");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the paginated list of overrides for this assignment that target sections/groups/students visible to the current user.
     * @summary List assignment overrides
     * @param courseId ID
     * @param assignmentId ID
     */
    public async listAssignmentOverrides (courseId: string, assignmentId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<AssignmentOverride>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/overrides'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listAssignmentOverrides.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling listAssignmentOverrides.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<AssignmentOverride>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<AssignmentOverride>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the paginated list of assignments for the current course or assignment group.
     * @summary List assignments
     * @param courseId ID
     * @param assignmentGroupId ID
     * @param include Optional information to include with each assignment: submission:: The current user\&#39;s current +Submission+ assignment_visibility:: An array of ids of students who can see the assignment all_dates:: An array of +AssignmentDate+ structures, one for each override, and also a +base+ if the assignment has an \&quot;Everyone\&quot; / \&quot;Everyone Else\&quot; date overrides:: An array of +AssignmentOverride+ structures observed_users:: An array of submissions for observed users can_edit:: an extra Boolean value will be included with each +Assignment+ (and +AssignmentDate+ if +all_dates+ is supplied) to indicate whether the caller can edit the assignment or date. Moderated grading and closed grading periods may restrict a user\&#39;s ability to edit an assignment. score_statistics:: An object containing min, max, and mean score on this assignment. This will not be included for students if there are less than 5 graded assignments or if disabled by the instructor. Only valid if \&#39;submission\&#39; is also included. ab_guid:: An array of guid strings for academic benchmarks
     * @param searchTerm The partial title of the assignments to match and return.
     * @param overrideAssignmentDates Apply assignment overrides for each assignment, defaults to true.
     * @param needsGradingCountBySection Split up \&quot;needs_grading_count\&quot; by sections into the \&quot;needs_grading_count_by_section\&quot; key, defaults to false
     * @param bucket If included, only return certain assignments depending on due date and submission status.
     * @param assignmentIds if set, return only assignments specified
     * @param orderBy Determines the order of the assignments. Defaults to \&quot;position\&quot;.
     * @param postToSis Return only assignments that have post_to_sis set or not set.
     * @param newQuizzes Return only New Quizzes assignments
     */
    public async listAssignmentsAssignmentGroups (courseId: string, assignmentGroupId: string, include?: Array<string>, searchTerm?: string, overrideAssignmentDates?: boolean, needsGradingCountBySection?: boolean, bucket?: 'past' | 'overdue' | 'undated' | 'ungraded' | 'unsubmitted' | 'upcoming' | 'future', assignmentIds?: Array<string>, orderBy?: 'position' | 'name' | 'due_at', postToSis?: boolean, newQuizzes?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Assignment>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignment_groups/{assignment_group_id}/assignments'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_group_id' + '}', encodeURIComponent(String(assignmentGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listAssignmentsAssignmentGroups.');
        }

        // verify required parameter 'assignmentGroupId' is not null or undefined
        if (assignmentGroupId === null || assignmentGroupId === undefined) {
            throw new Error('Required parameter assignmentGroupId was null or undefined when calling listAssignmentsAssignmentGroups.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['search_term'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (overrideAssignmentDates !== undefined) {
            localVarQueryParameters['override_assignment_dates'] = ObjectSerializer.serialize(overrideAssignmentDates, "boolean");
        }

        if (needsGradingCountBySection !== undefined) {
            localVarQueryParameters['needs_grading_count_by_section'] = ObjectSerializer.serialize(needsGradingCountBySection, "boolean");
        }

        if (bucket !== undefined) {
            localVarQueryParameters['bucket'] = ObjectSerializer.serialize(bucket, "'past' | 'overdue' | 'undated' | 'ungraded' | 'unsubmitted' | 'upcoming' | 'future'");
        }

        if (assignmentIds !== undefined) {
            localVarQueryParameters['assignment_ids'] = ObjectSerializer.serialize(assignmentIds, "Array<string>");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['order_by'] = ObjectSerializer.serialize(orderBy, "'position' | 'name' | 'due_at'");
        }

        if (postToSis !== undefined) {
            localVarQueryParameters['post_to_sis'] = ObjectSerializer.serialize(postToSis, "boolean");
        }

        if (newQuizzes !== undefined) {
            localVarQueryParameters['new_quizzes'] = ObjectSerializer.serialize(newQuizzes, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Assignment>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Assignment>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the paginated list of assignments for the current course or assignment group.
     * @summary List assignments
     * @param courseId ID
     * @param include Optional information to include with each assignment: submission:: The current user\&#39;s current +Submission+ assignment_visibility:: An array of ids of students who can see the assignment all_dates:: An array of +AssignmentDate+ structures, one for each override, and also a +base+ if the assignment has an \&quot;Everyone\&quot; / \&quot;Everyone Else\&quot; date overrides:: An array of +AssignmentOverride+ structures observed_users:: An array of submissions for observed users can_edit:: an extra Boolean value will be included with each +Assignment+ (and +AssignmentDate+ if +all_dates+ is supplied) to indicate whether the caller can edit the assignment or date. Moderated grading and closed grading periods may restrict a user\&#39;s ability to edit an assignment. score_statistics:: An object containing min, max, and mean score on this assignment. This will not be included for students if there are less than 5 graded assignments or if disabled by the instructor. Only valid if \&#39;submission\&#39; is also included. ab_guid:: An array of guid strings for academic benchmarks
     * @param searchTerm The partial title of the assignments to match and return.
     * @param overrideAssignmentDates Apply assignment overrides for each assignment, defaults to true.
     * @param needsGradingCountBySection Split up \&quot;needs_grading_count\&quot; by sections into the \&quot;needs_grading_count_by_section\&quot; key, defaults to false
     * @param bucket If included, only return certain assignments depending on due date and submission status.
     * @param assignmentIds if set, return only assignments specified
     * @param orderBy Determines the order of the assignments. Defaults to \&quot;position\&quot;.
     * @param postToSis Return only assignments that have post_to_sis set or not set.
     * @param newQuizzes Return only New Quizzes assignments
     */
    public async listAssignmentsAssignments (courseId: string, include?: Array<string>, searchTerm?: string, overrideAssignmentDates?: boolean, needsGradingCountBySection?: boolean, bucket?: 'past' | 'overdue' | 'undated' | 'ungraded' | 'unsubmitted' | 'upcoming' | 'future', assignmentIds?: Array<string>, orderBy?: 'position' | 'name' | 'due_at', postToSis?: boolean, newQuizzes?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Assignment>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listAssignmentsAssignments.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['search_term'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (overrideAssignmentDates !== undefined) {
            localVarQueryParameters['override_assignment_dates'] = ObjectSerializer.serialize(overrideAssignmentDates, "boolean");
        }

        if (needsGradingCountBySection !== undefined) {
            localVarQueryParameters['needs_grading_count_by_section'] = ObjectSerializer.serialize(needsGradingCountBySection, "boolean");
        }

        if (bucket !== undefined) {
            localVarQueryParameters['bucket'] = ObjectSerializer.serialize(bucket, "'past' | 'overdue' | 'undated' | 'ungraded' | 'unsubmitted' | 'upcoming' | 'future'");
        }

        if (assignmentIds !== undefined) {
            localVarQueryParameters['assignment_ids'] = ObjectSerializer.serialize(assignmentIds, "Array<string>");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['order_by'] = ObjectSerializer.serialize(orderBy, "'position' | 'name' | 'due_at'");
        }

        if (postToSis !== undefined) {
            localVarQueryParameters['post_to_sis'] = ObjectSerializer.serialize(postToSis, "boolean");
        }

        if (newQuizzes !== undefined) {
            localVarQueryParameters['new_quizzes'] = ObjectSerializer.serialize(newQuizzes, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Assignment>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Assignment>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the paginated list of assignments for the specified user if the current user has rights to view. See {api:AssignmentsApiController#index List assignments} for valid arguments.
     * @summary List assignments for user
     * @param userId ID
     * @param courseId ID
     */
    public async listAssignmentsForUser (userId: string, courseId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/users/{user_id}/courses/{course_id}/assignments'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)))
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling listAssignmentsForUser.');
        }

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listAssignmentsForUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns student ids and names for the group.
     * @summary List group members for a student on an assignment
     * @param courseId ID
     * @param assignmentId ID
     * @param userId ID
     */
    public async listGroupMembersForStudentOnAssignment (courseId: string, assignmentId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<BasicUser>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/users/{user_id}/group_members'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listGroupMembersForStudentOnAssignment.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling listGroupMembersForStudentOnAssignment.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling listGroupMembersForStudentOnAssignment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<BasicUser>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<BasicUser>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Responds with a redirect to the override for the given group, if any (404 otherwise).
     * @summary Redirect to the assignment override for a group
     * @param groupId ID
     * @param assignmentId ID
     */
    public async redirectToAssignmentOverrideForGroup (groupId: string, assignmentId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/groups/{group_id}/assignments/{assignment_id}/override'
            .replace('{' + 'group_id' + '}', encodeURIComponent(String(groupId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupId' is not null or undefined
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling redirectToAssignmentOverrideForGroup.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling redirectToAssignmentOverrideForGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Responds with a redirect to the override for the given section, if any (404 otherwise).
     * @summary Redirect to the assignment override for a section
     * @param courseSectionId ID
     * @param assignmentId ID
     */
    public async redirectToAssignmentOverrideForSection (courseSectionId: string, assignmentId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/sections/{course_section_id}/assignments/{assignment_id}/override'
            .replace('{' + 'course_section_id' + '}', encodeURIComponent(String(courseSectionId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseSectionId' is not null or undefined
        if (courseSectionId === null || courseSectionId === undefined) {
            throw new Error('Required parameter courseSectionId was null or undefined when calling redirectToAssignmentOverrideForSection.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling redirectToAssignmentOverrideForSection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * All current overridden values must be supplied if they are to be retained; e.g. if due_at was overridden, but this PUT omits a value for due_at, due_at will no longer be overridden. If the override is adhoc and student_ids is not supplied, the target override set is unchanged. Target override sets cannot be changed for group or section overrides.
     * @summary Update an assignment override
     * @param courseId ID
     * @param assignmentId ID
     * @param id ID
     * @param assignmentOverrideStudentIds The IDs of the override\\\&#39;s target students. If present, the IDs must each identify a user with an active student enrollment in the course that is not already targetted by a different adhoc override. Ignored unless the override being updated is adhoc.
     * @param assignmentOverrideTitle The title of an adhoc assignment override. Ignored unless the override being updated is adhoc.
     * @param assignmentOverrideDueAt The day/time the overridden assignment is due. Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z. If absent, this override will not affect due date. May be present but null to indicate the override removes any previous due date.
     * @param assignmentOverrideUnlockAt The day/time the overridden assignment becomes unlocked. Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z. If absent, this override will not affect the unlock date. May be present but null to indicate the override removes any previous unlock date.
     * @param assignmentOverrideLockAt The day/time the overridden assignment becomes locked. Accepts times in ISO 8601 format, e.g. 2014-10-21T18:48:00Z. If absent, this override will not affect the lock date. May be present but null to indicate the override removes any previous lock date.
     */
    public async updateAssignmentOverride (courseId: string, assignmentId: string, id: string, assignmentOverrideStudentIds?: Array<number>, assignmentOverrideTitle?: string, assignmentOverrideDueAt?: Date, assignmentOverrideUnlockAt?: Date, assignmentOverrideLockAt?: Date, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AssignmentOverride;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/overrides/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateAssignmentOverride.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling updateAssignmentOverride.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateAssignmentOverride.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (assignmentOverrideStudentIds !== undefined) {
            localVarFormParams['assignment_override[student_ids]'] = ObjectSerializer.serialize(assignmentOverrideStudentIds, "Array<number>");
        }

        if (assignmentOverrideTitle !== undefined) {
            localVarFormParams['assignment_override[title]'] = ObjectSerializer.serialize(assignmentOverrideTitle, "string");
        }

        if (assignmentOverrideDueAt !== undefined) {
            localVarFormParams['assignment_override[due_at]'] = ObjectSerializer.serialize(assignmentOverrideDueAt, "Date");
        }

        if (assignmentOverrideUnlockAt !== undefined) {
            localVarFormParams['assignment_override[unlock_at]'] = ObjectSerializer.serialize(assignmentOverrideUnlockAt, "Date");
        }

        if (assignmentOverrideLockAt !== undefined) {
            localVarFormParams['assignment_override[lock_at]'] = ObjectSerializer.serialize(assignmentOverrideLockAt, "Date");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AssignmentOverride;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AssignmentOverride");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
