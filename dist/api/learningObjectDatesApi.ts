/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { LearningObjectDates } from '../model/learningObjectDates';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum LearningObjectDatesApiApiKeys {
}

export class LearningObjectDatesApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: LearningObjectDatesApiApiKeys, value: string) {
        (this.authentications as any)[LearningObjectDatesApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Get a learning object\'s date-related information, including due date, availability dates, override status, and a paginated list of all assignment overrides for the item.
     * @summary Get a learning object\'s date information
     * @param courseId ID
     * @param assignmentId ID
     */
    public async getLearningObjectSDateInformationAssignments (courseId: string, assignmentId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: LearningObjectDates;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/date_details'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getLearningObjectSDateInformationAssignments.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling getLearningObjectSDateInformationAssignments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: LearningObjectDates;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "LearningObjectDates");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a learning object\'s date-related information, including due date, availability dates, override status, and a paginated list of all assignment overrides for the item.
     * @summary Get a learning object\'s date information
     * @param courseId ID
     * @param discussionTopicId ID
     */
    public async getLearningObjectSDateInformationDiscussionTopics (courseId: string, discussionTopicId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: LearningObjectDates;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{discussion_topic_id}/date_details'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'discussion_topic_id' + '}', encodeURIComponent(String(discussionTopicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getLearningObjectSDateInformationDiscussionTopics.');
        }

        // verify required parameter 'discussionTopicId' is not null or undefined
        if (discussionTopicId === null || discussionTopicId === undefined) {
            throw new Error('Required parameter discussionTopicId was null or undefined when calling getLearningObjectSDateInformationDiscussionTopics.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: LearningObjectDates;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "LearningObjectDates");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a learning object\'s date-related information, including due date, availability dates, override status, and a paginated list of all assignment overrides for the item.
     * @summary Get a learning object\'s date information
     * @param courseId ID
     * @param attachmentId ID
     */
    public async getLearningObjectSDateInformationFiles (courseId: string, attachmentId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: LearningObjectDates;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/files/{attachment_id}/date_details'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'attachment_id' + '}', encodeURIComponent(String(attachmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getLearningObjectSDateInformationFiles.');
        }

        // verify required parameter 'attachmentId' is not null or undefined
        if (attachmentId === null || attachmentId === undefined) {
            throw new Error('Required parameter attachmentId was null or undefined when calling getLearningObjectSDateInformationFiles.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: LearningObjectDates;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "LearningObjectDates");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a learning object\'s date-related information, including due date, availability dates, override status, and a paginated list of all assignment overrides for the item.
     * @summary Get a learning object\'s date information
     * @param courseId ID
     * @param contextModuleId ID
     */
    public async getLearningObjectSDateInformationModules (courseId: string, contextModuleId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: LearningObjectDates;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/modules/{context_module_id}/date_details'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'context_module_id' + '}', encodeURIComponent(String(contextModuleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getLearningObjectSDateInformationModules.');
        }

        // verify required parameter 'contextModuleId' is not null or undefined
        if (contextModuleId === null || contextModuleId === undefined) {
            throw new Error('Required parameter contextModuleId was null or undefined when calling getLearningObjectSDateInformationModules.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: LearningObjectDates;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "LearningObjectDates");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a learning object\'s date-related information, including due date, availability dates, override status, and a paginated list of all assignment overrides for the item.
     * @summary Get a learning object\'s date information
     * @param courseId ID
     * @param urlOrId ID
     */
    public async getLearningObjectSDateInformationPages (courseId: string, urlOrId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: LearningObjectDates;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/pages/{url_or_id}/date_details'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'url_or_id' + '}', encodeURIComponent(String(urlOrId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getLearningObjectSDateInformationPages.');
        }

        // verify required parameter 'urlOrId' is not null or undefined
        if (urlOrId === null || urlOrId === undefined) {
            throw new Error('Required parameter urlOrId was null or undefined when calling getLearningObjectSDateInformationPages.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: LearningObjectDates;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "LearningObjectDates");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get a learning object\'s date-related information, including due date, availability dates, override status, and a paginated list of all assignment overrides for the item.
     * @summary Get a learning object\'s date information
     * @param courseId ID
     * @param quizId ID
     */
    public async getLearningObjectSDateInformationQuizzes (courseId: string, quizId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: LearningObjectDates;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/quizzes/{quiz_id}/date_details'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'quiz_id' + '}', encodeURIComponent(String(quizId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getLearningObjectSDateInformationQuizzes.');
        }

        // verify required parameter 'quizId' is not null or undefined
        if (quizId === null || quizId === undefined) {
            throw new Error('Required parameter quizId was null or undefined when calling getLearningObjectSDateInformationQuizzes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: LearningObjectDates;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "LearningObjectDates");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates date-related information for learning objects, including due date, availability dates, override status, and assignment overrides.  Returns 204 No Content response code if successful.
     * @summary Update a learning object\'s date information
     * @param courseId ID
     * @param assignmentId ID
     * @param dueAt The learning object\\\&#39;s due date. Not applicable for ungraded discussions, pages, and files.
     * @param unlockAt The learning object\\\&#39;s unlock date. Must be before the due date if there is one.
     * @param lockAt The learning object\\\&#39;s lock date. Must be after the due date if there is one.
     * @param onlyVisibleToOverrides Whether the learning object is only assigned to students who are targeted by an override.
     * @param assignmentOverrides List of overrides to apply to the learning object. Overrides that already exist should include an ID and will be updated if needed. New overrides will be created for overrides in the list without an ID. Overrides not included in the list will be deleted. Providing an empty list will delete all of the object\\\&#39;s overrides. Keys for each override object can include: \\\&#39;id\\\&#39;, \\\&#39;title\\\&#39;, \\\&#39;due_at\\\&#39;, \\\&#39;unlock_at\\\&#39;, \\\&#39;lock_at\\\&#39;, \\\&#39;student_ids\\\&#39;, and \\\&#39;course_section_id\\\&#39;, \\\&#39;course_id\\\&#39;, \\\&#39;noop_id\\\&#39;, and \\\&#39;unassign_item\\\&#39;.
     */
    public async updateLearningObjectSDateInformationAssignments (courseId: string, assignmentId: string, dueAt?: Date, unlockAt?: Date, lockAt?: Date, onlyVisibleToOverrides?: boolean, assignmentOverrides?: Array<Array<object>>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/assignments/{assignment_id}/date_details'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'assignment_id' + '}', encodeURIComponent(String(assignmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateLearningObjectSDateInformationAssignments.');
        }

        // verify required parameter 'assignmentId' is not null or undefined
        if (assignmentId === null || assignmentId === undefined) {
            throw new Error('Required parameter assignmentId was null or undefined when calling updateLearningObjectSDateInformationAssignments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (dueAt !== undefined) {
            localVarFormParams['due_at'] = ObjectSerializer.serialize(dueAt, "Date");
        }

        if (unlockAt !== undefined) {
            localVarFormParams['unlock_at'] = ObjectSerializer.serialize(unlockAt, "Date");
        }

        if (lockAt !== undefined) {
            localVarFormParams['lock_at'] = ObjectSerializer.serialize(lockAt, "Date");
        }

        if (onlyVisibleToOverrides !== undefined) {
            localVarFormParams['only_visible_to_overrides'] = ObjectSerializer.serialize(onlyVisibleToOverrides, "boolean");
        }

        if (assignmentOverrides !== undefined) {
            localVarFormParams['assignment_overrides'] = ObjectSerializer.serialize(assignmentOverrides, "Array<Array<object>>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates date-related information for learning objects, including due date, availability dates, override status, and assignment overrides.  Returns 204 No Content response code if successful.
     * @summary Update a learning object\'s date information
     * @param courseId ID
     * @param discussionTopicId ID
     * @param dueAt The learning object\\\&#39;s due date. Not applicable for ungraded discussions, pages, and files.
     * @param unlockAt The learning object\\\&#39;s unlock date. Must be before the due date if there is one.
     * @param lockAt The learning object\\\&#39;s lock date. Must be after the due date if there is one.
     * @param onlyVisibleToOverrides Whether the learning object is only assigned to students who are targeted by an override.
     * @param assignmentOverrides List of overrides to apply to the learning object. Overrides that already exist should include an ID and will be updated if needed. New overrides will be created for overrides in the list without an ID. Overrides not included in the list will be deleted. Providing an empty list will delete all of the object\\\&#39;s overrides. Keys for each override object can include: \\\&#39;id\\\&#39;, \\\&#39;title\\\&#39;, \\\&#39;due_at\\\&#39;, \\\&#39;unlock_at\\\&#39;, \\\&#39;lock_at\\\&#39;, \\\&#39;student_ids\\\&#39;, and \\\&#39;course_section_id\\\&#39;, \\\&#39;course_id\\\&#39;, \\\&#39;noop_id\\\&#39;, and \\\&#39;unassign_item\\\&#39;.
     */
    public async updateLearningObjectSDateInformationDiscussionTopics (courseId: string, discussionTopicId: string, dueAt?: Date, unlockAt?: Date, lockAt?: Date, onlyVisibleToOverrides?: boolean, assignmentOverrides?: Array<Array<object>>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/discussion_topics/{discussion_topic_id}/date_details'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'discussion_topic_id' + '}', encodeURIComponent(String(discussionTopicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateLearningObjectSDateInformationDiscussionTopics.');
        }

        // verify required parameter 'discussionTopicId' is not null or undefined
        if (discussionTopicId === null || discussionTopicId === undefined) {
            throw new Error('Required parameter discussionTopicId was null or undefined when calling updateLearningObjectSDateInformationDiscussionTopics.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (dueAt !== undefined) {
            localVarFormParams['due_at'] = ObjectSerializer.serialize(dueAt, "Date");
        }

        if (unlockAt !== undefined) {
            localVarFormParams['unlock_at'] = ObjectSerializer.serialize(unlockAt, "Date");
        }

        if (lockAt !== undefined) {
            localVarFormParams['lock_at'] = ObjectSerializer.serialize(lockAt, "Date");
        }

        if (onlyVisibleToOverrides !== undefined) {
            localVarFormParams['only_visible_to_overrides'] = ObjectSerializer.serialize(onlyVisibleToOverrides, "boolean");
        }

        if (assignmentOverrides !== undefined) {
            localVarFormParams['assignment_overrides'] = ObjectSerializer.serialize(assignmentOverrides, "Array<Array<object>>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates date-related information for learning objects, including due date, availability dates, override status, and assignment overrides.  Returns 204 No Content response code if successful.
     * @summary Update a learning object\'s date information
     * @param courseId ID
     * @param attachmentId ID
     * @param dueAt The learning object\\\&#39;s due date. Not applicable for ungraded discussions, pages, and files.
     * @param unlockAt The learning object\\\&#39;s unlock date. Must be before the due date if there is one.
     * @param lockAt The learning object\\\&#39;s lock date. Must be after the due date if there is one.
     * @param onlyVisibleToOverrides Whether the learning object is only assigned to students who are targeted by an override.
     * @param assignmentOverrides List of overrides to apply to the learning object. Overrides that already exist should include an ID and will be updated if needed. New overrides will be created for overrides in the list without an ID. Overrides not included in the list will be deleted. Providing an empty list will delete all of the object\\\&#39;s overrides. Keys for each override object can include: \\\&#39;id\\\&#39;, \\\&#39;title\\\&#39;, \\\&#39;due_at\\\&#39;, \\\&#39;unlock_at\\\&#39;, \\\&#39;lock_at\\\&#39;, \\\&#39;student_ids\\\&#39;, and \\\&#39;course_section_id\\\&#39;, \\\&#39;course_id\\\&#39;, \\\&#39;noop_id\\\&#39;, and \\\&#39;unassign_item\\\&#39;.
     */
    public async updateLearningObjectSDateInformationFiles (courseId: string, attachmentId: string, dueAt?: Date, unlockAt?: Date, lockAt?: Date, onlyVisibleToOverrides?: boolean, assignmentOverrides?: Array<Array<object>>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/files/{attachment_id}/date_details'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'attachment_id' + '}', encodeURIComponent(String(attachmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateLearningObjectSDateInformationFiles.');
        }

        // verify required parameter 'attachmentId' is not null or undefined
        if (attachmentId === null || attachmentId === undefined) {
            throw new Error('Required parameter attachmentId was null or undefined when calling updateLearningObjectSDateInformationFiles.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (dueAt !== undefined) {
            localVarFormParams['due_at'] = ObjectSerializer.serialize(dueAt, "Date");
        }

        if (unlockAt !== undefined) {
            localVarFormParams['unlock_at'] = ObjectSerializer.serialize(unlockAt, "Date");
        }

        if (lockAt !== undefined) {
            localVarFormParams['lock_at'] = ObjectSerializer.serialize(lockAt, "Date");
        }

        if (onlyVisibleToOverrides !== undefined) {
            localVarFormParams['only_visible_to_overrides'] = ObjectSerializer.serialize(onlyVisibleToOverrides, "boolean");
        }

        if (assignmentOverrides !== undefined) {
            localVarFormParams['assignment_overrides'] = ObjectSerializer.serialize(assignmentOverrides, "Array<Array<object>>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates date-related information for learning objects, including due date, availability dates, override status, and assignment overrides.  Returns 204 No Content response code if successful.
     * @summary Update a learning object\'s date information
     * @param courseId ID
     * @param urlOrId ID
     * @param dueAt The learning object\\\&#39;s due date. Not applicable for ungraded discussions, pages, and files.
     * @param unlockAt The learning object\\\&#39;s unlock date. Must be before the due date if there is one.
     * @param lockAt The learning object\\\&#39;s lock date. Must be after the due date if there is one.
     * @param onlyVisibleToOverrides Whether the learning object is only assigned to students who are targeted by an override.
     * @param assignmentOverrides List of overrides to apply to the learning object. Overrides that already exist should include an ID and will be updated if needed. New overrides will be created for overrides in the list without an ID. Overrides not included in the list will be deleted. Providing an empty list will delete all of the object\\\&#39;s overrides. Keys for each override object can include: \\\&#39;id\\\&#39;, \\\&#39;title\\\&#39;, \\\&#39;due_at\\\&#39;, \\\&#39;unlock_at\\\&#39;, \\\&#39;lock_at\\\&#39;, \\\&#39;student_ids\\\&#39;, and \\\&#39;course_section_id\\\&#39;, \\\&#39;course_id\\\&#39;, \\\&#39;noop_id\\\&#39;, and \\\&#39;unassign_item\\\&#39;.
     */
    public async updateLearningObjectSDateInformationPages (courseId: string, urlOrId: string, dueAt?: Date, unlockAt?: Date, lockAt?: Date, onlyVisibleToOverrides?: boolean, assignmentOverrides?: Array<Array<object>>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/pages/{url_or_id}/date_details'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'url_or_id' + '}', encodeURIComponent(String(urlOrId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateLearningObjectSDateInformationPages.');
        }

        // verify required parameter 'urlOrId' is not null or undefined
        if (urlOrId === null || urlOrId === undefined) {
            throw new Error('Required parameter urlOrId was null or undefined when calling updateLearningObjectSDateInformationPages.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (dueAt !== undefined) {
            localVarFormParams['due_at'] = ObjectSerializer.serialize(dueAt, "Date");
        }

        if (unlockAt !== undefined) {
            localVarFormParams['unlock_at'] = ObjectSerializer.serialize(unlockAt, "Date");
        }

        if (lockAt !== undefined) {
            localVarFormParams['lock_at'] = ObjectSerializer.serialize(lockAt, "Date");
        }

        if (onlyVisibleToOverrides !== undefined) {
            localVarFormParams['only_visible_to_overrides'] = ObjectSerializer.serialize(onlyVisibleToOverrides, "boolean");
        }

        if (assignmentOverrides !== undefined) {
            localVarFormParams['assignment_overrides'] = ObjectSerializer.serialize(assignmentOverrides, "Array<Array<object>>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates date-related information for learning objects, including due date, availability dates, override status, and assignment overrides.  Returns 204 No Content response code if successful.
     * @summary Update a learning object\'s date information
     * @param courseId ID
     * @param quizId ID
     * @param dueAt The learning object\\\&#39;s due date. Not applicable for ungraded discussions, pages, and files.
     * @param unlockAt The learning object\\\&#39;s unlock date. Must be before the due date if there is one.
     * @param lockAt The learning object\\\&#39;s lock date. Must be after the due date if there is one.
     * @param onlyVisibleToOverrides Whether the learning object is only assigned to students who are targeted by an override.
     * @param assignmentOverrides List of overrides to apply to the learning object. Overrides that already exist should include an ID and will be updated if needed. New overrides will be created for overrides in the list without an ID. Overrides not included in the list will be deleted. Providing an empty list will delete all of the object\\\&#39;s overrides. Keys for each override object can include: \\\&#39;id\\\&#39;, \\\&#39;title\\\&#39;, \\\&#39;due_at\\\&#39;, \\\&#39;unlock_at\\\&#39;, \\\&#39;lock_at\\\&#39;, \\\&#39;student_ids\\\&#39;, and \\\&#39;course_section_id\\\&#39;, \\\&#39;course_id\\\&#39;, \\\&#39;noop_id\\\&#39;, and \\\&#39;unassign_item\\\&#39;.
     */
    public async updateLearningObjectSDateInformationQuizzes (courseId: string, quizId: string, dueAt?: Date, unlockAt?: Date, lockAt?: Date, onlyVisibleToOverrides?: boolean, assignmentOverrides?: Array<Array<object>>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/quizzes/{quiz_id}/date_details'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'quiz_id' + '}', encodeURIComponent(String(quizId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling updateLearningObjectSDateInformationQuizzes.');
        }

        // verify required parameter 'quizId' is not null or undefined
        if (quizId === null || quizId === undefined) {
            throw new Error('Required parameter quizId was null or undefined when calling updateLearningObjectSDateInformationQuizzes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (dueAt !== undefined) {
            localVarFormParams['due_at'] = ObjectSerializer.serialize(dueAt, "Date");
        }

        if (unlockAt !== undefined) {
            localVarFormParams['unlock_at'] = ObjectSerializer.serialize(unlockAt, "Date");
        }

        if (lockAt !== undefined) {
            localVarFormParams['lock_at'] = ObjectSerializer.serialize(lockAt, "Date");
        }

        if (onlyVisibleToOverrides !== undefined) {
            localVarFormParams['only_visible_to_overrides'] = ObjectSerializer.serialize(onlyVisibleToOverrides, "boolean");
        }

        if (assignmentOverrides !== undefined) {
            localVarFormParams['assignment_overrides'] = ObjectSerializer.serialize(assignmentOverrides, "Array<Array<object>>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
