/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Account } from '../model/account';
import { HelpLinks } from '../model/helpLinks';
import { TermsOfService } from '../model/termsOfService';
import { User } from '../model/user';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum AccountsApiApiKeys {
}

export class AccountsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: AccountsApiApiKeys, value: string) {
        (this.authentications as any)[AccountsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Add a new sub-account to a given account.
     * @summary Create a new sub-account
     * @param accountId ID
     * @param accountName The name of the new sub-account.
     * @param accountSisAccountId The account\\\&#39;s identifier in the Student Information System.
     * @param accountDefaultStorageQuotaMb The default course storage quota to be used, if not otherwise specified.
     * @param accountDefaultUserStorageQuotaMb The default user storage quota to be used, if not otherwise specified.
     * @param accountDefaultGroupStorageQuotaMb The default group storage quota to be used, if not otherwise specified.
     */
    public async createNewSubAccount (accountId: string, accountName: string, accountSisAccountId?: string, accountDefaultStorageQuotaMb?: number, accountDefaultUserStorageQuotaMb?: number, accountDefaultGroupStorageQuotaMb?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/sub_accounts'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createNewSubAccount.');
        }

        // verify required parameter 'accountName' is not null or undefined
        if (accountName === null || accountName === undefined) {
            throw new Error('Required parameter accountName was null or undefined when calling createNewSubAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (accountName !== undefined) {
            localVarFormParams['account[name]'] = ObjectSerializer.serialize(accountName, "string");
        }

        if (accountSisAccountId !== undefined) {
            localVarFormParams['account[sis_account_id]'] = ObjectSerializer.serialize(accountSisAccountId, "string");
        }

        if (accountDefaultStorageQuotaMb !== undefined) {
            localVarFormParams['account[default_storage_quota_mb]'] = ObjectSerializer.serialize(accountDefaultStorageQuotaMb, "number");
        }

        if (accountDefaultUserStorageQuotaMb !== undefined) {
            localVarFormParams['account[default_user_storage_quota_mb]'] = ObjectSerializer.serialize(accountDefaultUserStorageQuotaMb, "number");
        }

        if (accountDefaultGroupStorageQuotaMb !== undefined) {
            localVarFormParams['account[default_group_storage_quota_mb]'] = ObjectSerializer.serialize(accountDefaultGroupStorageQuotaMb, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Account");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Cannot delete an account with active courses or active sub_accounts. Cannot delete a root_account
     * @summary Delete a sub-account
     * @param accountId ID
     * @param id ID
     */
    public async deleteSubAccount (accountId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/sub_accounts/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteSubAccount.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSubAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Account");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete a user record from a Canvas root account. If a user is associated with multiple root accounts (in a multi-tenant instance of Canvas), this action will NOT remove them from the other accounts.  WARNING: This API will allow a user to remove themselves from the account. If they do this, they won\'t be able to make API calls or log into Canvas at that account.
     * @summary Delete a user from the root account
     * @param accountId ID
     * @param userId ID
     */
    public async deleteUserFromRootAccount (accountId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: User;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/users/{user_id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteUserFromRootAccount.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deleteUserFromRootAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: User;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "User");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of accounts where the current user has permission to create or manage courses. List will be empty for students and teachers as only admins can view which accounts they are in.
     * @summary Get accounts that admins can manage
     */
    public async getAccountsThatAdminsCanManage (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Account>;  }> {
        const localVarPath = this.basePath + '/v1/manageable_accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Account>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Account>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of accounts where the current user has permission to create courses.
     * @summary Get accounts that users can create courses in
     */
    public async getAccountsThatUsersCanCreateCoursesIn (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Account>;  }> {
        const localVarPath = this.basePath + '/v1/course_creation_accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Account>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Account>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the help links for that account
     * @summary Get help links
     * @param accountId ID
     */
    public async getHelpLinks (accountId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: HelpLinks;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/help_links'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getHelpLinks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: HelpLinks;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "HelpLinks");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Get the manually-created courses sub-account for the domain root account
     */
    public async getManuallyCreatedCoursesSubAccountForDomainRootAccount (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/v1/manually_created_courses_account';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Account");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve information on an individual account, given by id or sis sis_account_id.
     * @summary Get a single account
     * @param id ID
     */
    public async getSingleAccount (id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSingleAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Account");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List accounts that are sub-accounts of the given account.
     * @summary Get the sub-accounts of an account
     * @param accountId ID
     * @param recursive If true, the entire account tree underneath this account will be returned (though still paginated). If false, only direct sub-accounts of this account will be returned. Defaults to false.
     * @param order Sorts the accounts by id or name. Only applies when recursive is false. Defaults to id.
     * @param include Array of additional information to include.  \&quot;course_count\&quot;:: returns the number of courses directly under each account \&quot;sub_account_count\&quot;:: returns the number of sub-accounts directly under each account
     */
    public async getSubAccountsOfAccount (accountId: string, recursive?: boolean, order?: 'id' | 'name', include?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Account>;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/sub_accounts'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getSubAccountsOfAccount.');
        }

        if (recursive !== undefined) {
            localVarQueryParameters['recursive'] = ObjectSerializer.serialize(recursive, "boolean");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "'id' | 'name'");
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Account>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Account>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the terms of service for that account
     * @summary Get the Terms of Service
     * @param accountId ID
     */
    public async getTermsOfService (accountId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TermsOfService;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/terms_of_service'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getTermsOfService.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TermsOfService;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TermsOfService");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of accounts that the current user can view or manage. Typically, students and even teachers will get an empty list in response, only account admins can view the accounts that they are in.
     * @summary List accounts
     * @param include Array of additional information to include.  \&quot;lti_guid\&quot;:: the \&#39;tool_consumer_instance_guid\&#39; that will be sent for this account on LTI launches \&quot;registration_settings\&quot;:: returns info about the privacy policy and terms of use \&quot;services\&quot;:: returns services and whether they are enabled (requires account management permissions) \&quot;course_count\&quot;:: returns the number of courses directly under each account \&quot;sub_account_count\&quot;:: returns the number of sub-accounts directly under each account
     */
    public async listAccounts (include?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Account>;  }> {
        const localVarPath = this.basePath + '/v1/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Account>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Account>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of accounts that the current user can view through their admin course enrollments. (Teacher, TA, or designer enrollments). Only returns \"id\", \"name\", \"workflow_state\", \"root_account_id\" and \"parent_account_id\"
     * @summary List accounts for course admins
     */
    public async listAccountsForCourseAdmins (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Account>;  }> {
        const localVarPath = this.basePath + '/v1/course_accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Account>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Account>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Return a hash of global settings for the root account This is the same information supplied to the web interface as +ENV.SETTINGS+.
     * @summary List environment settings
     */
    public async listEnvironmentSettings (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/settings/environment';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns permission information for the calling user and the given account. You may use `self` as the account id to check permissions against the domain root account. The caller must have an account role or admin (teacher/TA/designer) enrollment in a course in the account.  See also the {api:CoursesController#permissions Course} and {api:GroupsController#permissions Group} counterparts.
     * @summary Permissions
     * @param accountId ID
     * @param permissions List of permissions to check against the authenticated user. Permission names are documented in the {api:RoleOverridesController#add_role Create a role} endpoint.
     */
    public async permissions (accountId: string, permissions?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/permissions'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling permissions.');
        }

        if (permissions !== undefined) {
            localVarQueryParameters['permissions'] = ObjectSerializer.serialize(permissions, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Restore a user record along with the most recently deleted pseudonym from a Canvas root account.
     * @summary Restore a deleted user from a root account
     * @param accountId ID
     * @param userId ID
     */
    public async restoreDeletedUserFromRootAccount (accountId: string, userId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: User;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/users/{user_id}/restore'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling restoreDeletedUserFromRootAccount.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling restoreDeletedUserFromRootAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: User;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "User");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns a JSON object containing a subset of settings for the specified account. It\'s possible an empty set will be returned if no settings are applicable. The caller must be an Account admin with the manage_account_settings permission.
     * @summary Settings
     * @param accountId ID
     */
    public async settings (accountId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/settings'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling settings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update an existing account.
     * @summary Update an account
     * @param id ID
     * @param accountName Updates the account name
     * @param accountSisAccountId Updates the account sis_account_id Must have manage_sis permission and must not be a root_account.
     * @param accountDefaultTimeZone The default time zone of the account. Allowed time zones are {http://www.iana.org/time-zones IANA time zones} or friendlier {http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html Ruby on Rails time zones}.
     * @param accountDefaultStorageQuotaMb The default course storage quota to be used, if not otherwise specified.
     * @param accountDefaultUserStorageQuotaMb The default user storage quota to be used, if not otherwise specified.
     * @param accountDefaultGroupStorageQuotaMb The default group storage quota to be used, if not otherwise specified.
     * @param accountCourseTemplateId The ID of a course to be used as a template for all newly created courses. Empty means to inherit the setting from parent account, 0 means to not use a template even if a parent account has one set. The course must be marked as a template.
     * @param accountParentAccountId The ID of a parent account to move the account to. The new parent account must be in the same root account as the original. The hierarchy of sub-accounts will be preserved in the new parent account. The caller must be an administrator in both the original parent account and the new parent account.
     * @param accountSettingsRestrictStudentPastViewValue Restrict students from viewing courses after end date
     * @param accountSettingsRestrictStudentPastViewLocked Lock this setting for sub-accounts and courses
     * @param accountSettingsRestrictStudentFutureViewValue Restrict students from viewing courses before start date
     * @param accountSettingsMicrosoftSyncEnabled Determines whether this account has Microsoft Teams Sync enabled or not.  Note that if you are altering Microsoft Teams sync settings you must enable the Microsoft Group enrollment syncing feature flag. In addition, if you are enabling Microsoft Teams sync, you must also specify a tenant, login attribute, and a remote attribute. Specifying a suffix to use is optional.
     * @param accountSettingsMicrosoftSyncTenant The tenant this account should use when using Microsoft Teams Sync. This should be an Azure Active Directory domain name.
     * @param accountSettingsMicrosoftSyncLoginAttribute The attribute this account should use to lookup users when using Microsoft Teams Sync. Must be one of \\\&quot;sub\\\&quot;, \\\&quot;email\\\&quot;, \\\&quot;oid\\\&quot;, \\\&quot;preferred_username\\\&quot;, or \\\&quot;integration_id\\\&quot;.
     * @param accountSettingsMicrosoftSyncLoginAttributeSuffix A suffix that will be appended to the result of the login attribute when associating Canvas users with Microsoft users. Must be under 255 characters and contain no whitespace. This field is optional.
     * @param accountSettingsMicrosoftSyncRemoteAttribute The Active Directory attribute to use when associating Canvas users with Microsoft users. Must be one of \\\&quot;mail\\\&quot;, \\\&quot;mailNickname\\\&quot;, or \\\&quot;userPrincipalName\\\&quot;.
     * @param accountSettingsRestrictStudentFutureViewLocked Lock this setting for sub-accounts and courses
     * @param accountSettingsLockAllAnnouncementsValue Disable comments on announcements
     * @param accountSettingsLockAllAnnouncementsLocked Lock this setting for sub-accounts and courses
     * @param accountSettingsUsageRightsRequiredValue Copyright and license information must be provided for files before they are published.
     * @param accountSettingsUsageRightsRequiredLocked Lock this setting for sub-accounts and courses
     * @param accountSettingsRestrictStudentFutureListingValue Restrict students from viewing future enrollments in course list
     * @param accountSettingsRestrictStudentFutureListingLocked Lock this setting for sub-accounts and courses
     * @param accountSettingsConditionalReleaseValue Enable or disable individual learning paths for students based on assessment
     * @param accountSettingsConditionalReleaseLocked Lock this setting for sub-accounts and courses
     * @param accountSettingsPasswordPolicy Hash of optional password policy configuration parameters for a root account  +allow_login_suspension+ boolean:: Allow suspension of user logins upon reaching maximum_login_attempts  +require_number_characters+ boolean:: Require the use of number characters when setting up a new password  +require_symbol_characters+ boolean:: Require the use of symbol characters when setting up a new password  +minimum_character_length+ integer:: Minimum number of characters required for a new password  +maximum_login_attempts+ integer:: Maximum number of login attempts before a user is locked out  _Required_ feature option:   Enhance password options
     * @param accountSettingsEnableAsK5AccountValue Enable or disable Canvas for Elementary for this account
     * @param accountSettingsUseClassicFontInK5Value Whether or not the classic font is used on the dashboard. Only applies if enable_as_k5_account is true.
     * @param accountSettingsHorizonAccountValue Enable or disable Canvas Career for this account
     * @param overrideSisStickiness Default is true. If false, any fields containing sticky changes will not be updated. See SIS CSV Format documentation for information on which fields can have SIS stickiness
     * @param accountSettingsLockOutcomeProficiencyValue [DEPRECATED] Restrict instructors from changing mastery scale
     * @param accountLockOutcomeProficiencyLocked [DEPRECATED] Lock this setting for sub-accounts and courses
     * @param accountSettingsLockProficiencyCalculationValue [DEPRECATED] Restrict instructors from changing proficiency calculation method
     * @param accountLockProficiencyCalculationLocked [DEPRECATED] Lock this setting for sub-accounts and courses
     * @param accountServices Give this a set of keys and boolean values to enable or disable services matching the keys
     */
    public async updateAccount (id: string, accountName?: string, accountSisAccountId?: string, accountDefaultTimeZone?: string, accountDefaultStorageQuotaMb?: number, accountDefaultUserStorageQuotaMb?: number, accountDefaultGroupStorageQuotaMb?: number, accountCourseTemplateId?: number, accountParentAccountId?: number, accountSettingsRestrictStudentPastViewValue?: boolean, accountSettingsRestrictStudentPastViewLocked?: boolean, accountSettingsRestrictStudentFutureViewValue?: boolean, accountSettingsMicrosoftSyncEnabled?: boolean, accountSettingsMicrosoftSyncTenant?: string, accountSettingsMicrosoftSyncLoginAttribute?: string, accountSettingsMicrosoftSyncLoginAttributeSuffix?: string, accountSettingsMicrosoftSyncRemoteAttribute?: string, accountSettingsRestrictStudentFutureViewLocked?: boolean, accountSettingsLockAllAnnouncementsValue?: boolean, accountSettingsLockAllAnnouncementsLocked?: boolean, accountSettingsUsageRightsRequiredValue?: boolean, accountSettingsUsageRightsRequiredLocked?: boolean, accountSettingsRestrictStudentFutureListingValue?: boolean, accountSettingsRestrictStudentFutureListingLocked?: boolean, accountSettingsConditionalReleaseValue?: boolean, accountSettingsConditionalReleaseLocked?: boolean, accountSettingsPasswordPolicy?: any, accountSettingsEnableAsK5AccountValue?: boolean, accountSettingsUseClassicFontInK5Value?: boolean, accountSettingsHorizonAccountValue?: boolean, overrideSisStickiness?: boolean, accountSettingsLockOutcomeProficiencyValue?: boolean, accountLockOutcomeProficiencyLocked?: boolean, accountSettingsLockProficiencyCalculationValue?: boolean, accountLockProficiencyCalculationLocked?: boolean, accountServices?: any, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (accountName !== undefined) {
            localVarFormParams['account[name]'] = ObjectSerializer.serialize(accountName, "string");
        }

        if (accountSisAccountId !== undefined) {
            localVarFormParams['account[sis_account_id]'] = ObjectSerializer.serialize(accountSisAccountId, "string");
        }

        if (accountDefaultTimeZone !== undefined) {
            localVarFormParams['account[default_time_zone]'] = ObjectSerializer.serialize(accountDefaultTimeZone, "string");
        }

        if (accountDefaultStorageQuotaMb !== undefined) {
            localVarFormParams['account[default_storage_quota_mb]'] = ObjectSerializer.serialize(accountDefaultStorageQuotaMb, "number");
        }

        if (accountDefaultUserStorageQuotaMb !== undefined) {
            localVarFormParams['account[default_user_storage_quota_mb]'] = ObjectSerializer.serialize(accountDefaultUserStorageQuotaMb, "number");
        }

        if (accountDefaultGroupStorageQuotaMb !== undefined) {
            localVarFormParams['account[default_group_storage_quota_mb]'] = ObjectSerializer.serialize(accountDefaultGroupStorageQuotaMb, "number");
        }

        if (accountCourseTemplateId !== undefined) {
            localVarFormParams['account[course_template_id]'] = ObjectSerializer.serialize(accountCourseTemplateId, "number");
        }

        if (accountParentAccountId !== undefined) {
            localVarFormParams['account[parent_account_id]'] = ObjectSerializer.serialize(accountParentAccountId, "number");
        }

        if (accountSettingsRestrictStudentPastViewValue !== undefined) {
            localVarFormParams['account[settings][restrict_student_past_view][value]'] = ObjectSerializer.serialize(accountSettingsRestrictStudentPastViewValue, "boolean");
        }

        if (accountSettingsRestrictStudentPastViewLocked !== undefined) {
            localVarFormParams['account[settings][restrict_student_past_view][locked]'] = ObjectSerializer.serialize(accountSettingsRestrictStudentPastViewLocked, "boolean");
        }

        if (accountSettingsRestrictStudentFutureViewValue !== undefined) {
            localVarFormParams['account[settings][restrict_student_future_view][value]'] = ObjectSerializer.serialize(accountSettingsRestrictStudentFutureViewValue, "boolean");
        }

        if (accountSettingsMicrosoftSyncEnabled !== undefined) {
            localVarFormParams['account[settings][microsoft_sync_enabled]'] = ObjectSerializer.serialize(accountSettingsMicrosoftSyncEnabled, "boolean");
        }

        if (accountSettingsMicrosoftSyncTenant !== undefined) {
            localVarFormParams['account[settings][microsoft_sync_tenant]'] = ObjectSerializer.serialize(accountSettingsMicrosoftSyncTenant, "string");
        }

        if (accountSettingsMicrosoftSyncLoginAttribute !== undefined) {
            localVarFormParams['account[settings][microsoft_sync_login_attribute]'] = ObjectSerializer.serialize(accountSettingsMicrosoftSyncLoginAttribute, "string");
        }

        if (accountSettingsMicrosoftSyncLoginAttributeSuffix !== undefined) {
            localVarFormParams['account[settings][microsoft_sync_login_attribute_suffix]'] = ObjectSerializer.serialize(accountSettingsMicrosoftSyncLoginAttributeSuffix, "string");
        }

        if (accountSettingsMicrosoftSyncRemoteAttribute !== undefined) {
            localVarFormParams['account[settings][microsoft_sync_remote_attribute]'] = ObjectSerializer.serialize(accountSettingsMicrosoftSyncRemoteAttribute, "string");
        }

        if (accountSettingsRestrictStudentFutureViewLocked !== undefined) {
            localVarFormParams['account[settings][restrict_student_future_view][locked]'] = ObjectSerializer.serialize(accountSettingsRestrictStudentFutureViewLocked, "boolean");
        }

        if (accountSettingsLockAllAnnouncementsValue !== undefined) {
            localVarFormParams['account[settings][lock_all_announcements][value]'] = ObjectSerializer.serialize(accountSettingsLockAllAnnouncementsValue, "boolean");
        }

        if (accountSettingsLockAllAnnouncementsLocked !== undefined) {
            localVarFormParams['account[settings][lock_all_announcements][locked]'] = ObjectSerializer.serialize(accountSettingsLockAllAnnouncementsLocked, "boolean");
        }

        if (accountSettingsUsageRightsRequiredValue !== undefined) {
            localVarFormParams['account[settings][usage_rights_required][value]'] = ObjectSerializer.serialize(accountSettingsUsageRightsRequiredValue, "boolean");
        }

        if (accountSettingsUsageRightsRequiredLocked !== undefined) {
            localVarFormParams['account[settings][usage_rights_required][locked]'] = ObjectSerializer.serialize(accountSettingsUsageRightsRequiredLocked, "boolean");
        }

        if (accountSettingsRestrictStudentFutureListingValue !== undefined) {
            localVarFormParams['account[settings][restrict_student_future_listing][value]'] = ObjectSerializer.serialize(accountSettingsRestrictStudentFutureListingValue, "boolean");
        }

        if (accountSettingsRestrictStudentFutureListingLocked !== undefined) {
            localVarFormParams['account[settings][restrict_student_future_listing][locked]'] = ObjectSerializer.serialize(accountSettingsRestrictStudentFutureListingLocked, "boolean");
        }

        if (accountSettingsConditionalReleaseValue !== undefined) {
            localVarFormParams['account[settings][conditional_release][value]'] = ObjectSerializer.serialize(accountSettingsConditionalReleaseValue, "boolean");
        }

        if (accountSettingsConditionalReleaseLocked !== undefined) {
            localVarFormParams['account[settings][conditional_release][locked]'] = ObjectSerializer.serialize(accountSettingsConditionalReleaseLocked, "boolean");
        }

        if (accountSettingsPasswordPolicy !== undefined) {
            localVarFormParams['account[settings][password_policy]'] = ObjectSerializer.serialize(accountSettingsPasswordPolicy, "any");
        }

        if (accountSettingsEnableAsK5AccountValue !== undefined) {
            localVarFormParams['account[settings][enable_as_k5_account][value]'] = ObjectSerializer.serialize(accountSettingsEnableAsK5AccountValue, "boolean");
        }

        if (accountSettingsUseClassicFontInK5Value !== undefined) {
            localVarFormParams['account[settings][use_classic_font_in_k5][value]'] = ObjectSerializer.serialize(accountSettingsUseClassicFontInK5Value, "boolean");
        }

        if (accountSettingsHorizonAccountValue !== undefined) {
            localVarFormParams['account[settings][horizon_account][value]'] = ObjectSerializer.serialize(accountSettingsHorizonAccountValue, "boolean");
        }

        if (overrideSisStickiness !== undefined) {
            localVarFormParams['override_sis_stickiness'] = ObjectSerializer.serialize(overrideSisStickiness, "boolean");
        }

        if (accountSettingsLockOutcomeProficiencyValue !== undefined) {
            localVarFormParams['account[settings][lock_outcome_proficiency][value]'] = ObjectSerializer.serialize(accountSettingsLockOutcomeProficiencyValue, "boolean");
        }

        if (accountLockOutcomeProficiencyLocked !== undefined) {
            localVarFormParams['account[lock_outcome_proficiency][locked]'] = ObjectSerializer.serialize(accountLockOutcomeProficiencyLocked, "boolean");
        }

        if (accountSettingsLockProficiencyCalculationValue !== undefined) {
            localVarFormParams['account[settings][lock_proficiency_calculation][value]'] = ObjectSerializer.serialize(accountSettingsLockProficiencyCalculationValue, "boolean");
        }

        if (accountLockProficiencyCalculationLocked !== undefined) {
            localVarFormParams['account[lock_proficiency_calculation][locked]'] = ObjectSerializer.serialize(accountLockProficiencyCalculationLocked, "boolean");
        }

        if (accountServices !== undefined) {
            localVarFormParams['account[services]'] = ObjectSerializer.serialize(accountServices, "any");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Account");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
