/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Arrayofoutcomeids } from '../model/arrayofoutcomeids';
import { OutcomeImport } from '../model/outcomeImport';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum OutcomeImportsApiApiKeys {
}

export class OutcomeImportsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: OutcomeImportsApiApiKeys, value: string) {
        (this.authentications as any)[OutcomeImportsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Get the IDs of the outcome groups created after a successful import. Pass \'latest\' for the outcome import id for the latest import.    Examples:     curl \'https://<canvas>/api/v1/accounts/<account_id>/outcome_imports/outcomes_group_ids/<outcome_import_id>\' \\         -H \"Authorization: Bearer <token>\"     curl \'https://<canvas>/api/v1/courses/<course_id>/outcome_imports/outcome_group_ids/<outcome_import_id>\' \\         -H \"Authorization: Bearer <token>\"
     * @summary Get IDs of outcome groups created after successful import
     * @param accountId ID
     * @param id ID
     */
    public async getIdsOfOutcomeGroupsCreatedAfterSuccessfulImportAccounts (accountId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array of outcome ids;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/outcome_imports/{id}/created_group_ids'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getIdsOfOutcomeGroupsCreatedAfterSuccessfulImportAccounts.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getIdsOfOutcomeGroupsCreatedAfterSuccessfulImportAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array of outcome ids;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array of outcome ids");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get the IDs of the outcome groups created after a successful import. Pass \'latest\' for the outcome import id for the latest import.    Examples:     curl \'https://<canvas>/api/v1/accounts/<account_id>/outcome_imports/outcomes_group_ids/<outcome_import_id>\' \\         -H \"Authorization: Bearer <token>\"     curl \'https://<canvas>/api/v1/courses/<course_id>/outcome_imports/outcome_group_ids/<outcome_import_id>\' \\         -H \"Authorization: Bearer <token>\"
     * @summary Get IDs of outcome groups created after successful import
     * @param courseId ID
     * @param id ID
     */
    public async getIdsOfOutcomeGroupsCreatedAfterSuccessfulImportCourses (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array of outcome ids;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/outcome_imports/{id}/created_group_ids'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getIdsOfOutcomeGroupsCreatedAfterSuccessfulImportCourses.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getIdsOfOutcomeGroupsCreatedAfterSuccessfulImportCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array of outcome ids;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array of outcome ids");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get the status of an already created Outcome import. Pass \'latest\' for the outcome import id for the latest import.    Examples:     curl \'https://<canvas>/api/v1/accounts/<account_id>/outcome_imports/<outcome_import_id>\' \\         -H \"Authorization: Bearer <token>\"     curl \'https://<canvas>/api/v1/courses/<course_id>/outcome_imports/<outcome_import_id>\' \\         -H \"Authorization: Bearer <token>\"
     * @summary Get Outcome import status
     * @param accountId ID
     * @param id ID
     */
    public async getOutcomeImportStatusAccounts (accountId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: OutcomeImport;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/outcome_imports/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getOutcomeImportStatusAccounts.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getOutcomeImportStatusAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: OutcomeImport;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "OutcomeImport");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get the status of an already created Outcome import. Pass \'latest\' for the outcome import id for the latest import.    Examples:     curl \'https://<canvas>/api/v1/accounts/<account_id>/outcome_imports/<outcome_import_id>\' \\         -H \"Authorization: Bearer <token>\"     curl \'https://<canvas>/api/v1/courses/<course_id>/outcome_imports/<outcome_import_id>\' \\         -H \"Authorization: Bearer <token>\"
     * @summary Get Outcome import status
     * @param courseId ID
     * @param id ID
     */
    public async getOutcomeImportStatusCourses (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: OutcomeImport;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/outcome_imports/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling getOutcomeImportStatusCourses.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getOutcomeImportStatusCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: OutcomeImport;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "OutcomeImport");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Import outcomes into Canvas.  For more information on the format that\'s expected here, please see the \"Outcomes CSV\" section in the API docs.
     * @summary Import Outcomes
     * @param accountId ID
     * @param importType Choose the data format for reading outcome data. With a standard Canvas install, this option can only be \\\&#39;instructure_csv\\\&#39;, and if unprovided, will be assumed to be so. Can be part of the query string.
     * @param attachment There are two ways to post outcome import data - either via a multipart/form-data form-field-style attachment, or via a non-multipart raw post request.  \\\&#39;attachment\\\&#39; is required for multipart/form-data style posts. Assumed to be outcome data from a file upload form field named \\\&#39;attachment\\\&#39;.  Examples:   curl -F attachment&#x3D;@&lt;filename&gt; -H \\\&quot;Authorization: Bearer &lt;token&gt;\\\&quot; \\\\       \\\&#39;https://&lt;canvas&gt;/api/v1/accounts/&lt;account_id&gt;/outcome_imports?import_type&#x3D;instructure_csv\\\&#39;   curl -F attachment&#x3D;@&lt;filename&gt; -H \\\&quot;Authorization: Bearer &lt;token&gt;\\\&quot; \\\\       \\\&#39;https://&lt;canvas&gt;/api/v1/courses/&lt;course_id&gt;/outcome_imports?import_type&#x3D;instructure_csv\\\&#39;  If you decide to do a raw post, you can skip the \\\&#39;attachment\\\&#39; argument, but you will then be required to provide a suitable Content-Type header. You are encouraged to also provide the \\\&#39;extension\\\&#39; argument.  Examples:   curl -H \\\&#39;Content-Type: text/csv\\\&#39; --data-binary @&lt;filename&gt;.csv \\\\       -H \\\&quot;Authorization: Bearer &lt;token&gt;\\\&quot; \\\\       \\\&#39;https://&lt;canvas&gt;/api/v1/accounts/&lt;account_id&gt;/outcome_imports?import_type&#x3D;instructure_csv\\\&#39;    curl -H \\\&#39;Content-Type: text/csv\\\&#39; --data-binary @&lt;filename&gt;.csv \\\\       -H \\\&quot;Authorization: Bearer &lt;token&gt;\\\&quot; \\\\       \\\&#39;https://&lt;canvas&gt;/api/v1/courses/&lt;course_id&gt;/outcome_imports?import_type&#x3D;instructure_csv\\\&#39;
     * @param extension Recommended for raw post request style imports. This field will be used to distinguish between csv and other file format extensions that would usually be provided with the filename in the multipart post request scenario. If not provided, this value will be inferred from the Content-Type, falling back to csv-file format if all else fails.
     */
    public async importOutcomesAccounts (accountId: string, importType?: string, attachment?: string, extension?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: OutcomeImport;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/outcome_imports'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling importOutcomesAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (importType !== undefined) {
            localVarFormParams['import_type'] = ObjectSerializer.serialize(importType, "string");
        }

        if (attachment !== undefined) {
            localVarFormParams['attachment'] = ObjectSerializer.serialize(attachment, "string");
        }

        if (extension !== undefined) {
            localVarFormParams['extension'] = ObjectSerializer.serialize(extension, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: OutcomeImport;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "OutcomeImport");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Import outcomes into Canvas.  For more information on the format that\'s expected here, please see the \"Outcomes CSV\" section in the API docs.
     * @summary Import Outcomes
     * @param courseId ID
     * @param importType Choose the data format for reading outcome data. With a standard Canvas install, this option can only be \\\&#39;instructure_csv\\\&#39;, and if unprovided, will be assumed to be so. Can be part of the query string.
     * @param attachment There are two ways to post outcome import data - either via a multipart/form-data form-field-style attachment, or via a non-multipart raw post request.  \\\&#39;attachment\\\&#39; is required for multipart/form-data style posts. Assumed to be outcome data from a file upload form field named \\\&#39;attachment\\\&#39;.  Examples:   curl -F attachment&#x3D;@&lt;filename&gt; -H \\\&quot;Authorization: Bearer &lt;token&gt;\\\&quot; \\\\       \\\&#39;https://&lt;canvas&gt;/api/v1/accounts/&lt;account_id&gt;/outcome_imports?import_type&#x3D;instructure_csv\\\&#39;   curl -F attachment&#x3D;@&lt;filename&gt; -H \\\&quot;Authorization: Bearer &lt;token&gt;\\\&quot; \\\\       \\\&#39;https://&lt;canvas&gt;/api/v1/courses/&lt;course_id&gt;/outcome_imports?import_type&#x3D;instructure_csv\\\&#39;  If you decide to do a raw post, you can skip the \\\&#39;attachment\\\&#39; argument, but you will then be required to provide a suitable Content-Type header. You are encouraged to also provide the \\\&#39;extension\\\&#39; argument.  Examples:   curl -H \\\&#39;Content-Type: text/csv\\\&#39; --data-binary @&lt;filename&gt;.csv \\\\       -H \\\&quot;Authorization: Bearer &lt;token&gt;\\\&quot; \\\\       \\\&#39;https://&lt;canvas&gt;/api/v1/accounts/&lt;account_id&gt;/outcome_imports?import_type&#x3D;instructure_csv\\\&#39;    curl -H \\\&#39;Content-Type: text/csv\\\&#39; --data-binary @&lt;filename&gt;.csv \\\\       -H \\\&quot;Authorization: Bearer &lt;token&gt;\\\&quot; \\\\       \\\&#39;https://&lt;canvas&gt;/api/v1/courses/&lt;course_id&gt;/outcome_imports?import_type&#x3D;instructure_csv\\\&#39;
     * @param extension Recommended for raw post request style imports. This field will be used to distinguish between csv and other file format extensions that would usually be provided with the filename in the multipart post request scenario. If not provided, this value will be inferred from the Content-Type, falling back to csv-file format if all else fails.
     */
    public async importOutcomesCourses (courseId: string, importType?: string, attachment?: string, extension?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: OutcomeImport;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/outcome_imports'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling importOutcomesCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (importType !== undefined) {
            localVarFormParams['import_type'] = ObjectSerializer.serialize(importType, "string");
        }

        if (attachment !== undefined) {
            localVarFormParams['attachment'] = ObjectSerializer.serialize(attachment, "string");
        }

        if (extension !== undefined) {
            localVarFormParams['extension'] = ObjectSerializer.serialize(extension, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: OutcomeImport;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "OutcomeImport");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
