/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { CalendarEvent } from '../model/calendarEvent';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum AppointmentGroupsApiApiKeys {
}

export class AppointmentGroupsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: AppointmentGroupsApiApiKeys, value: string) {
        (this.authentications as any)[AppointmentGroupsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Create and return a new appointment group. If new_appointments are specified, the response will return a new_appointments array (same format as appointments array, see \"List appointment groups\" action)
     * @summary Create an appointment group
     * @param appointmentGroupContextCodes Array of context codes (courses, e.g. course_1) this group should be linked to (1 or more). Users in the course(s) with appropriate permissions will be able to sign up for this appointment group.
     * @param appointmentGroupTitle Short title for the appointment group.
     * @param appointmentGroupSubContextCodes Array of sub context codes (course sections or a single group category) this group should be linked to. Used to limit the appointment group to particular sections. If a group category is specified, students will sign up in groups and the participant_type will be \\\&quot;Group\\\&quot; instead of \\\&quot;User\\\&quot;.
     * @param appointmentGroupDescription Longer text description of the appointment group.
     * @param appointmentGroupLocationName Location name of the appointment group.
     * @param appointmentGroupLocationAddress Location address.
     * @param appointmentGroupPublish Indicates whether this appointment group should be published (i.e. made available for signup). Once published, an appointment group cannot be unpublished. Defaults to false.
     * @param appointmentGroupParticipantsPerAppointment Maximum number of participants that may register for each time slot. Defaults to null (no limit).
     * @param appointmentGroupMinAppointmentsPerParticipant Minimum number of time slots a user must register for. If not set, users do not need to sign up for any time slots.
     * @param appointmentGroupMaxAppointmentsPerParticipant Maximum number of time slots a user may register for.
     * @param appointmentGroupNewAppointmentsX Nested array of start time/end time pairs indicating time slots for this appointment group. Refer to the example request.
     * @param appointmentGroupParticipantVisibility \\\&quot;private\\\&quot;:: participants cannot see who has signed up for a particular             time slot \\\&quot;protected\\\&quot;:: participants can see who has signed up.  Defaults to               \\\&quot;private\\\&quot;.
     * @param appointmentGroupAllowObserverSignup Whether observer users can sign-up for an appointment. Defaults to false.
     */
    public async createAppointmentGroup (appointmentGroupContextCodes: Array<string>, appointmentGroupTitle: string, appointmentGroupSubContextCodes?: Array<string>, appointmentGroupDescription?: string, appointmentGroupLocationName?: string, appointmentGroupLocationAddress?: string, appointmentGroupPublish?: boolean, appointmentGroupParticipantsPerAppointment?: number, appointmentGroupMinAppointmentsPerParticipant?: number, appointmentGroupMaxAppointmentsPerParticipant?: number, appointmentGroupNewAppointmentsX?: Array<string>, appointmentGroupParticipantVisibility?: string, appointmentGroupAllowObserverSignup?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/appointment_groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appointmentGroupContextCodes' is not null or undefined
        if (appointmentGroupContextCodes === null || appointmentGroupContextCodes === undefined) {
            throw new Error('Required parameter appointmentGroupContextCodes was null or undefined when calling createAppointmentGroup.');
        }

        // verify required parameter 'appointmentGroupTitle' is not null or undefined
        if (appointmentGroupTitle === null || appointmentGroupTitle === undefined) {
            throw new Error('Required parameter appointmentGroupTitle was null or undefined when calling createAppointmentGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (appointmentGroupContextCodes !== undefined) {
            localVarFormParams['appointment_group[context_codes]'] = ObjectSerializer.serialize(appointmentGroupContextCodes, "Array<string>");
        }

        if (appointmentGroupSubContextCodes !== undefined) {
            localVarFormParams['appointment_group[sub_context_codes]'] = ObjectSerializer.serialize(appointmentGroupSubContextCodes, "Array<string>");
        }

        if (appointmentGroupTitle !== undefined) {
            localVarFormParams['appointment_group[title]'] = ObjectSerializer.serialize(appointmentGroupTitle, "string");
        }

        if (appointmentGroupDescription !== undefined) {
            localVarFormParams['appointment_group[description]'] = ObjectSerializer.serialize(appointmentGroupDescription, "string");
        }

        if (appointmentGroupLocationName !== undefined) {
            localVarFormParams['appointment_group[location_name]'] = ObjectSerializer.serialize(appointmentGroupLocationName, "string");
        }

        if (appointmentGroupLocationAddress !== undefined) {
            localVarFormParams['appointment_group[location_address]'] = ObjectSerializer.serialize(appointmentGroupLocationAddress, "string");
        }

        if (appointmentGroupPublish !== undefined) {
            localVarFormParams['appointment_group[publish]'] = ObjectSerializer.serialize(appointmentGroupPublish, "boolean");
        }

        if (appointmentGroupParticipantsPerAppointment !== undefined) {
            localVarFormParams['appointment_group[participants_per_appointment]'] = ObjectSerializer.serialize(appointmentGroupParticipantsPerAppointment, "number");
        }

        if (appointmentGroupMinAppointmentsPerParticipant !== undefined) {
            localVarFormParams['appointment_group[min_appointments_per_participant]'] = ObjectSerializer.serialize(appointmentGroupMinAppointmentsPerParticipant, "number");
        }

        if (appointmentGroupMaxAppointmentsPerParticipant !== undefined) {
            localVarFormParams['appointment_group[max_appointments_per_participant]'] = ObjectSerializer.serialize(appointmentGroupMaxAppointmentsPerParticipant, "number");
        }

        if (appointmentGroupNewAppointmentsX !== undefined) {
            localVarFormParams['appointment_group[new_appointments][X]'] = ObjectSerializer.serialize(appointmentGroupNewAppointmentsX, "Array<string>");
        }

        if (appointmentGroupParticipantVisibility !== undefined) {
            localVarFormParams['appointment_group[participant_visibility]'] = ObjectSerializer.serialize(appointmentGroupParticipantVisibility, "string");
        }

        if (appointmentGroupAllowObserverSignup !== undefined) {
            localVarFormParams['appointment_group[allow_observer_signup]'] = ObjectSerializer.serialize(appointmentGroupAllowObserverSignup, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Delete an appointment group (and associated time slots and reservations) and return the deleted group
     * @summary Delete an appointment group
     * @param id ID
     * @param cancelReason Reason for deleting/canceling the appointment group.
     */
    public async deleteAppointmentGroup (id: string, cancelReason?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/appointment_groups/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteAppointmentGroup.');
        }

        if (cancelReason !== undefined) {
            localVarQueryParameters['cancel_reason'] = ObjectSerializer.serialize(cancelReason, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Return the next appointment available to sign up for. The appointment is returned in a one-element array. If no future appointments are available, an empty array is returned.
     * @summary Get next appointment
     * @param appointmentGroupIds List of ids of appointment groups to search.
     */
    public async getNextAppointment (appointmentGroupIds?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<CalendarEvent>;  }> {
        const localVarPath = this.basePath + '/v1/appointment_groups/next_appointment';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (appointmentGroupIds !== undefined) {
            localVarQueryParameters['appointment_group_ids'] = ObjectSerializer.serialize(appointmentGroupIds, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<CalendarEvent>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<CalendarEvent>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns information for a single appointment group
     * @summary Get a single appointment group
     * @param id ID
     * @param include Array of additional information to include. See include[] argument of \&quot;List appointment groups\&quot; action.  \&quot;child_events\&quot;:: reservations of time slots time slots \&quot;appointments\&quot;:: will always be returned \&quot;all_context_codes\&quot;:: all context codes associated with this appointment group
     */
    public async getSingleAppointmentGroup (id: string, include?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/appointment_groups/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSingleAppointmentGroup.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve the paginated list of appointment groups that can be reserved or managed by the current user.
     * @summary List appointment groups
     * @param scope Defaults to \&quot;reservable\&quot;
     * @param contextCodes Array of context codes used to limit returned results.
     * @param includePastAppointments Defaults to false. If true, includes past appointment groups
     * @param include Array of additional information to include.  \&quot;appointments\&quot;:: calendar event time slots for this appointment group \&quot;child_events\&quot;:: reservations of those time slots \&quot;participant_count\&quot;:: number of reservations \&quot;reserved_times\&quot;:: the event id, start time and end time of reservations                    the current user has made) \&quot;all_context_codes\&quot;:: all context codes associated with this appointment group
     */
    public async listAppointmentGroups (scope?: 'reservable' | 'manageable', contextCodes?: Array<string>, includePastAppointments?: boolean, include?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/appointment_groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        if (scope !== undefined) {
            localVarQueryParameters['scope'] = ObjectSerializer.serialize(scope, "'reservable' | 'manageable'");
        }

        if (contextCodes !== undefined) {
            localVarQueryParameters['context_codes'] = ObjectSerializer.serialize(contextCodes, "Array<string>");
        }

        if (includePastAppointments !== undefined) {
            localVarQueryParameters['include_past_appointments'] = ObjectSerializer.serialize(includePastAppointments, "boolean");
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of student groups that are (or may be) participating in this appointment group. Refer to the Groups API for the response fields. Returns no results for appointment groups with the \"User\" participant_type.
     * @summary List student group participants
     * @param id ID
     * @param registrationStatus Limits results to the a given participation status, defaults to \&quot;all\&quot;
     */
    public async listStudentGroupParticipants (id: string, registrationStatus?: 'all' | 'registered' | 'registered', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/appointment_groups/{id}/groups'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listStudentGroupParticipants.');
        }

        if (registrationStatus !== undefined) {
            localVarQueryParameters['registration_status'] = ObjectSerializer.serialize(registrationStatus, "'all' | 'registered' | 'registered'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * A paginated list of users that are (or may be) participating in this appointment group.  Refer to the Users API for the response fields. Returns no results for appointment groups with the \"Group\" participant_type.
     * @summary List user participants
     * @param id ID
     * @param registrationStatus Limits results to the a given participation status, defaults to \&quot;all\&quot;
     */
    public async listUserParticipants (id: string, registrationStatus?: 'all' | 'registered' | 'registered', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/appointment_groups/{id}/users'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listUserParticipants.');
        }

        if (registrationStatus !== undefined) {
            localVarQueryParameters['registration_status'] = ObjectSerializer.serialize(registrationStatus, "'all' | 'registered' | 'registered'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update and return an appointment group. If new_appointments are specified, the response will return a new_appointments array (same format as appointments array, see \"List appointment groups\" action).
     * @summary Update an appointment group
     * @param id ID
     * @param appointmentGroupContextCodes Array of context codes (courses, e.g. course_1) this group should be linked to (1 or more). Users in the course(s) with appropriate permissions will be able to sign up for this appointment group.
     * @param appointmentGroupSubContextCodes Array of sub context codes (course sections or a single group category) this group should be linked to. Used to limit the appointment group to particular sections. If a group category is specified, students will sign up in groups and the participant_type will be \\\&quot;Group\\\&quot; instead of \\\&quot;User\\\&quot;.
     * @param appointmentGroupTitle Short title for the appointment group.
     * @param appointmentGroupDescription Longer text description of the appointment group.
     * @param appointmentGroupLocationName Location name of the appointment group.
     * @param appointmentGroupLocationAddress Location address.
     * @param appointmentGroupPublish Indicates whether this appointment group should be published (i.e. made available for signup). Once published, an appointment group cannot be unpublished. Defaults to false.
     * @param appointmentGroupParticipantsPerAppointment Maximum number of participants that may register for each time slot. Defaults to null (no limit).
     * @param appointmentGroupMinAppointmentsPerParticipant Minimum number of time slots a user must register for. If not set, users do not need to sign up for any time slots.
     * @param appointmentGroupMaxAppointmentsPerParticipant Maximum number of time slots a user may register for.
     * @param appointmentGroupNewAppointmentsX Nested array of start time/end time pairs indicating time slots for this appointment group. Refer to the example request.
     * @param appointmentGroupParticipantVisibility \\\&quot;private\\\&quot;:: participants cannot see who has signed up for a particular             time slot \\\&quot;protected\\\&quot;:: participants can see who has signed up. Defaults to \\\&quot;private\\\&quot;.
     * @param appointmentGroupAllowObserverSignup Whether observer users can sign-up for an appointment.
     */
    public async updateAppointmentGroup (id: string, appointmentGroupContextCodes: Array<string>, appointmentGroupSubContextCodes?: Array<string>, appointmentGroupTitle?: string, appointmentGroupDescription?: string, appointmentGroupLocationName?: string, appointmentGroupLocationAddress?: string, appointmentGroupPublish?: boolean, appointmentGroupParticipantsPerAppointment?: number, appointmentGroupMinAppointmentsPerParticipant?: number, appointmentGroupMaxAppointmentsPerParticipant?: number, appointmentGroupNewAppointmentsX?: Array<string>, appointmentGroupParticipantVisibility?: string, appointmentGroupAllowObserverSignup?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/appointment_groups/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateAppointmentGroup.');
        }

        // verify required parameter 'appointmentGroupContextCodes' is not null or undefined
        if (appointmentGroupContextCodes === null || appointmentGroupContextCodes === undefined) {
            throw new Error('Required parameter appointmentGroupContextCodes was null or undefined when calling updateAppointmentGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (appointmentGroupContextCodes !== undefined) {
            localVarFormParams['appointment_group[context_codes]'] = ObjectSerializer.serialize(appointmentGroupContextCodes, "Array<string>");
        }

        if (appointmentGroupSubContextCodes !== undefined) {
            localVarFormParams['appointment_group[sub_context_codes]'] = ObjectSerializer.serialize(appointmentGroupSubContextCodes, "Array<string>");
        }

        if (appointmentGroupTitle !== undefined) {
            localVarFormParams['appointment_group[title]'] = ObjectSerializer.serialize(appointmentGroupTitle, "string");
        }

        if (appointmentGroupDescription !== undefined) {
            localVarFormParams['appointment_group[description]'] = ObjectSerializer.serialize(appointmentGroupDescription, "string");
        }

        if (appointmentGroupLocationName !== undefined) {
            localVarFormParams['appointment_group[location_name]'] = ObjectSerializer.serialize(appointmentGroupLocationName, "string");
        }

        if (appointmentGroupLocationAddress !== undefined) {
            localVarFormParams['appointment_group[location_address]'] = ObjectSerializer.serialize(appointmentGroupLocationAddress, "string");
        }

        if (appointmentGroupPublish !== undefined) {
            localVarFormParams['appointment_group[publish]'] = ObjectSerializer.serialize(appointmentGroupPublish, "boolean");
        }

        if (appointmentGroupParticipantsPerAppointment !== undefined) {
            localVarFormParams['appointment_group[participants_per_appointment]'] = ObjectSerializer.serialize(appointmentGroupParticipantsPerAppointment, "number");
        }

        if (appointmentGroupMinAppointmentsPerParticipant !== undefined) {
            localVarFormParams['appointment_group[min_appointments_per_participant]'] = ObjectSerializer.serialize(appointmentGroupMinAppointmentsPerParticipant, "number");
        }

        if (appointmentGroupMaxAppointmentsPerParticipant !== undefined) {
            localVarFormParams['appointment_group[max_appointments_per_participant]'] = ObjectSerializer.serialize(appointmentGroupMaxAppointmentsPerParticipant, "number");
        }

        if (appointmentGroupNewAppointmentsX !== undefined) {
            localVarFormParams['appointment_group[new_appointments][X]'] = ObjectSerializer.serialize(appointmentGroupNewAppointmentsX, "Array<string>");
        }

        if (appointmentGroupParticipantVisibility !== undefined) {
            localVarFormParams['appointment_group[participant_visibility]'] = ObjectSerializer.serialize(appointmentGroupParticipantVisibility, "string");
        }

        if (appointmentGroupAllowObserverSignup !== undefined) {
            localVarFormParams['appointment_group[allow_observer_signup]'] = ObjectSerializer.serialize(appointmentGroupAllowObserverSignup, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
