/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Enrollment } from '../model/enrollment';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum EnrollmentsApiApiKeys {
}

export class EnrollmentsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: EnrollmentsApiApiKeys, value: string) {
        (this.authentications as any)[EnrollmentsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * accepts a pending course invitation for the current user
     * @summary Accept Course Invitation
     * @param courseId ID
     * @param id ID
     */
    public async acceptCourseInvitation (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/enrollments/{id}/accept'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling acceptCourseInvitation.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling acceptCourseInvitation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Add last attended date to student enrollment in course
     * @summary Add last attended date
     * @param courseId ID
     * @param userId ID
     * @param date The last attended date of a student enrollment in a course.
     */
    public async addLastAttendedDate (courseId: string, userId: string, date?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Enrollment;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/users/{user_id}/last_attended'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling addLastAttendedDate.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling addLastAttendedDate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (date !== undefined) {
            localVarFormParams['date'] = ObjectSerializer.serialize(date, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Enrollment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Enrollment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Conclude, deactivate, or delete an enrollment. If the +task+ argument isn\'t given, the enrollment will be concluded.
     * @summary Conclude, deactivate, or delete an enrollment
     * @param courseId ID
     * @param id ID
     * @param task The action to take on the enrollment. When inactive, a user will still appear in the course roster to admins, but be unable to participate. (\&quot;inactivate\&quot; and \&quot;deactivate\&quot; are equivalent tasks)
     */
    public async concludeDeactivateOrDeleteEnrollment (courseId: string, id: string, task?: 'conclude' | 'delete' | 'inactivate' | 'deactivate', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Enrollment;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/enrollments/{id}'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling concludeDeactivateOrDeleteEnrollment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling concludeDeactivateOrDeleteEnrollment.');
        }

        if (task !== undefined) {
            localVarQueryParameters['task'] = ObjectSerializer.serialize(task, "'conclude' | 'delete' | 'inactivate' | 'deactivate'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Enrollment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Enrollment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a new user enrollment for a course or section.
     * @summary Enroll a user
     * @param courseId ID
     * @param enrollmentUserId The ID of the user to be enrolled in the course.
     * @param enrollmentType Enroll the user as a student, teacher, TA, observer, or designer. If no value is given, the type will be inferred by enrollment[role] if supplied, otherwise \\\&#39;StudentEnrollment\\\&#39; will be used.
     * @param enrollmentStartAt The start time of the enrollment, in ISO8601 format. e.g. 2012-04-18T23:08:51Z
     * @param enrollmentEndAt The end time of the enrollment, in ISO8601 format. e.g. 2012-04-18T23:08:51Z
     * @param enrollmentRole Assigns a custom course-level role to the user.
     * @param enrollmentRoleId Assigns a custom course-level role to the user.
     * @param enrollmentEnrollmentState If set to \\\&#39;active,\\\&#39; student will be immediately enrolled in the course. Otherwise they will be required to accept a course invitation. Default is \\\&#39;invited.\\\&#39;.  If set to \\\&#39;inactive\\\&#39;, student will be listed in the course roster for teachers, but will not be able to participate in the course until their enrollment is activated.
     * @param enrollmentCourseSectionId The ID of the course section to enroll the student in. If the section-specific URL is used, this argument is redundant and will be ignored.
     * @param enrollmentLimitPrivilegesToCourseSection If set, the enrollment will only allow the user to see and interact with users enrolled in the section given by course_section_id. * For teachers and TAs, this includes grading privileges. * Section-limited students will not see any users (including teachers   and TAs) not enrolled in their sections. * Users may have other enrollments that grant privileges to   multiple sections in the same course.
     * @param enrollmentNotify If true, a notification will be sent to the enrolled user. Notifications are not sent by default.
     * @param enrollmentSelfEnrollmentCode If the current user is not allowed to manage enrollments in this course, but the course allows self-enrollment, the user can self- enroll as a student in the default section by passing in a valid code. When self-enrolling, the user_id must be \\\&#39;self\\\&#39;. The enrollment_state will be set to \\\&#39;active\\\&#39; and all other arguments will be ignored.
     * @param enrollmentSelfEnrolled If true, marks the enrollment as a self-enrollment, which gives students the ability to drop the course if desired. Defaults to false.
     * @param enrollmentAssociatedUserId For an observer enrollment, the ID of a student to observe. This is a one-off operation; to automatically observe all a student\\\&#39;s enrollments (for example, as a parent), please use the {api:UserObserveesController#create User Observees API}.
     * @param enrollmentSisUserId Required if the user is being enrolled from another trusted account. The unique identifier for the user (sis_user_id) must also be accompanied by the root_account parameter. The user_id will be ignored.
     * @param enrollmentIntegrationId Required if the user is being enrolled from another trusted account. The unique identifier for the user (integration_id) must also be accompanied by the root_account parameter. The user_id will be ignored.
     * @param rootAccount The domain of the account to search for the user. Will be a no-op unless the sis_user_id or integration_id parameter is also included.
     */
    public async enrollUserCourses (courseId: string, enrollmentUserId: string, enrollmentType: string, enrollmentStartAt?: Date, enrollmentEndAt?: Date, enrollmentRole?: any, enrollmentRoleId?: number, enrollmentEnrollmentState?: string, enrollmentCourseSectionId?: number, enrollmentLimitPrivilegesToCourseSection?: boolean, enrollmentNotify?: boolean, enrollmentSelfEnrollmentCode?: string, enrollmentSelfEnrolled?: boolean, enrollmentAssociatedUserId?: number, enrollmentSisUserId?: string, enrollmentIntegrationId?: string, rootAccount?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Enrollment;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/enrollments'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling enrollUserCourses.');
        }

        // verify required parameter 'enrollmentUserId' is not null or undefined
        if (enrollmentUserId === null || enrollmentUserId === undefined) {
            throw new Error('Required parameter enrollmentUserId was null or undefined when calling enrollUserCourses.');
        }

        // verify required parameter 'enrollmentType' is not null or undefined
        if (enrollmentType === null || enrollmentType === undefined) {
            throw new Error('Required parameter enrollmentType was null or undefined when calling enrollUserCourses.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (enrollmentStartAt !== undefined) {
            localVarFormParams['enrollment[start_at]'] = ObjectSerializer.serialize(enrollmentStartAt, "Date");
        }

        if (enrollmentEndAt !== undefined) {
            localVarFormParams['enrollment[end_at]'] = ObjectSerializer.serialize(enrollmentEndAt, "Date");
        }

        if (enrollmentUserId !== undefined) {
            localVarFormParams['enrollment[user_id]'] = ObjectSerializer.serialize(enrollmentUserId, "string");
        }

        if (enrollmentType !== undefined) {
            localVarFormParams['enrollment[type]'] = ObjectSerializer.serialize(enrollmentType, "string");
        }

        if (enrollmentRole !== undefined) {
            localVarFormParams['enrollment[role]'] = ObjectSerializer.serialize(enrollmentRole, "any");
        }

        if (enrollmentRoleId !== undefined) {
            localVarFormParams['enrollment[role_id]'] = ObjectSerializer.serialize(enrollmentRoleId, "number");
        }

        if (enrollmentEnrollmentState !== undefined) {
            localVarFormParams['enrollment[enrollment_state]'] = ObjectSerializer.serialize(enrollmentEnrollmentState, "string");
        }

        if (enrollmentCourseSectionId !== undefined) {
            localVarFormParams['enrollment[course_section_id]'] = ObjectSerializer.serialize(enrollmentCourseSectionId, "number");
        }

        if (enrollmentLimitPrivilegesToCourseSection !== undefined) {
            localVarFormParams['enrollment[limit_privileges_to_course_section]'] = ObjectSerializer.serialize(enrollmentLimitPrivilegesToCourseSection, "boolean");
        }

        if (enrollmentNotify !== undefined) {
            localVarFormParams['enrollment[notify]'] = ObjectSerializer.serialize(enrollmentNotify, "boolean");
        }

        if (enrollmentSelfEnrollmentCode !== undefined) {
            localVarFormParams['enrollment[self_enrollment_code]'] = ObjectSerializer.serialize(enrollmentSelfEnrollmentCode, "string");
        }

        if (enrollmentSelfEnrolled !== undefined) {
            localVarFormParams['enrollment[self_enrolled]'] = ObjectSerializer.serialize(enrollmentSelfEnrolled, "boolean");
        }

        if (enrollmentAssociatedUserId !== undefined) {
            localVarFormParams['enrollment[associated_user_id]'] = ObjectSerializer.serialize(enrollmentAssociatedUserId, "number");
        }

        if (enrollmentSisUserId !== undefined) {
            localVarFormParams['enrollment[sis_user_id]'] = ObjectSerializer.serialize(enrollmentSisUserId, "string");
        }

        if (enrollmentIntegrationId !== undefined) {
            localVarFormParams['enrollment[integration_id]'] = ObjectSerializer.serialize(enrollmentIntegrationId, "string");
        }

        if (rootAccount !== undefined) {
            localVarFormParams['root_account'] = ObjectSerializer.serialize(rootAccount, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Enrollment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Enrollment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create a new user enrollment for a course or section.
     * @summary Enroll a user
     * @param sectionId ID
     * @param enrollmentUserId The ID of the user to be enrolled in the course.
     * @param enrollmentType Enroll the user as a student, teacher, TA, observer, or designer. If no value is given, the type will be inferred by enrollment[role] if supplied, otherwise \\\&#39;StudentEnrollment\\\&#39; will be used.
     * @param enrollmentStartAt The start time of the enrollment, in ISO8601 format. e.g. 2012-04-18T23:08:51Z
     * @param enrollmentEndAt The end time of the enrollment, in ISO8601 format. e.g. 2012-04-18T23:08:51Z
     * @param enrollmentRole Assigns a custom course-level role to the user.
     * @param enrollmentRoleId Assigns a custom course-level role to the user.
     * @param enrollmentEnrollmentState If set to \\\&#39;active,\\\&#39; student will be immediately enrolled in the course. Otherwise they will be required to accept a course invitation. Default is \\\&#39;invited.\\\&#39;.  If set to \\\&#39;inactive\\\&#39;, student will be listed in the course roster for teachers, but will not be able to participate in the course until their enrollment is activated.
     * @param enrollmentCourseSectionId The ID of the course section to enroll the student in. If the section-specific URL is used, this argument is redundant and will be ignored.
     * @param enrollmentLimitPrivilegesToCourseSection If set, the enrollment will only allow the user to see and interact with users enrolled in the section given by course_section_id. * For teachers and TAs, this includes grading privileges. * Section-limited students will not see any users (including teachers   and TAs) not enrolled in their sections. * Users may have other enrollments that grant privileges to   multiple sections in the same course.
     * @param enrollmentNotify If true, a notification will be sent to the enrolled user. Notifications are not sent by default.
     * @param enrollmentSelfEnrollmentCode If the current user is not allowed to manage enrollments in this course, but the course allows self-enrollment, the user can self- enroll as a student in the default section by passing in a valid code. When self-enrolling, the user_id must be \\\&#39;self\\\&#39;. The enrollment_state will be set to \\\&#39;active\\\&#39; and all other arguments will be ignored.
     * @param enrollmentSelfEnrolled If true, marks the enrollment as a self-enrollment, which gives students the ability to drop the course if desired. Defaults to false.
     * @param enrollmentAssociatedUserId For an observer enrollment, the ID of a student to observe. This is a one-off operation; to automatically observe all a student\\\&#39;s enrollments (for example, as a parent), please use the {api:UserObserveesController#create User Observees API}.
     * @param enrollmentSisUserId Required if the user is being enrolled from another trusted account. The unique identifier for the user (sis_user_id) must also be accompanied by the root_account parameter. The user_id will be ignored.
     * @param enrollmentIntegrationId Required if the user is being enrolled from another trusted account. The unique identifier for the user (integration_id) must also be accompanied by the root_account parameter. The user_id will be ignored.
     * @param rootAccount The domain of the account to search for the user. Will be a no-op unless the sis_user_id or integration_id parameter is also included.
     */
    public async enrollUserSections (sectionId: string, enrollmentUserId: string, enrollmentType: string, enrollmentStartAt?: Date, enrollmentEndAt?: Date, enrollmentRole?: any, enrollmentRoleId?: number, enrollmentEnrollmentState?: string, enrollmentCourseSectionId?: number, enrollmentLimitPrivilegesToCourseSection?: boolean, enrollmentNotify?: boolean, enrollmentSelfEnrollmentCode?: string, enrollmentSelfEnrolled?: boolean, enrollmentAssociatedUserId?: number, enrollmentSisUserId?: string, enrollmentIntegrationId?: string, rootAccount?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Enrollment;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/enrollments'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling enrollUserSections.');
        }

        // verify required parameter 'enrollmentUserId' is not null or undefined
        if (enrollmentUserId === null || enrollmentUserId === undefined) {
            throw new Error('Required parameter enrollmentUserId was null or undefined when calling enrollUserSections.');
        }

        // verify required parameter 'enrollmentType' is not null or undefined
        if (enrollmentType === null || enrollmentType === undefined) {
            throw new Error('Required parameter enrollmentType was null or undefined when calling enrollUserSections.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (enrollmentStartAt !== undefined) {
            localVarFormParams['enrollment[start_at]'] = ObjectSerializer.serialize(enrollmentStartAt, "Date");
        }

        if (enrollmentEndAt !== undefined) {
            localVarFormParams['enrollment[end_at]'] = ObjectSerializer.serialize(enrollmentEndAt, "Date");
        }

        if (enrollmentUserId !== undefined) {
            localVarFormParams['enrollment[user_id]'] = ObjectSerializer.serialize(enrollmentUserId, "string");
        }

        if (enrollmentType !== undefined) {
            localVarFormParams['enrollment[type]'] = ObjectSerializer.serialize(enrollmentType, "string");
        }

        if (enrollmentRole !== undefined) {
            localVarFormParams['enrollment[role]'] = ObjectSerializer.serialize(enrollmentRole, "any");
        }

        if (enrollmentRoleId !== undefined) {
            localVarFormParams['enrollment[role_id]'] = ObjectSerializer.serialize(enrollmentRoleId, "number");
        }

        if (enrollmentEnrollmentState !== undefined) {
            localVarFormParams['enrollment[enrollment_state]'] = ObjectSerializer.serialize(enrollmentEnrollmentState, "string");
        }

        if (enrollmentCourseSectionId !== undefined) {
            localVarFormParams['enrollment[course_section_id]'] = ObjectSerializer.serialize(enrollmentCourseSectionId, "number");
        }

        if (enrollmentLimitPrivilegesToCourseSection !== undefined) {
            localVarFormParams['enrollment[limit_privileges_to_course_section]'] = ObjectSerializer.serialize(enrollmentLimitPrivilegesToCourseSection, "boolean");
        }

        if (enrollmentNotify !== undefined) {
            localVarFormParams['enrollment[notify]'] = ObjectSerializer.serialize(enrollmentNotify, "boolean");
        }

        if (enrollmentSelfEnrollmentCode !== undefined) {
            localVarFormParams['enrollment[self_enrollment_code]'] = ObjectSerializer.serialize(enrollmentSelfEnrollmentCode, "string");
        }

        if (enrollmentSelfEnrolled !== undefined) {
            localVarFormParams['enrollment[self_enrolled]'] = ObjectSerializer.serialize(enrollmentSelfEnrolled, "boolean");
        }

        if (enrollmentAssociatedUserId !== undefined) {
            localVarFormParams['enrollment[associated_user_id]'] = ObjectSerializer.serialize(enrollmentAssociatedUserId, "number");
        }

        if (enrollmentSisUserId !== undefined) {
            localVarFormParams['enrollment[sis_user_id]'] = ObjectSerializer.serialize(enrollmentSisUserId, "string");
        }

        if (enrollmentIntegrationId !== undefined) {
            localVarFormParams['enrollment[integration_id]'] = ObjectSerializer.serialize(enrollmentIntegrationId, "string");
        }

        if (rootAccount !== undefined) {
            localVarFormParams['root_account'] = ObjectSerializer.serialize(rootAccount, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Enrollment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Enrollment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Get an Enrollment object by Enrollment ID
     * @summary Enrollment by ID
     * @param accountId ID
     * @param id The ID of the enrollment object
     */
    public async enrollmentById (accountId: string, id: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Enrollment;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/enrollments/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling enrollmentById.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling enrollmentById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Enrollment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Enrollment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Depending on the URL given, return a paginated list of either (1) all of the enrollments in a course, (2) all of the enrollments in a section or (3) all of a user\'s enrollments. This includes student, teacher, TA, and observer enrollments.  If a user has multiple enrollments in a context (e.g. as a teacher and a student or in multiple course sections), each enrollment will be listed separately.  note: Currently, only a root level admin user can return other users\' enrollments. A user can, however, return his/her own enrollments.  Enrollments scoped to a course context will include inactive states by default if the caller has account admin authorization and the state[] parameter is omitted.
     * @summary List enrollments
     * @param courseId ID
     * @param type A list of enrollment types to return. Accepted values are \&#39;StudentEnrollment\&#39;, \&#39;TeacherEnrollment\&#39;, \&#39;TaEnrollment\&#39;, \&#39;DesignerEnrollment\&#39;, and \&#39;ObserverEnrollment.\&#39; If omitted, all enrollment types are returned. This argument is ignored if &#x60;role&#x60; is given.
     * @param role A list of enrollment roles to return. Accepted values include course-level roles created by the {api:RoleOverridesController#add_role Add Role API} as well as the base enrollment types accepted by the &#x60;type&#x60; argument above.
     * @param state Filter by enrollment state. If omitted, \&#39;active\&#39; and \&#39;invited\&#39; enrollments are returned. The following synthetic states are supported only when querying a user\&#39;s enrollments (either via user_id argument or via user enrollments endpoint): +current_and_invited+, +current_and_future+, +current_future_and_restricted+, +current_and_concluded+
     * @param include Array of additional information to include on the enrollment or user records. \&quot;avatar_url\&quot; and \&quot;group_ids\&quot; will be returned on the user record. If \&quot;current_points\&quot; is specified, the fields \&quot;current_points\&quot; and (if the caller has permissions to manage grades) \&quot;unposted_current_points\&quot; will be included in the \&quot;grades\&quot; hash for student enrollments.
     * @param userId Filter by user_id (only valid for course or section enrollment queries). If set to the current user\&#39;s id, this is a way to determine if the user has any enrollments in the course or section, independent of whether the user has permission to view other people on the roster.
     * @param gradingPeriodId Return grades for the given grading_period.  If this parameter is not specified, the returned grades will be for the whole course.
     * @param enrollmentTermId Returns only enrollments for the specified enrollment term. This parameter only applies to the user enrollments path. May pass the ID from the enrollment terms api or the SIS id prepended with \&#39;sis_term_id:\&#39;.
     * @param sisAccountId Returns only enrollments for the specified SIS account ID(s). Does not look into sub_accounts. May pass in array or string.
     * @param sisCourseId Returns only enrollments matching the specified SIS course ID(s). May pass in array or string.
     * @param sisSectionId Returns only section enrollments matching the specified SIS section ID(s). May pass in array or string.
     * @param sisUserId Returns only enrollments for the specified SIS user ID(s). May pass in array or string.
     * @param createdForSisId If sis_user_id is present and created_for_sis_id is true, Returns only enrollments for the specified SIS ID(s). If a user has two sis_id\&#39;s, one enrollment may be created using one of the two ids. This would limit the enrollments returned from the endpoint to enrollments that were created from a sis_import with that sis_user_id
     */
    public async listEnrollmentsCourses (courseId: string, type?: Array<string>, role?: Array<string>, state?: Array<string>, include?: Array<string>, userId?: string, gradingPeriodId?: number, enrollmentTermId?: number, sisAccountId?: Array<string>, sisCourseId?: Array<string>, sisSectionId?: Array<string>, sisUserId?: Array<string>, createdForSisId?: Array<boolean>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Enrollment>;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/enrollments'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling listEnrollmentsCourses.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "Array<string>");
        }

        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "Array<string>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<string>");
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (userId !== undefined) {
            localVarQueryParameters['user_id'] = ObjectSerializer.serialize(userId, "string");
        }

        if (gradingPeriodId !== undefined) {
            localVarQueryParameters['grading_period_id'] = ObjectSerializer.serialize(gradingPeriodId, "number");
        }

        if (enrollmentTermId !== undefined) {
            localVarQueryParameters['enrollment_term_id'] = ObjectSerializer.serialize(enrollmentTermId, "number");
        }

        if (sisAccountId !== undefined) {
            localVarQueryParameters['sis_account_id'] = ObjectSerializer.serialize(sisAccountId, "Array<string>");
        }

        if (sisCourseId !== undefined) {
            localVarQueryParameters['sis_course_id'] = ObjectSerializer.serialize(sisCourseId, "Array<string>");
        }

        if (sisSectionId !== undefined) {
            localVarQueryParameters['sis_section_id'] = ObjectSerializer.serialize(sisSectionId, "Array<string>");
        }

        if (sisUserId !== undefined) {
            localVarQueryParameters['sis_user_id'] = ObjectSerializer.serialize(sisUserId, "Array<string>");
        }

        if (createdForSisId !== undefined) {
            localVarQueryParameters['created_for_sis_id'] = ObjectSerializer.serialize(createdForSisId, "Array<boolean>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Enrollment>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Enrollment>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Depending on the URL given, return a paginated list of either (1) all of the enrollments in a course, (2) all of the enrollments in a section or (3) all of a user\'s enrollments. This includes student, teacher, TA, and observer enrollments.  If a user has multiple enrollments in a context (e.g. as a teacher and a student or in multiple course sections), each enrollment will be listed separately.  note: Currently, only a root level admin user can return other users\' enrollments. A user can, however, return his/her own enrollments.  Enrollments scoped to a course context will include inactive states by default if the caller has account admin authorization and the state[] parameter is omitted.
     * @summary List enrollments
     * @param sectionId ID
     * @param type A list of enrollment types to return. Accepted values are \&#39;StudentEnrollment\&#39;, \&#39;TeacherEnrollment\&#39;, \&#39;TaEnrollment\&#39;, \&#39;DesignerEnrollment\&#39;, and \&#39;ObserverEnrollment.\&#39; If omitted, all enrollment types are returned. This argument is ignored if &#x60;role&#x60; is given.
     * @param role A list of enrollment roles to return. Accepted values include course-level roles created by the {api:RoleOverridesController#add_role Add Role API} as well as the base enrollment types accepted by the &#x60;type&#x60; argument above.
     * @param state Filter by enrollment state. If omitted, \&#39;active\&#39; and \&#39;invited\&#39; enrollments are returned. The following synthetic states are supported only when querying a user\&#39;s enrollments (either via user_id argument or via user enrollments endpoint): +current_and_invited+, +current_and_future+, +current_future_and_restricted+, +current_and_concluded+
     * @param include Array of additional information to include on the enrollment or user records. \&quot;avatar_url\&quot; and \&quot;group_ids\&quot; will be returned on the user record. If \&quot;current_points\&quot; is specified, the fields \&quot;current_points\&quot; and (if the caller has permissions to manage grades) \&quot;unposted_current_points\&quot; will be included in the \&quot;grades\&quot; hash for student enrollments.
     * @param userId Filter by user_id (only valid for course or section enrollment queries). If set to the current user\&#39;s id, this is a way to determine if the user has any enrollments in the course or section, independent of whether the user has permission to view other people on the roster.
     * @param gradingPeriodId Return grades for the given grading_period.  If this parameter is not specified, the returned grades will be for the whole course.
     * @param enrollmentTermId Returns only enrollments for the specified enrollment term. This parameter only applies to the user enrollments path. May pass the ID from the enrollment terms api or the SIS id prepended with \&#39;sis_term_id:\&#39;.
     * @param sisAccountId Returns only enrollments for the specified SIS account ID(s). Does not look into sub_accounts. May pass in array or string.
     * @param sisCourseId Returns only enrollments matching the specified SIS course ID(s). May pass in array or string.
     * @param sisSectionId Returns only section enrollments matching the specified SIS section ID(s). May pass in array or string.
     * @param sisUserId Returns only enrollments for the specified SIS user ID(s). May pass in array or string.
     * @param createdForSisId If sis_user_id is present and created_for_sis_id is true, Returns only enrollments for the specified SIS ID(s). If a user has two sis_id\&#39;s, one enrollment may be created using one of the two ids. This would limit the enrollments returned from the endpoint to enrollments that were created from a sis_import with that sis_user_id
     */
    public async listEnrollmentsSections (sectionId: string, type?: Array<string>, role?: Array<string>, state?: Array<string>, include?: Array<string>, userId?: string, gradingPeriodId?: number, enrollmentTermId?: number, sisAccountId?: Array<string>, sisCourseId?: Array<string>, sisSectionId?: Array<string>, sisUserId?: Array<string>, createdForSisId?: Array<boolean>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Enrollment>;  }> {
        const localVarPath = this.basePath + '/v1/sections/{section_id}/enrollments'
            .replace('{' + 'section_id' + '}', encodeURIComponent(String(sectionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'sectionId' is not null or undefined
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling listEnrollmentsSections.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "Array<string>");
        }

        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "Array<string>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<string>");
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (userId !== undefined) {
            localVarQueryParameters['user_id'] = ObjectSerializer.serialize(userId, "string");
        }

        if (gradingPeriodId !== undefined) {
            localVarQueryParameters['grading_period_id'] = ObjectSerializer.serialize(gradingPeriodId, "number");
        }

        if (enrollmentTermId !== undefined) {
            localVarQueryParameters['enrollment_term_id'] = ObjectSerializer.serialize(enrollmentTermId, "number");
        }

        if (sisAccountId !== undefined) {
            localVarQueryParameters['sis_account_id'] = ObjectSerializer.serialize(sisAccountId, "Array<string>");
        }

        if (sisCourseId !== undefined) {
            localVarQueryParameters['sis_course_id'] = ObjectSerializer.serialize(sisCourseId, "Array<string>");
        }

        if (sisSectionId !== undefined) {
            localVarQueryParameters['sis_section_id'] = ObjectSerializer.serialize(sisSectionId, "Array<string>");
        }

        if (sisUserId !== undefined) {
            localVarQueryParameters['sis_user_id'] = ObjectSerializer.serialize(sisUserId, "Array<string>");
        }

        if (createdForSisId !== undefined) {
            localVarQueryParameters['created_for_sis_id'] = ObjectSerializer.serialize(createdForSisId, "Array<boolean>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Enrollment>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Enrollment>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Depending on the URL given, return a paginated list of either (1) all of the enrollments in a course, (2) all of the enrollments in a section or (3) all of a user\'s enrollments. This includes student, teacher, TA, and observer enrollments.  If a user has multiple enrollments in a context (e.g. as a teacher and a student or in multiple course sections), each enrollment will be listed separately.  note: Currently, only a root level admin user can return other users\' enrollments. A user can, however, return his/her own enrollments.  Enrollments scoped to a course context will include inactive states by default if the caller has account admin authorization and the state[] parameter is omitted.
     * @summary List enrollments
     * @param userId Filter by user_id (only valid for course or section enrollment queries). If set to the current user\&#39;s id, this is a way to determine if the user has any enrollments in the course or section, independent of whether the user has permission to view other people on the roster.
     * @param type A list of enrollment types to return. Accepted values are \&#39;StudentEnrollment\&#39;, \&#39;TeacherEnrollment\&#39;, \&#39;TaEnrollment\&#39;, \&#39;DesignerEnrollment\&#39;, and \&#39;ObserverEnrollment.\&#39; If omitted, all enrollment types are returned. This argument is ignored if &#x60;role&#x60; is given.
     * @param role A list of enrollment roles to return. Accepted values include course-level roles created by the {api:RoleOverridesController#add_role Add Role API} as well as the base enrollment types accepted by the &#x60;type&#x60; argument above.
     * @param state Filter by enrollment state. If omitted, \&#39;active\&#39; and \&#39;invited\&#39; enrollments are returned. The following synthetic states are supported only when querying a user\&#39;s enrollments (either via user_id argument or via user enrollments endpoint): +current_and_invited+, +current_and_future+, +current_future_and_restricted+, +current_and_concluded+
     * @param include Array of additional information to include on the enrollment or user records. \&quot;avatar_url\&quot; and \&quot;group_ids\&quot; will be returned on the user record. If \&quot;current_points\&quot; is specified, the fields \&quot;current_points\&quot; and (if the caller has permissions to manage grades) \&quot;unposted_current_points\&quot; will be included in the \&quot;grades\&quot; hash for student enrollments.
     * @param gradingPeriodId Return grades for the given grading_period.  If this parameter is not specified, the returned grades will be for the whole course.
     * @param enrollmentTermId Returns only enrollments for the specified enrollment term. This parameter only applies to the user enrollments path. May pass the ID from the enrollment terms api or the SIS id prepended with \&#39;sis_term_id:\&#39;.
     * @param sisAccountId Returns only enrollments for the specified SIS account ID(s). Does not look into sub_accounts. May pass in array or string.
     * @param sisCourseId Returns only enrollments matching the specified SIS course ID(s). May pass in array or string.
     * @param sisSectionId Returns only section enrollments matching the specified SIS section ID(s). May pass in array or string.
     * @param sisUserId Returns only enrollments for the specified SIS user ID(s). May pass in array or string.
     * @param createdForSisId If sis_user_id is present and created_for_sis_id is true, Returns only enrollments for the specified SIS ID(s). If a user has two sis_id\&#39;s, one enrollment may be created using one of the two ids. This would limit the enrollments returned from the endpoint to enrollments that were created from a sis_import with that sis_user_id
     */
    public async listEnrollmentsUsers (userId: string, type?: Array<string>, role?: Array<string>, state?: Array<string>, include?: Array<string>, gradingPeriodId?: number, enrollmentTermId?: number, sisAccountId?: Array<string>, sisCourseId?: Array<string>, sisSectionId?: Array<string>, sisUserId?: Array<string>, createdForSisId?: Array<boolean>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<Enrollment>;  }> {
        const localVarPath = this.basePath + '/v1/users/{user_id}/enrollments'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling listEnrollmentsUsers.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "Array<string>");
        }

        if (role !== undefined) {
            localVarQueryParameters['role'] = ObjectSerializer.serialize(role, "Array<string>");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "Array<string>");
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "Array<string>");
        }

        if (gradingPeriodId !== undefined) {
            localVarQueryParameters['grading_period_id'] = ObjectSerializer.serialize(gradingPeriodId, "number");
        }

        if (enrollmentTermId !== undefined) {
            localVarQueryParameters['enrollment_term_id'] = ObjectSerializer.serialize(enrollmentTermId, "number");
        }

        if (sisAccountId !== undefined) {
            localVarQueryParameters['sis_account_id'] = ObjectSerializer.serialize(sisAccountId, "Array<string>");
        }

        if (sisCourseId !== undefined) {
            localVarQueryParameters['sis_course_id'] = ObjectSerializer.serialize(sisCourseId, "Array<string>");
        }

        if (sisSectionId !== undefined) {
            localVarQueryParameters['sis_section_id'] = ObjectSerializer.serialize(sisSectionId, "Array<string>");
        }

        if (sisUserId !== undefined) {
            localVarQueryParameters['sis_user_id'] = ObjectSerializer.serialize(sisUserId, "Array<string>");
        }

        if (createdForSisId !== undefined) {
            localVarQueryParameters['created_for_sis_id'] = ObjectSerializer.serialize(createdForSisId, "Array<boolean>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<Enrollment>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<Enrollment>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Activates an inactive enrollment
     * @summary Re-activate an enrollment
     * @param courseId ID
     * @param id ID
     */
    public async reActivateEnrollment (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Enrollment;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/enrollments/{id}/reactivate'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling reActivateEnrollment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling reActivateEnrollment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Enrollment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Enrollment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * rejects a pending course invitation for the current user
     * @summary Reject Course Invitation
     * @param courseId ID
     * @param id ID
     */
    public async rejectCourseInvitation (courseId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/courses/{course_id}/enrollments/{id}/reject'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling rejectCourseInvitation.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling rejectCourseInvitation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns a JSON Object containing the temporary enrollment status for a user.
     * @summary Show Temporary Enrollment recipient and provider status
     * @param userId ID
     * @param accountId The ID of the account to check for temporary enrollment status. Defaults to the domain root account if not provided.
     */
    public async showTemporaryEnrollmentRecipientAndProviderStatus (userId: string, accountId?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/users/{user_id}/temporary_enrollment_status'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling showTemporaryEnrollmentRecipientAndProviderStatus.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['account_id'] = ObjectSerializer.serialize(accountId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
