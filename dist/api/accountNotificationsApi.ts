/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { AccountNotification } from '../model/accountNotification';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum AccountNotificationsApiApiKeys {
}

export class AccountNotificationsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: AccountNotificationsApiApiKeys, value: string) {
        (this.authentications as any)[AccountNotificationsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * If the current user no longer wants to see this account notification, it can be closed with this call. This affects the current user only.  If the current user is an admin and they pass a remove parameter with a value of \"true\", the account notification will be destroyed. This affects all users.
     * @summary Close notification for user. Destroy notification for admin
     * @param accountId ID
     * @param id ID
     * @param remove Destroy the account notification.
     */
    public async closeNotificationForUserDestroyNotificationForAdmin (accountId: string, id: string, remove?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AccountNotification;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/account_notifications/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling closeNotificationForUserDestroyNotificationForAdmin.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling closeNotificationForUserDestroyNotificationForAdmin.');
        }

        if (remove !== undefined) {
            localVarQueryParameters['remove'] = ObjectSerializer.serialize(remove, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AccountNotification;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AccountNotification");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Create and return a new global notification for an account.
     * @summary Create a global notification
     * @param accountId ID
     * @param accountNotificationSubject The subject of the notification.
     * @param accountNotificationMessage The message body of the notification.
     * @param accountNotificationStartAt The start date and time of the notification in ISO8601 format. e.g. 2014-01-01T01:00Z
     * @param accountNotificationEndAt The end date and time of the notification in ISO8601 format. e.g. 2014-01-01T01:00Z
     * @param accountNotificationIcon The icon to display with the notification. Note: Defaults to warning.
     * @param accountNotificationRoles The role(s) to send global notification to.  Note:  ommitting this field will send to everyone Example:   account_notification_roles: [\\\&quot;StudentEnrollment\\\&quot;, \\\&quot;TeacherEnrollment\\\&quot;]
     */
    public async createGlobalNotification (accountId: string, accountNotificationSubject: string, accountNotificationMessage: string, accountNotificationStartAt: Date, accountNotificationEndAt: Date, accountNotificationIcon?: string, accountNotificationRoles?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/account_notifications'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createGlobalNotification.');
        }

        // verify required parameter 'accountNotificationSubject' is not null or undefined
        if (accountNotificationSubject === null || accountNotificationSubject === undefined) {
            throw new Error('Required parameter accountNotificationSubject was null or undefined when calling createGlobalNotification.');
        }

        // verify required parameter 'accountNotificationMessage' is not null or undefined
        if (accountNotificationMessage === null || accountNotificationMessage === undefined) {
            throw new Error('Required parameter accountNotificationMessage was null or undefined when calling createGlobalNotification.');
        }

        // verify required parameter 'accountNotificationStartAt' is not null or undefined
        if (accountNotificationStartAt === null || accountNotificationStartAt === undefined) {
            throw new Error('Required parameter accountNotificationStartAt was null or undefined when calling createGlobalNotification.');
        }

        // verify required parameter 'accountNotificationEndAt' is not null or undefined
        if (accountNotificationEndAt === null || accountNotificationEndAt === undefined) {
            throw new Error('Required parameter accountNotificationEndAt was null or undefined when calling createGlobalNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (accountNotificationSubject !== undefined) {
            localVarFormParams['account_notification[subject]'] = ObjectSerializer.serialize(accountNotificationSubject, "string");
        }

        if (accountNotificationMessage !== undefined) {
            localVarFormParams['account_notification[message]'] = ObjectSerializer.serialize(accountNotificationMessage, "string");
        }

        if (accountNotificationStartAt !== undefined) {
            localVarFormParams['account_notification[start_at]'] = ObjectSerializer.serialize(accountNotificationStartAt, "Date");
        }

        if (accountNotificationEndAt !== undefined) {
            localVarFormParams['account_notification[end_at]'] = ObjectSerializer.serialize(accountNotificationEndAt, "Date");
        }

        if (accountNotificationIcon !== undefined) {
            localVarFormParams['account_notification[icon]'] = ObjectSerializer.serialize(accountNotificationIcon, "string");
        }

        if (accountNotificationRoles !== undefined) {
            localVarFormParams['account_notification_roles'] = ObjectSerializer.serialize(accountNotificationRoles, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns a list of all global notifications in the account for the current user Any notifications that have been closed by the user will not be returned, unless a include_past parameter is passed in as true. Admins can request all global notifications for the account by passing in an include_all parameter.
     * @summary Index of active global notification for the user
     * @param accountId ID
     * @param includePast Include past and dismissed global announcements.
     * @param includeAll Include all global announcements, regardless of user\&#39;s role or availability date. Only available to account admins.
     * @param showIsClosed Include a flag for each notification indicating whether it has been read by the user.
     */
    public async indexOfActiveGlobalNotificationForUser (accountId: string, includePast?: boolean, includeAll?: boolean, showIsClosed?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<AccountNotification>;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/account_notifications'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling indexOfActiveGlobalNotificationForUser.');
        }

        if (includePast !== undefined) {
            localVarQueryParameters['include_past'] = ObjectSerializer.serialize(includePast, "boolean");
        }

        if (includeAll !== undefined) {
            localVarQueryParameters['include_all'] = ObjectSerializer.serialize(includeAll, "boolean");
        }

        if (showIsClosed !== undefined) {
            localVarQueryParameters['show_is_closed'] = ObjectSerializer.serialize(showIsClosed, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<AccountNotification>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<AccountNotification>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns a global notification for the current user A notification that has been closed by the user will not be returned
     * @summary Show a global notification
     * @param accountId ID
     * @param id ID
     */
    public async showGlobalNotification (accountId: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AccountNotification;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/account_notifications/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling showGlobalNotification.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling showGlobalNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AccountNotification;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AccountNotification");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update global notification for an account.
     * @summary Update a global notification
     * @param accountId ID
     * @param id ID
     * @param accountNotificationSubject The subject of the notification.
     * @param accountNotificationMessage The message body of the notification.
     * @param accountNotificationStartAt The start date and time of the notification in ISO8601 format. e.g. 2014-01-01T01:00Z
     * @param accountNotificationEndAt The end date and time of the notification in ISO8601 format. e.g. 2014-01-01T01:00Z
     * @param accountNotificationIcon The icon to display with the notification.
     * @param accountNotificationRoles The role(s) to send global notification to.  Note:  ommitting this field will send to everyone Example:   account_notification_roles: [\\\&quot;StudentEnrollment\\\&quot;, \\\&quot;TeacherEnrollment\\\&quot;]
     */
    public async updateGlobalNotification (accountId: string, id: string, accountNotificationSubject?: string, accountNotificationMessage?: string, accountNotificationStartAt?: Date, accountNotificationEndAt?: Date, accountNotificationIcon?: string, accountNotificationRoles?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account_id}/account_notifications/{id}'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateGlobalNotification.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateGlobalNotification.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (accountNotificationSubject !== undefined) {
            localVarFormParams['account_notification[subject]'] = ObjectSerializer.serialize(accountNotificationSubject, "string");
        }

        if (accountNotificationMessage !== undefined) {
            localVarFormParams['account_notification[message]'] = ObjectSerializer.serialize(accountNotificationMessage, "string");
        }

        if (accountNotificationStartAt !== undefined) {
            localVarFormParams['account_notification[start_at]'] = ObjectSerializer.serialize(accountNotificationStartAt, "Date");
        }

        if (accountNotificationEndAt !== undefined) {
            localVarFormParams['account_notification[end_at]'] = ObjectSerializer.serialize(accountNotificationEndAt, "Date");
        }

        if (accountNotificationIcon !== undefined) {
            localVarFormParams['account_notification[icon]'] = ObjectSerializer.serialize(accountNotificationIcon, "string");
        }

        if (accountNotificationRoles !== undefined) {
            localVarFormParams['account_notification_roles'] = ObjectSerializer.serialize(accountNotificationRoles, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
