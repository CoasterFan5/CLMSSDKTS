/**
 * Title was not specified
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://canvas.instructure.com/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum SisIntegrationApiApiKeys {
}

export class SisIntegrationApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: SisIntegrationApiApiKeys, value: string) {
        (this.authentications as any)[SisIntegrationApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Disable all assignments flagged as \"post_to_sis\", with the option of making it specific to a grading period, in a course.  On success, the response will be 204 No Content with an empty body.  On failure, the response will be 400 Bad Request with a body of a specific message.  For disabling assignments in a specific grading period
     * @summary Disable assignments currently enabled for grade export to SIS
     * @param courseId The ID of the course.
     * @param gradingPeriodId The ID of the grading period.
     */
    public async disableAssignmentsCurrentlyEnabledForGradeExportToSis (courseId: number, gradingPeriodId?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/sis/courses/{course_id}/disable_post_to_sis'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling disableAssignmentsCurrentlyEnabledForGradeExportToSis.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (gradingPeriodId !== undefined) {
            localVarFormParams['grading_period_id'] = ObjectSerializer.serialize(gradingPeriodId, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve a list of published assignments flagged as \"post_to_sis\". See the Assignments API for more details on assignments. Assignment group and section information are included for convenience.  Each section includes course information for the origin course and the cross-listed course, if applicable. The `origin_course` is the course to which the section belongs or the course from which the section was cross-listed. Generally, the `origin_course` should be preferred when performing integration work. The `xlist_course` is provided for consistency and is only present when the section has been cross-listed. See Sections API and Courses Api for me details.  The `override` is only provided if the Differentiated Assignments course feature is turned on and the assignment has an override for that section. When there is an override for the assignment the override object\'s keys/values can be merged with the top level assignment object to create a view of the assignment object specific to that section. See Assignments api for more information on assignment overrides.  restricts to courses that start before this date (if they have a start date) restricts to courses that end after this date (if they have an end date) information to include.    \"student_overrides\":: returns individual student override information
     * @summary Retrieve assignments enabled for grade export to SIS
     * @param accountId The ID of the account to query.
     * @param courseId The ID of the course to query.
     * @param startsBefore When searching on an account,
     * @param endsAfter When searching on an account,
     * @param include Array of additional
     */
    public async retrieveAssignmentsEnabledForGradeExportToSisAccounts (accountId: number, courseId?: number, startsBefore?: Date, endsAfter?: Date, include?: 'student_overrides', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/sis/accounts/{account_id}/assignments'
            .replace('{' + 'account_id' + '}', encodeURIComponent(String(accountId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling retrieveAssignmentsEnabledForGradeExportToSisAccounts.');
        }

        if (courseId !== undefined) {
            localVarQueryParameters['course_id'] = ObjectSerializer.serialize(courseId, "number");
        }

        if (startsBefore !== undefined) {
            localVarQueryParameters['starts_before'] = ObjectSerializer.serialize(startsBefore, "Date");
        }

        if (endsAfter !== undefined) {
            localVarQueryParameters['ends_after'] = ObjectSerializer.serialize(endsAfter, "Date");
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "'student_overrides'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve a list of published assignments flagged as \"post_to_sis\". See the Assignments API for more details on assignments. Assignment group and section information are included for convenience.  Each section includes course information for the origin course and the cross-listed course, if applicable. The `origin_course` is the course to which the section belongs or the course from which the section was cross-listed. Generally, the `origin_course` should be preferred when performing integration work. The `xlist_course` is provided for consistency and is only present when the section has been cross-listed. See Sections API and Courses Api for me details.  The `override` is only provided if the Differentiated Assignments course feature is turned on and the assignment has an override for that section. When there is an override for the assignment the override object\'s keys/values can be merged with the top level assignment object to create a view of the assignment object specific to that section. See Assignments api for more information on assignment overrides.  restricts to courses that start before this date (if they have a start date) restricts to courses that end after this date (if they have an end date) information to include.    \"student_overrides\":: returns individual student override information
     * @summary Retrieve assignments enabled for grade export to SIS
     * @param courseId The ID of the course to query.
     * @param accountId The ID of the account to query.
     * @param startsBefore When searching on an account,
     * @param endsAfter When searching on an account,
     * @param include Array of additional
     */
    public async retrieveAssignmentsEnabledForGradeExportToSisCourses (courseId: number, accountId?: number, startsBefore?: Date, endsAfter?: Date, include?: 'student_overrides', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/sis/courses/{course_id}/assignments'
            .replace('{' + 'course_id' + '}', encodeURIComponent(String(courseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'courseId' is not null or undefined
        if (courseId === null || courseId === undefined) {
            throw new Error('Required parameter courseId was null or undefined when calling retrieveAssignmentsEnabledForGradeExportToSisCourses.');
        }

        if (accountId !== undefined) {
            localVarQueryParameters['account_id'] = ObjectSerializer.serialize(accountId, "number");
        }

        if (startsBefore !== undefined) {
            localVarQueryParameters['starts_before'] = ObjectSerializer.serialize(startsBefore, "Date");
        }

        if (endsAfter !== undefined) {
            localVarQueryParameters['ends_after'] = ObjectSerializer.serialize(endsAfter, "Date");
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "'student_overrides'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
